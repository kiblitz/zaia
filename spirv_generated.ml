[@@@warning "-32"]
open Core
module Requirements =
  struct
    module Version =
      struct
        module T =
          struct
            type t =
              | V1_0 
              | V1_1 
              | V1_2 
              | V1_3 
              | V1_4 
              | V1_5 
              | V1_6 [@@deriving compare, sexp_of, enumerate]
          end
        include T
        include (Comparable.Make_plain)(T)
        let major =
          function
          | V1_0 -> 1l
          | V1_1 -> 1l
          | V1_2 -> 1l
          | V1_3 -> 1l
          | V1_4 -> 1l
          | V1_5 -> 1l
          | V1_6 -> 1l
        let minor =
          function
          | V1_0 -> 0l
          | V1_1 -> 1l
          | V1_2 -> 2l
          | V1_3 -> 3l
          | V1_4 -> 4l
          | V1_5 -> 5l
          | V1_6 -> 6l
        let value t =
          let major_value = Int32.shift_left (major t) 16 in
          let minor_value = Int32.shift_left (minor t) 8 in
          Int32.bit_or minor_value major_value
        let valid_versions ~required ~last =
          List.filter all
            ~f:(fun t ->
                  (Option.value_map required ~default:true
                     ~f:(fun required -> t >= required))
                    &&
                    (Option.value_map last ~default:true
                       ~f:(fun last -> t <= last)))
      end
    module Extension =
      struct
        module T =
          struct
            type t =
              | Spv_altera_arbitrary_precision_fixed_point 
              | Spv_altera_arbitrary_precision_floating_point 
              | Spv_altera_arbitrary_precision_integers 
              | Spv_altera_blocking_pipes 
              | Spv_altera_fpga_argument_interfaces 
              | Spv_altera_fpga_buffer_location 
              | Spv_altera_fpga_cluster_attributes 
              | Spv_altera_fpga_dsp_control 
              | Spv_altera_fpga_invocation_pipelining_attributes 
              | Spv_altera_fpga_latency_control 
              | Spv_altera_fpga_loop_controls 
              | Spv_altera_fpga_memory_accesses 
              | Spv_altera_fpga_memory_attributes 
              | Spv_altera_fpga_reg 
              | Spv_altera_global_variable_fpga_decorations 
              | Spv_altera_io_pipes 
              | Spv_altera_loop_fuse 
              | Spv_altera_runtime_aligned 
              | Spv_altera_task_sequence 
              | Spv_altera_usm_storage_classes 
              | Spv_amdx_shader_enqueue 
              | Spv_amd_gpu_shader_half_float_fetch 
              | Spv_amd_shader_ballot 
              | Spv_amd_shader_early_and_late_fragment_tests 
              | Spv_amd_shader_explicit_vertex_parameter 
              | Spv_amd_shader_fragment_mask 
              | Spv_amd_shader_image_load_store_lod 
              | Spv_amd_texture_gather_bias_lod 
              | Spv_arm_cooperative_matrix_layouts 
              | Spv_arm_core_builtins 
              | Spv_arm_graph 
              | Spv_arm_tensors 
              | Spv_ext_arithmetic_fence 
              | Spv_ext_demote_to_helper_invocation 
              | Spv_ext_descriptor_indexing 
              | Spv_ext_float8 
              | Spv_ext_fragment_fully_covered 
              | Spv_ext_fragment_invocation_density 
              | Spv_ext_fragment_shader_interlock 
              | Spv_ext_long_vector 
              | Spv_ext_mesh_shader 
              | Spv_ext_opacity_micromap 
              | Spv_ext_optnone 
              | Spv_ext_physical_storage_buffer 
              | Spv_ext_replicated_composites 
              | Spv_ext_shader_64bit_indexing 
              | Spv_ext_shader_atomic_float16_add 
              | Spv_ext_shader_atomic_float_add 
              | Spv_ext_shader_atomic_float_min_max 
              | Spv_ext_shader_image_int64 
              | Spv_ext_shader_invocation_reorder 
              | Spv_ext_shader_stencil_export 
              | Spv_ext_shader_tile_image 
              | Spv_ext_shader_viewport_index_layer 
              | Spv_google_decorate_string 
              | Spv_google_hlsl_functionality1 
              | Spv_google_user_type 
              | Spv_intel_2d_block_io 
              | Spv_intel_arbitrary_precision_fixed_point 
              | Spv_intel_arbitrary_precision_floating_point 
              | Spv_intel_arbitrary_precision_integers 
              | Spv_intel_bfloat16_conversion 
              | Spv_intel_bindless_images 
              | Spv_intel_blocking_pipes 
              | Spv_intel_cache_controls 
              | Spv_intel_debug_module 
              | Spv_intel_device_side_avc_motion_estimation 
              | Spv_intel_float_controls2 
              | Spv_intel_fp_fast_math_mode 
              | Spv_intel_fp_max_error 
              | Spv_intel_fpga_argument_interfaces 
              | Spv_intel_fpga_buffer_location 
              | Spv_intel_fpga_cluster_attributes 
              | Spv_intel_fpga_dsp_control 
              | Spv_intel_fpga_invocation_pipelining_attributes 
              | Spv_intel_fpga_latency_control 
              | Spv_intel_fpga_loop_controls 
              | Spv_intel_fpga_memory_accesses 
              | Spv_intel_fpga_memory_attributes 
              | Spv_intel_fpga_reg 
              | Spv_intel_function_pointers 
              | Spv_intel_function_variants 
              | Spv_intel_global_variable_fpga_decorations 
              | Spv_intel_global_variable_host_access 
              | Spv_intel_inline_assembly 
              | Spv_intel_int4 
              | Spv_intel_io_pipes 
              | Spv_intel_kernel_attributes 
              | Spv_intel_long_composites 
              | Spv_intel_loop_fuse 
              | Spv_intel_masked_gather_scatter 
              | Spv_intel_maximum_registers 
              | Spv_intel_media_block_io 
              | Spv_intel_memory_access_aliasing 
              | Spv_intel_optnone 
              | Spv_intel_runtime_aligned 
              | Spv_intel_shader_integer_functions2 
              | Spv_intel_split_barrier 
              | Spv_intel_subgroup_buffer_prefetch 
              | Spv_intel_subgroup_matrix_multiply_accumulate 
              | Spv_intel_subgroups 
              | Spv_intel_task_sequence 
              | Spv_intel_tensor_float32_conversion 
              | Spv_intel_ternary_bitwise_function 
              | Spv_intel_unstructured_loop_controls 
              | Spv_intel_usm_storage_classes 
              | Spv_intel_variable_length_array 
              | Spv_intel_vector_compute 
              | Spv_khr_16bit_storage 
              | Spv_khr_8bit_storage 
              | Spv_khr_bfloat16 
              | Spv_khr_bit_instructions 
              | Spv_khr_compute_shader_derivatives 
              | Spv_khr_cooperative_matrix 
              | Spv_khr_device_group 
              | Spv_khr_expect_assume 
              | Spv_khr_float_controls 
              | Spv_khr_float_controls2 
              | Spv_khr_fma 
              | Spv_khr_fragment_shader_barycentric 
              | Spv_khr_fragment_shading_rate 
              | Spv_khr_integer_dot_product 
              | Spv_khr_linkonce_odr 
              | Spv_khr_maximal_reconvergence 
              | Spv_khr_multiview 
              | Spv_khr_no_integer_wrap_decoration 
              | Spv_khr_physical_storage_buffer 
              | Spv_khr_post_depth_coverage 
              | Spv_khr_quad_control 
              | Spv_khr_ray_cull_mask 
              | Spv_khr_ray_query 
              | Spv_khr_ray_tracing 
              | Spv_khr_ray_tracing_position_fetch 
              | Spv_khr_relaxed_extended_instruction 
              | Spv_khr_shader_atomic_counter_ops 
              | Spv_khr_shader_ballot 
              | Spv_khr_shader_clock 
              | Spv_khr_shader_draw_parameters 
              | Spv_khr_storage_buffer_storage_class 
              | Spv_khr_subgroup_rotate 
              | Spv_khr_subgroup_uniform_control_flow 
              | Spv_khr_subgroup_vote 
              | Spv_khr_terminate_invocation 
              | Spv_khr_uniform_group_instructions 
              | Spv_khr_untyped_pointers 
              | Spv_khr_variable_pointers 
              | Spv_khr_vulkan_memory_model 
              | Spv_khr_workgroup_memory_explicit_layout 
              | Spv_nvx_multiview_per_view_attributes 
              | Spv_nv_bindless_texture 
              | Spv_nv_cluster_acceleration_structure 
              | Spv_nv_compute_shader_derivatives 
              | Spv_nv_cooperative_matrix 
              | Spv_nv_cooperative_matrix2 
              | Spv_nv_cooperative_vector 
              | Spv_nv_displacement_micromap 
              | Spv_nv_fragment_shader_barycentric 
              | Spv_nv_geometry_shader_passthrough 
              | Spv_nv_linear_swept_spheres 
              | Spv_nv_mesh_shader 
              | Spv_nv_raw_access_chains 
              | Spv_nv_ray_tracing 
              | Spv_nv_ray_tracing_motion_blur 
              | Spv_nv_sample_mask_override_coverage 
              | Spv_nv_shader_atomic_fp16_vector 
              | Spv_nv_shader_image_footprint 
              | Spv_nv_shader_invocation_reorder 
              | Spv_nv_shader_sm_builtins 
              | Spv_nv_shader_subgroup_partitioned 
              | Spv_nv_shading_rate 
              | Spv_nv_stereo_view_rendering 
              | Spv_nv_tensor_addressing 
              | Spv_nv_viewport_array2 
              | Spv_qcom_cooperative_matrix_conversion 
              | Spv_qcom_image_processing 
              | Spv_qcom_image_processing2 
              | Spv_qcom_tile_shading [@@deriving
                                        compare, sexp_of, enumerate]
          end
        include T
        include (Comparable.Make_plain)(T)
        let to_string =
          function
          | Spv_altera_arbitrary_precision_fixed_point ->
              "SPV_ALTERA_arbitrary_precision_fixed_point"
          | Spv_altera_arbitrary_precision_floating_point ->
              "SPV_ALTERA_arbitrary_precision_floating_point"
          | Spv_altera_arbitrary_precision_integers ->
              "SPV_ALTERA_arbitrary_precision_integers"
          | Spv_altera_blocking_pipes -> "SPV_ALTERA_blocking_pipes"
          | Spv_altera_fpga_argument_interfaces ->
              "SPV_ALTERA_fpga_argument_interfaces"
          | Spv_altera_fpga_buffer_location ->
              "SPV_ALTERA_fpga_buffer_location"
          | Spv_altera_fpga_cluster_attributes ->
              "SPV_ALTERA_fpga_cluster_attributes"
          | Spv_altera_fpga_dsp_control -> "SPV_ALTERA_fpga_dsp_control"
          | Spv_altera_fpga_invocation_pipelining_attributes ->
              "SPV_ALTERA_fpga_invocation_pipelining_attributes"
          | Spv_altera_fpga_latency_control ->
              "SPV_ALTERA_fpga_latency_control"
          | Spv_altera_fpga_loop_controls -> "SPV_ALTERA_fpga_loop_controls"
          | Spv_altera_fpga_memory_accesses ->
              "SPV_ALTERA_fpga_memory_accesses"
          | Spv_altera_fpga_memory_attributes ->
              "SPV_ALTERA_fpga_memory_attributes"
          | Spv_altera_fpga_reg -> "SPV_ALTERA_fpga_reg"
          | Spv_altera_global_variable_fpga_decorations ->
              "SPV_ALTERA_global_variable_fpga_decorations"
          | Spv_altera_io_pipes -> "SPV_ALTERA_io_pipes"
          | Spv_altera_loop_fuse -> "SPV_ALTERA_loop_fuse"
          | Spv_altera_runtime_aligned -> "SPV_ALTERA_runtime_aligned"
          | Spv_altera_task_sequence -> "SPV_ALTERA_task_sequence"
          | Spv_altera_usm_storage_classes ->
              "SPV_ALTERA_usm_storage_classes"
          | Spv_amdx_shader_enqueue -> "SPV_AMDX_shader_enqueue"
          | Spv_amd_gpu_shader_half_float_fetch ->
              "SPV_AMD_gpu_shader_half_float_fetch"
          | Spv_amd_shader_ballot -> "SPV_AMD_shader_ballot"
          | Spv_amd_shader_early_and_late_fragment_tests ->
              "SPV_AMD_shader_early_and_late_fragment_tests"
          | Spv_amd_shader_explicit_vertex_parameter ->
              "SPV_AMD_shader_explicit_vertex_parameter"
          | Spv_amd_shader_fragment_mask -> "SPV_AMD_shader_fragment_mask"
          | Spv_amd_shader_image_load_store_lod ->
              "SPV_AMD_shader_image_load_store_lod"
          | Spv_amd_texture_gather_bias_lod ->
              "SPV_AMD_texture_gather_bias_lod"
          | Spv_arm_cooperative_matrix_layouts ->
              "SPV_ARM_cooperative_matrix_layouts"
          | Spv_arm_core_builtins -> "SPV_ARM_core_builtins"
          | Spv_arm_graph -> "SPV_ARM_graph"
          | Spv_arm_tensors -> "SPV_ARM_tensors"
          | Spv_ext_arithmetic_fence -> "SPV_EXT_arithmetic_fence"
          | Spv_ext_demote_to_helper_invocation ->
              "SPV_EXT_demote_to_helper_invocation"
          | Spv_ext_descriptor_indexing -> "SPV_EXT_descriptor_indexing"
          | Spv_ext_float8 -> "SPV_EXT_float8"
          | Spv_ext_fragment_fully_covered ->
              "SPV_EXT_fragment_fully_covered"
          | Spv_ext_fragment_invocation_density ->
              "SPV_EXT_fragment_invocation_density"
          | Spv_ext_fragment_shader_interlock ->
              "SPV_EXT_fragment_shader_interlock"
          | Spv_ext_long_vector -> "SPV_EXT_long_vector"
          | Spv_ext_mesh_shader -> "SPV_EXT_mesh_shader"
          | Spv_ext_opacity_micromap -> "SPV_EXT_opacity_micromap"
          | Spv_ext_optnone -> "SPV_EXT_optnone"
          | Spv_ext_physical_storage_buffer ->
              "SPV_EXT_physical_storage_buffer"
          | Spv_ext_replicated_composites -> "SPV_EXT_replicated_composites"
          | Spv_ext_shader_64bit_indexing -> "SPV_EXT_shader_64bit_indexing"
          | Spv_ext_shader_atomic_float16_add ->
              "SPV_EXT_shader_atomic_float16_add"
          | Spv_ext_shader_atomic_float_add ->
              "SPV_EXT_shader_atomic_float_add"
          | Spv_ext_shader_atomic_float_min_max ->
              "SPV_EXT_shader_atomic_float_min_max"
          | Spv_ext_shader_image_int64 -> "SPV_EXT_shader_image_int64"
          | Spv_ext_shader_invocation_reorder ->
              "SPV_EXT_shader_invocation_reorder"
          | Spv_ext_shader_stencil_export -> "SPV_EXT_shader_stencil_export"
          | Spv_ext_shader_tile_image -> "SPV_EXT_shader_tile_image"
          | Spv_ext_shader_viewport_index_layer ->
              "SPV_EXT_shader_viewport_index_layer"
          | Spv_google_decorate_string -> "SPV_GOOGLE_decorate_string"
          | Spv_google_hlsl_functionality1 ->
              "SPV_GOOGLE_hlsl_functionality1"
          | Spv_google_user_type -> "SPV_GOOGLE_user_type"
          | Spv_intel_2d_block_io -> "SPV_INTEL_2d_block_io"
          | Spv_intel_arbitrary_precision_fixed_point ->
              "SPV_INTEL_arbitrary_precision_fixed_point"
          | Spv_intel_arbitrary_precision_floating_point ->
              "SPV_INTEL_arbitrary_precision_floating_point"
          | Spv_intel_arbitrary_precision_integers ->
              "SPV_INTEL_arbitrary_precision_integers"
          | Spv_intel_bfloat16_conversion -> "SPV_INTEL_bfloat16_conversion"
          | Spv_intel_bindless_images -> "SPV_INTEL_bindless_images"
          | Spv_intel_blocking_pipes -> "SPV_INTEL_blocking_pipes"
          | Spv_intel_cache_controls -> "SPV_INTEL_cache_controls"
          | Spv_intel_debug_module -> "SPV_INTEL_debug_module"
          | Spv_intel_device_side_avc_motion_estimation ->
              "SPV_INTEL_device_side_avc_motion_estimation"
          | Spv_intel_float_controls2 -> "SPV_INTEL_float_controls2"
          | Spv_intel_fp_fast_math_mode -> "SPV_INTEL_fp_fast_math_mode"
          | Spv_intel_fp_max_error -> "SPV_INTEL_fp_max_error"
          | Spv_intel_fpga_argument_interfaces ->
              "SPV_INTEL_fpga_argument_interfaces"
          | Spv_intel_fpga_buffer_location ->
              "SPV_INTEL_fpga_buffer_location"
          | Spv_intel_fpga_cluster_attributes ->
              "SPV_INTEL_fpga_cluster_attributes"
          | Spv_intel_fpga_dsp_control -> "SPV_INTEL_fpga_dsp_control"
          | Spv_intel_fpga_invocation_pipelining_attributes ->
              "SPV_INTEL_fpga_invocation_pipelining_attributes"
          | Spv_intel_fpga_latency_control ->
              "SPV_INTEL_fpga_latency_control"
          | Spv_intel_fpga_loop_controls -> "SPV_INTEL_fpga_loop_controls"
          | Spv_intel_fpga_memory_accesses ->
              "SPV_INTEL_fpga_memory_accesses"
          | Spv_intel_fpga_memory_attributes ->
              "SPV_INTEL_fpga_memory_attributes"
          | Spv_intel_fpga_reg -> "SPV_INTEL_fpga_reg"
          | Spv_intel_function_pointers -> "SPV_INTEL_function_pointers"
          | Spv_intel_function_variants -> "SPV_INTEL_function_variants"
          | Spv_intel_global_variable_fpga_decorations ->
              "SPV_INTEL_global_variable_fpga_decorations"
          | Spv_intel_global_variable_host_access ->
              "SPV_INTEL_global_variable_host_access"
          | Spv_intel_inline_assembly -> "SPV_INTEL_inline_assembly"
          | Spv_intel_int4 -> "SPV_INTEL_int4"
          | Spv_intel_io_pipes -> "SPV_INTEL_io_pipes"
          | Spv_intel_kernel_attributes -> "SPV_INTEL_kernel_attributes"
          | Spv_intel_long_composites -> "SPV_INTEL_long_composites"
          | Spv_intel_loop_fuse -> "SPV_INTEL_loop_fuse"
          | Spv_intel_masked_gather_scatter ->
              "SPV_INTEL_masked_gather_scatter"
          | Spv_intel_maximum_registers -> "SPV_INTEL_maximum_registers"
          | Spv_intel_media_block_io -> "SPV_INTEL_media_block_io"
          | Spv_intel_memory_access_aliasing ->
              "SPV_INTEL_memory_access_aliasing"
          | Spv_intel_optnone -> "SPV_INTEL_optnone"
          | Spv_intel_runtime_aligned -> "SPV_INTEL_runtime_aligned"
          | Spv_intel_shader_integer_functions2 ->
              "SPV_INTEL_shader_integer_functions2"
          | Spv_intel_split_barrier -> "SPV_INTEL_split_barrier"
          | Spv_intel_subgroup_buffer_prefetch ->
              "SPV_INTEL_subgroup_buffer_prefetch"
          | Spv_intel_subgroup_matrix_multiply_accumulate ->
              "SPV_INTEL_subgroup_matrix_multiply_accumulate"
          | Spv_intel_subgroups -> "SPV_INTEL_subgroups"
          | Spv_intel_task_sequence -> "SPV_INTEL_task_sequence"
          | Spv_intel_tensor_float32_conversion ->
              "SPV_INTEL_tensor_float32_conversion"
          | Spv_intel_ternary_bitwise_function ->
              "SPV_INTEL_ternary_bitwise_function"
          | Spv_intel_unstructured_loop_controls ->
              "SPV_INTEL_unstructured_loop_controls"
          | Spv_intel_usm_storage_classes -> "SPV_INTEL_usm_storage_classes"
          | Spv_intel_variable_length_array ->
              "SPV_INTEL_variable_length_array"
          | Spv_intel_vector_compute -> "SPV_INTEL_vector_compute"
          | Spv_khr_16bit_storage -> "SPV_KHR_16bit_storage"
          | Spv_khr_8bit_storage -> "SPV_KHR_8bit_storage"
          | Spv_khr_bfloat16 -> "SPV_KHR_bfloat16"
          | Spv_khr_bit_instructions -> "SPV_KHR_bit_instructions"
          | Spv_khr_compute_shader_derivatives ->
              "SPV_KHR_compute_shader_derivatives"
          | Spv_khr_cooperative_matrix -> "SPV_KHR_cooperative_matrix"
          | Spv_khr_device_group -> "SPV_KHR_device_group"
          | Spv_khr_expect_assume -> "SPV_KHR_expect_assume"
          | Spv_khr_float_controls -> "SPV_KHR_float_controls"
          | Spv_khr_float_controls2 -> "SPV_KHR_float_controls2"
          | Spv_khr_fma -> "SPV_KHR_fma"
          | Spv_khr_fragment_shader_barycentric ->
              "SPV_KHR_fragment_shader_barycentric"
          | Spv_khr_fragment_shading_rate -> "SPV_KHR_fragment_shading_rate"
          | Spv_khr_integer_dot_product -> "SPV_KHR_integer_dot_product"
          | Spv_khr_linkonce_odr -> "SPV_KHR_linkonce_odr"
          | Spv_khr_maximal_reconvergence -> "SPV_KHR_maximal_reconvergence"
          | Spv_khr_multiview -> "SPV_KHR_multiview"
          | Spv_khr_no_integer_wrap_decoration ->
              "SPV_KHR_no_integer_wrap_decoration"
          | Spv_khr_physical_storage_buffer ->
              "SPV_KHR_physical_storage_buffer"
          | Spv_khr_post_depth_coverage -> "SPV_KHR_post_depth_coverage"
          | Spv_khr_quad_control -> "SPV_KHR_quad_control"
          | Spv_khr_ray_cull_mask -> "SPV_KHR_ray_cull_mask"
          | Spv_khr_ray_query -> "SPV_KHR_ray_query"
          | Spv_khr_ray_tracing -> "SPV_KHR_ray_tracing"
          | Spv_khr_ray_tracing_position_fetch ->
              "SPV_KHR_ray_tracing_position_fetch"
          | Spv_khr_relaxed_extended_instruction ->
              "SPV_KHR_relaxed_extended_instruction"
          | Spv_khr_shader_atomic_counter_ops ->
              "SPV_KHR_shader_atomic_counter_ops"
          | Spv_khr_shader_ballot -> "SPV_KHR_shader_ballot"
          | Spv_khr_shader_clock -> "SPV_KHR_shader_clock"
          | Spv_khr_shader_draw_parameters ->
              "SPV_KHR_shader_draw_parameters"
          | Spv_khr_storage_buffer_storage_class ->
              "SPV_KHR_storage_buffer_storage_class"
          | Spv_khr_subgroup_rotate -> "SPV_KHR_subgroup_rotate"
          | Spv_khr_subgroup_uniform_control_flow ->
              "SPV_KHR_subgroup_uniform_control_flow"
          | Spv_khr_subgroup_vote -> "SPV_KHR_subgroup_vote"
          | Spv_khr_terminate_invocation -> "SPV_KHR_terminate_invocation"
          | Spv_khr_uniform_group_instructions ->
              "SPV_KHR_uniform_group_instructions"
          | Spv_khr_untyped_pointers -> "SPV_KHR_untyped_pointers"
          | Spv_khr_variable_pointers -> "SPV_KHR_variable_pointers"
          | Spv_khr_vulkan_memory_model -> "SPV_KHR_vulkan_memory_model"
          | Spv_khr_workgroup_memory_explicit_layout ->
              "SPV_KHR_workgroup_memory_explicit_layout"
          | Spv_nvx_multiview_per_view_attributes ->
              "SPV_NVX_multiview_per_view_attributes"
          | Spv_nv_bindless_texture -> "SPV_NV_bindless_texture"
          | Spv_nv_cluster_acceleration_structure ->
              "SPV_NV_cluster_acceleration_structure"
          | Spv_nv_compute_shader_derivatives ->
              "SPV_NV_compute_shader_derivatives"
          | Spv_nv_cooperative_matrix -> "SPV_NV_cooperative_matrix"
          | Spv_nv_cooperative_matrix2 -> "SPV_NV_cooperative_matrix2"
          | Spv_nv_cooperative_vector -> "SPV_NV_cooperative_vector"
          | Spv_nv_displacement_micromap -> "SPV_NV_displacement_micromap"
          | Spv_nv_fragment_shader_barycentric ->
              "SPV_NV_fragment_shader_barycentric"
          | Spv_nv_geometry_shader_passthrough ->
              "SPV_NV_geometry_shader_passthrough"
          | Spv_nv_linear_swept_spheres -> "SPV_NV_linear_swept_spheres"
          | Spv_nv_mesh_shader -> "SPV_NV_mesh_shader"
          | Spv_nv_raw_access_chains -> "SPV_NV_raw_access_chains"
          | Spv_nv_ray_tracing -> "SPV_NV_ray_tracing"
          | Spv_nv_ray_tracing_motion_blur ->
              "SPV_NV_ray_tracing_motion_blur"
          | Spv_nv_sample_mask_override_coverage ->
              "SPV_NV_sample_mask_override_coverage"
          | Spv_nv_shader_atomic_fp16_vector ->
              "SPV_NV_shader_atomic_fp16_vector"
          | Spv_nv_shader_image_footprint -> "SPV_NV_shader_image_footprint"
          | Spv_nv_shader_invocation_reorder ->
              "SPV_NV_shader_invocation_reorder"
          | Spv_nv_shader_sm_builtins -> "SPV_NV_shader_sm_builtins"
          | Spv_nv_shader_subgroup_partitioned ->
              "SPV_NV_shader_subgroup_partitioned"
          | Spv_nv_shading_rate -> "SPV_NV_shading_rate"
          | Spv_nv_stereo_view_rendering -> "SPV_NV_stereo_view_rendering"
          | Spv_nv_tensor_addressing -> "SPV_NV_tensor_addressing"
          | Spv_nv_viewport_array2 -> "SPV_NV_viewport_array2"
          | Spv_qcom_cooperative_matrix_conversion ->
              "SPV_QCOM_cooperative_matrix_conversion"
          | Spv_qcom_image_processing -> "SPV_QCOM_image_processing"
          | Spv_qcom_image_processing2 -> "SPV_QCOM_image_processing2"
          | Spv_qcom_tile_shading -> "SPV_QCOM_tile_shading"
      end
  end
module Instruction_printing_class =
  struct
    type t =
      | Annotation 
      | Arithmetic 
      | Atomic 
      | Barrier 
      | Bit 
      | Composite 
      | Constant_creation 
      | Control_flow 
      | Conversion 
      | Debug 
      | Derivative 
      | Device_side_enqueue 
      | Exclude 
      | Extension 
      | Function 
      | Graph 
      | Group 
      | Image 
      | Memory 
      | Miscellaneous 
      | Mode_setting 
      | Non_uniform 
      | Pipe 
      | Primitive 
      | Relational_and_logical 
      | Reserved 
      | Tensor 
      | Type_declaration [@@deriving compare, sexp_of, enumerate]
    let heading =
      function
      | Annotation -> Some "Annotation Instructions"
      | Arithmetic -> Some "Arithmetic Instructions"
      | Atomic -> Some "Atomic Instructions"
      | Barrier -> Some "Barrier Instructions"
      | Bit -> Some "Bit Instructions"
      | Composite -> Some "Composite Instructions"
      | Constant_creation -> Some "Constant-Creation Instructions"
      | Control_flow -> Some "Control-Flow Instructions"
      | Conversion -> Some "Conversion Instructions"
      | Debug -> Some "Debug Instructions"
      | Derivative -> Some "Derivative Instructions"
      | Device_side_enqueue -> Some "Device-Side Enqueue Instructions"
      | Exclude -> None
      | Extension -> Some "Extension Instructions"
      | Function -> Some "Function Instructions"
      | Graph -> Some "Graph Instructions"
      | Group -> Some "Group and Subgroup Instructions"
      | Image -> Some "Image Instructions"
      | Memory -> Some "Memory Instructions"
      | Miscellaneous -> Some "Miscellaneous Instructions"
      | Mode_setting -> Some "Mode-Setting Instructions"
      | Non_uniform -> Some "Non-Uniform Instructions"
      | Pipe -> Some "Pipe Instructions"
      | Primitive -> Some "Primitive Instructions"
      | Relational_and_logical -> Some "Relational and Logical Instructions"
      | Reserved -> Some "Reserved Instructions"
      | Tensor -> Some "Tensor Instructions"
      | Type_declaration -> Some "Type-Declaration Instructions"
  end
module Operand_kind =
  struct
    module Category =
      struct
        type t =
          | Bitenum 
          | Composite 
          | Id 
          | Literal 
          | Valueenum [@@deriving compare, sexp_of, enumerate]
      end
    module Payload =
      struct
        module Capability =
          struct
            module T =
              struct
                type t =
                  | Addresses 
                  | Arbitraryprecisionfixedpointaltera 
                  | Arbitraryprecisionfloatingpointaltera 
                  | Arbitraryprecisionintegersaltera 
                  | Arithmeticfenceext 
                  | Asmintel 
                  | Atomicfloat16addext 
                  | Atomicfloat16minmaxext 
                  | Atomicfloat16vectornv 
                  | Atomicfloat32addext 
                  | Atomicfloat32minmaxext 
                  | Atomicfloat64addext 
                  | Atomicfloat64minmaxext 
                  | Atomicstorage 
                  | Atomicstorageops 
                  | Bfloat16conversionintel 
                  | Bfloat16cooperativematrixkhr 
                  | Bfloat16dotproductkhr 
                  | Bfloat16typekhr 
                  | Bindlessimagesintel 
                  | Bindlesstexturenv 
                  | Bitinstructions 
                  | Blockingpipesaltera 
                  | Cachecontrolsintel 
                  | Clipdistance 
                  | Computederivativegrouplinearkhr 
                  | Computederivativegroupquadskhr 
                  | Cooperativematrixblockloadsnv 
                  | Cooperativematrixconversionqcom 
                  | Cooperativematrixconversionsnv 
                  | Cooperativematrixkhr 
                  | Cooperativematrixlayoutsarm 
                  | Cooperativematrixnv 
                  | Cooperativematrixperelementoperationsnv 
                  | Cooperativematrixreductionsnv 
                  | Cooperativematrixtensoraddressingnv 
                  | Cooperativevectornv 
                  | Cooperativevectortrainingnv 
                  | Corebuiltinsarm 
                  | Culldistance 
                  | Debuginfomoduleintel 
                  | Demotetohelperinvocation 
                  | Denormflushtozero 
                  | Denormpreserve 
                  | Derivativecontrol 
                  | Deviceenqueue 
                  | Devicegroup 
                  | Displacementmicromapnv 
                  | Dotproduct 
                  | Dotproductinput4x8bit 
                  | Dotproductinput4x8bitpacked 
                  | Dotproductinputall 
                  | Drawparameters 
                  | Expectassumekhr 
                  | Float16 
                  | Float16buffer 
                  | Float16imageamd 
                  | Float64 
                  | Float8cooperativematrixext 
                  | Float8ext 
                  | Floatcontrols2 
                  | Floatingpointmodeintel 
                  | Fmakhr 
                  | Fpfastmathmodeintel 
                  | Fpgaargumentinterfacesaltera 
                  | Fpgabufferlocationaltera 
                  | Fpgaclusterattributesaltera 
                  | Fpgaclusterattributesv2altera 
                  | Fpgadspcontrolaltera 
                  | Fpgainvocationpipeliningattributesaltera 
                  | Fpgakernelattributesintel 
                  | Fpgakernelattributesv2intel 
                  | Fpgalatencycontrolaltera 
                  | Fpgaloopcontrolsaltera 
                  | Fpgamemoryaccessesaltera 
                  | Fpgamemoryattributesaltera 
                  | Fpgaregaltera 
                  | Fpmaxerrorintel 
                  | Fragmentbarycentrickhr 
                  | Fragmentdensityext 
                  | Fragmentfullycoveredext 
                  | Fragmentmaskamd 
                  | Fragmentshaderpixelinterlockext 
                  | Fragmentshadersampleinterlockext 
                  | Fragmentshadershadingrateinterlockext 
                  | Fragmentshadingratekhr 
                  | Functionfloatcontrolintel 
                  | Functionpointersintel 
                  | Functionvariantsintel 
                  | Genericpointer 
                  | Geometry 
                  | Geometrypointsize 
                  | Geometryshaderpassthroughnv 
                  | Geometrystreams 
                  | Globalvariablefpgadecorationsaltera 
                  | Globalvariablehostaccessintel 
                  | Grapharm 
                  | Groupnonuniform 
                  | Groupnonuniformarithmetic 
                  | Groupnonuniformballot 
                  | Groupnonuniformclustered 
                  | Groupnonuniformpartitionednv 
                  | Groupnonuniformquad 
                  | Groupnonuniformrotatekhr 
                  | Groupnonuniformshuffle 
                  | Groupnonuniformshufflerelative 
                  | Groupnonuniformvote 
                  | Groups 
                  | Groupuniformarithmetickhr 
                  | Image1d 
                  | Imagebasic 
                  | Imagebuffer 
                  | Imagecubearray 
                  | Imagefootprintnv 
                  | Imagegatherbiaslodamd 
                  | Imagegatherextended 
                  | Imagemipmap 
                  | Imagemsarray 
                  | Imagequery 
                  | Imagereadwrite 
                  | Imagereadwritelodamd 
                  | Imagerect 
                  | Indirectreferencesintel 
                  | Inputattachment 
                  | Inputattachmentarraydynamicindexing 
                  | Inputattachmentarraynonuniformindexing 
                  | Int16 
                  | Int4cooperativematrixintel 
                  | Int4typeintel 
                  | Int64 
                  | Int64atomics 
                  | Int64imageext 
                  | Int8 
                  | Integerfunctions2intel 
                  | Interpolationfunction 
                  | Iopipesaltera 
                  | Kernel 
                  | Kernelattributesintel 
                  | Linkage 
                  | Literalsampler 
                  | Longcompositesintel 
                  | Longvectorext 
                  | Loopfusealtera 
                  | Maskedgatherscatterintel 
                  | Matrix 
                  | Memoryaccessaliasingintel 
                  | Meshshadingext 
                  | Meshshadingnv 
                  | Minlod 
                  | Multiview 
                  | Multiviewport 
                  | Namedbarrier 
                  | Optnoneext 
                  | Perviewattributesnv 
                  | Physicalstoragebufferaddresses 
                  | Pipes 
                  | Pipestorage 
                  | Quadcontrolkhr 
                  | Rawaccesschainsnv 
                  | Raycullmaskkhr 
                  | Rayquerykhr 
                  | Rayquerypositionfetchkhr 
                  | Rayqueryprovisionalkhr 
                  | Raytracingclusteraccelerationstructurenv 
                  | Raytracingdisplacementmicromapnv 
                  | Raytracingkhr 
                  | Raytracinglinearsweptspheresgeometrynv 
                  | Raytracingmotionblurnv 
                  | Raytracingnv 
                  | Raytracingopacitymicromapext 
                  | Raytracingpositionfetchkhr 
                  | Raytracingprovisionalkhr 
                  | Raytracingspheresgeometrynv 
                  | Raytraversalprimitivecullingkhr 
                  | Registerlimitsintel 
                  | Replicatedcompositesext 
                  | Roundingmoderte 
                  | Roundingmodertz 
                  | Roundtoinfinityintel 
                  | Runtimealignedattributealtera 
                  | Runtimedescriptorarray 
                  | Sampled1d 
                  | Sampledbuffer 
                  | Sampledcubearray 
                  | Sampledimagearraydynamicindexing 
                  | Sampledimagearraynonuniformindexing 
                  | Sampledrect 
                  | Samplemaskoverridecoveragenv 
                  | Samplemaskpostdepthcoverage 
                  | Samplerateshading 
                  | Shader 
                  | Shader64bitindexingext 
                  | Shaderclockkhr 
                  | Shaderenqueueamdx 
                  | Shaderinvocationreorderext 
                  | Shaderinvocationreordernv 
                  | Shaderlayer 
                  | Shadernonuniform 
                  | Shadersmbuiltinsnv 
                  | Shaderstereoviewnv 
                  | Shaderviewportindex 
                  | Shaderviewportindexlayerext 
                  | Shaderviewportmasknv 
                  | Signedzeroinfnanpreserve 
                  | Sparseresidency 
                  | Specconditionalintel 
                  | Splitbarrierintel 
                  | Stencilexportext 
                  | Storagebuffer16bitaccess 
                  | Storagebuffer8bitaccess 
                  | Storagebufferarraydynamicindexing 
                  | Storagebufferarraynonuniformindexing 
                  | Storageimagearraydynamicindexing 
                  | Storageimagearraynonuniformindexing 
                  | Storageimageextendedformats 
                  | Storageimagemultisample 
                  | Storageimagereadwithoutformat 
                  | Storageimagewritewithoutformat 
                  | Storageinputoutput16 
                  | Storagepushconstant16 
                  | Storagepushconstant8 
                  | Storagetensorarraydynamicindexingarm 
                  | Storagetensorarraynonuniformindexingarm 
                  | Storagetexelbufferarraydynamicindexing 
                  | Storagetexelbufferarraynonuniformindexing 
                  | Subgroup2dblockiointel 
                  | Subgroup2dblocktransformintel 
                  | Subgroup2dblocktransposeintel 
                  | Subgroupavcmotionestimationchromaintel 
                  | Subgroupavcmotionestimationintel 
                  | Subgroupavcmotionestimationintraintel 
                  | Subgroupballotkhr 
                  | Subgroupbufferblockiointel 
                  | Subgroupbufferprefetchintel 
                  | Subgroupdispatch 
                  | Subgroupimageblockiointel 
                  | Subgroupimagemediablockiointel 
                  | Subgroupmatrixmultiplyaccumulateintel 
                  | Subgroupshuffleintel 
                  | Subgroupvotekhr 
                  | Tasksequencealtera 
                  | Tensoraddressingnv 
                  | Tensorfloat32roundingintel 
                  | Tensorsarm 
                  | Ternarybitwisefunctionintel 
                  | Tessellation 
                  | Tessellationpointsize 
                  | Textureblockmatch2qcom 
                  | Textureblockmatchqcom 
                  | Textureboxfilterqcom 
                  | Texturesampleweightedqcom 
                  | Tileimagecolorreadaccessext 
                  | Tileimagedepthreadaccessext 
                  | Tileimagestencilreadaccessext 
                  | Tileshadingqcom 
                  | Transformfeedback 
                  | Uniformandstoragebuffer16bitaccess 
                  | Uniformandstoragebuffer8bitaccess 
                  | Uniformbufferarraydynamicindexing 
                  | Uniformbufferarraynonuniformindexing 
                  | Uniformdecoration 
                  | Uniformtexelbufferarraydynamicindexing 
                  | Uniformtexelbufferarraynonuniformindexing 
                  | Unstructuredloopcontrolsintel 
                  | Untypedpointerskhr 
                  | Untypedvariablelengtharrayintel 
                  | Usmstorageclassesaltera 
                  | Variablelengtharrayintel 
                  | Variablepointers 
                  | Variablepointersstoragebuffer 
                  | Vector16 
                  | Vectoranyintel 
                  | Vectorcomputeintel 
                  | Vulkanmemorymodel 
                  | Vulkanmemorymodeldevicescope 
                  | Workgroupmemoryexplicitlayout16bitaccesskhr 
                  | Workgroupmemoryexplicitlayout8bitaccesskhr 
                  | Workgroupmemoryexplicitlayoutkhr [@@deriving
                                                       compare, sexp_of, enumerate]
              end
            include T
            include (Comparable.Make_plain)(T)
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Addresses -> [4l]
              | Arbitraryprecisionfixedpointaltera -> [5922l]
              | Arbitraryprecisionfloatingpointaltera -> [5845l]
              | Arbitraryprecisionintegersaltera -> [5844l]
              | Arithmeticfenceext -> [6144l]
              | Asmintel -> [5606l]
              | Atomicfloat16addext -> [6095l]
              | Atomicfloat16minmaxext -> [5616l]
              | Atomicfloat16vectornv -> [5404l]
              | Atomicfloat32addext -> [6033l]
              | Atomicfloat32minmaxext -> [5612l]
              | Atomicfloat64addext -> [6034l]
              | Atomicfloat64minmaxext -> [5613l]
              | Atomicstorage -> [21l]
              | Atomicstorageops -> [4445l]
              | Bfloat16conversionintel -> [6115l]
              | Bfloat16cooperativematrixkhr -> [5118l]
              | Bfloat16dotproductkhr -> [5117l]
              | Bfloat16typekhr -> [5116l]
              | Bindlessimagesintel -> [6528l]
              | Bindlesstexturenv -> [5390l]
              | Bitinstructions -> [6025l]
              | Blockingpipesaltera -> [5945l]
              | Cachecontrolsintel -> [6441l]
              | Clipdistance -> [32l]
              | Computederivativegrouplinearkhr -> [5350l]
              | Computederivativegroupquadskhr -> [5288l]
              | Cooperativematrixblockloadsnv -> [5434l]
              | Cooperativematrixconversionqcom -> [4496l]
              | Cooperativematrixconversionsnv -> [5431l]
              | Cooperativematrixkhr -> [6022l]
              | Cooperativematrixlayoutsarm -> [4201l]
              | Cooperativematrixnv -> [5357l]
              | Cooperativematrixperelementoperationsnv -> [5432l]
              | Cooperativematrixreductionsnv -> [5430l]
              | Cooperativematrixtensoraddressingnv -> [5433l]
              | Cooperativevectornv -> [5394l]
              | Cooperativevectortrainingnv -> [5435l]
              | Corebuiltinsarm -> [4165l]
              | Culldistance -> [33l]
              | Debuginfomoduleintel -> [6114l]
              | Demotetohelperinvocation -> [5379l]
              | Denormflushtozero -> [4465l]
              | Denormpreserve -> [4464l]
              | Derivativecontrol -> [51l]
              | Deviceenqueue -> [19l]
              | Devicegroup -> [4437l]
              | Displacementmicromapnv -> [5380l]
              | Dotproduct -> [6019l]
              | Dotproductinput4x8bit -> [6017l]
              | Dotproductinput4x8bitpacked -> [6018l]
              | Dotproductinputall -> [6016l]
              | Drawparameters -> [4427l]
              | Expectassumekhr -> [5629l]
              | Float16 -> [9l]
              | Float16buffer -> [8l]
              | Float16imageamd -> [5008l]
              | Float64 -> [10l]
              | Float8cooperativematrixext -> [4213l]
              | Float8ext -> [4212l]
              | Floatcontrols2 -> [6029l]
              | Floatingpointmodeintel -> [5583l]
              | Fmakhr -> [6030l]
              | Fpfastmathmodeintel -> [5837l]
              | Fpgaargumentinterfacesaltera -> [6174l]
              | Fpgabufferlocationaltera -> [5920l]
              | Fpgaclusterattributesaltera -> [5904l]
              | Fpgaclusterattributesv2altera -> [6150l]
              | Fpgadspcontrolaltera -> [5908l]
              | Fpgainvocationpipeliningattributesaltera -> [5916l]
              | Fpgakernelattributesintel -> [5897l]
              | Fpgakernelattributesv2intel -> [6161l]
              | Fpgalatencycontrolaltera -> [6171l]
              | Fpgaloopcontrolsaltera -> [5888l]
              | Fpgamemoryaccessesaltera -> [5898l]
              | Fpgamemoryattributesaltera -> [5824l]
              | Fpgaregaltera -> [5948l]
              | Fpmaxerrorintel -> [6169l]
              | Fragmentbarycentrickhr -> [5284l]
              | Fragmentdensityext -> [5291l]
              | Fragmentfullycoveredext -> [5265l]
              | Fragmentmaskamd -> [5010l]
              | Fragmentshaderpixelinterlockext -> [5378l]
              | Fragmentshadersampleinterlockext -> [5363l]
              | Fragmentshadershadingrateinterlockext -> [5372l]
              | Fragmentshadingratekhr -> [4422l]
              | Functionfloatcontrolintel -> [5821l]
              | Functionpointersintel -> [5603l]
              | Functionvariantsintel -> [6246l]
              | Genericpointer -> [38l]
              | Geometry -> [2l]
              | Geometrypointsize -> [24l]
              | Geometryshaderpassthroughnv -> [5251l]
              | Geometrystreams -> [54l]
              | Globalvariablefpgadecorationsaltera -> [6189l]
              | Globalvariablehostaccessintel -> [6187l]
              | Grapharm -> [4191l]
              | Groupnonuniform -> [61l]
              | Groupnonuniformarithmetic -> [63l]
              | Groupnonuniformballot -> [64l]
              | Groupnonuniformclustered -> [67l]
              | Groupnonuniformpartitionednv -> [5297l]
              | Groupnonuniformquad -> [68l]
              | Groupnonuniformrotatekhr -> [6026l]
              | Groupnonuniformshuffle -> [65l]
              | Groupnonuniformshufflerelative -> [66l]
              | Groupnonuniformvote -> [62l]
              | Groups -> [18l]
              | Groupuniformarithmetickhr -> [6400l]
              | Image1d -> [44l]
              | Imagebasic -> [13l]
              | Imagebuffer -> [47l]
              | Imagecubearray -> [34l]
              | Imagefootprintnv -> [5282l]
              | Imagegatherbiaslodamd -> [5009l]
              | Imagegatherextended -> [25l]
              | Imagemipmap -> [15l]
              | Imagemsarray -> [48l]
              | Imagequery -> [50l]
              | Imagereadwrite -> [14l]
              | Imagereadwritelodamd -> [5015l]
              | Imagerect -> [36l]
              | Indirectreferencesintel -> [5604l]
              | Inputattachment -> [40l]
              | Inputattachmentarraydynamicindexing -> [5303l]
              | Inputattachmentarraynonuniformindexing -> [5310l]
              | Int16 -> [22l]
              | Int4cooperativematrixintel -> [5114l]
              | Int4typeintel -> [5112l]
              | Int64 -> [11l]
              | Int64atomics -> [12l]
              | Int64imageext -> [5016l]
              | Int8 -> [39l]
              | Integerfunctions2intel -> [5584l]
              | Interpolationfunction -> [52l]
              | Iopipesaltera -> [5943l]
              | Kernel -> [6l]
              | Kernelattributesintel -> [5892l]
              | Linkage -> [5l]
              | Literalsampler -> [20l]
              | Longcompositesintel -> [6089l]
              | Longvectorext -> [5425l]
              | Loopfusealtera -> [5906l]
              | Maskedgatherscatterintel -> [6427l]
              | Matrix -> [0l]
              | Memoryaccessaliasingintel -> [5910l]
              | Meshshadingext -> [5283l]
              | Meshshadingnv -> [5266l]
              | Minlod -> [42l]
              | Multiview -> [4439l]
              | Multiviewport -> [57l]
              | Namedbarrier -> [59l]
              | Optnoneext -> [6094l]
              | Perviewattributesnv -> [5260l]
              | Physicalstoragebufferaddresses -> [5347l]
              | Pipes -> [17l]
              | Pipestorage -> [60l]
              | Quadcontrolkhr -> [5087l]
              | Rawaccesschainsnv -> [5414l]
              | Raycullmaskkhr -> [6020l]
              | Rayquerykhr -> [4472l]
              | Rayquerypositionfetchkhr -> [5391l]
              | Rayqueryprovisionalkhr -> [4471l]
              | Raytracingclusteraccelerationstructurenv -> [5437l]
              | Raytracingdisplacementmicromapnv -> [5409l]
              | Raytracingkhr -> [4479l]
              | Raytracinglinearsweptspheresgeometrynv -> [5419l]
              | Raytracingmotionblurnv -> [5341l]
              | Raytracingnv -> [5340l]
              | Raytracingopacitymicromapext -> [5381l]
              | Raytracingpositionfetchkhr -> [5336l]
              | Raytracingprovisionalkhr -> [5353l]
              | Raytracingspheresgeometrynv -> [5418l]
              | Raytraversalprimitivecullingkhr -> [4478l]
              | Registerlimitsintel -> [6460l]
              | Replicatedcompositesext -> [6024l]
              | Roundingmoderte -> [4467l]
              | Roundingmodertz -> [4468l]
              | Roundtoinfinityintel -> [5582l]
              | Runtimealignedattributealtera -> [5939l]
              | Runtimedescriptorarray -> [5302l]
              | Sampled1d -> [43l]
              | Sampledbuffer -> [46l]
              | Sampledcubearray -> [45l]
              | Sampledimagearraydynamicindexing -> [29l]
              | Sampledimagearraynonuniformindexing -> [5307l]
              | Sampledrect -> [37l]
              | Samplemaskoverridecoveragenv -> [5249l]
              | Samplemaskpostdepthcoverage -> [4447l]
              | Samplerateshading -> [35l]
              | Shader -> [1l]
              | Shader64bitindexingext -> [5426l]
              | Shaderclockkhr -> [5055l]
              | Shaderenqueueamdx -> [5067l]
              | Shaderinvocationreorderext -> [5388l]
              | Shaderinvocationreordernv -> [5383l]
              | Shaderlayer -> [69l]
              | Shadernonuniform -> [5301l]
              | Shadersmbuiltinsnv -> [5373l]
              | Shaderstereoviewnv -> [5259l]
              | Shaderviewportindex -> [70l]
              | Shaderviewportindexlayerext -> [5254l]
              | Shaderviewportmasknv -> [5255l]
              | Signedzeroinfnanpreserve -> [4466l]
              | Sparseresidency -> [41l]
              | Specconditionalintel -> [6245l]
              | Splitbarrierintel -> [6141l]
              | Stencilexportext -> [5013l]
              | Storagebuffer16bitaccess -> [4433l]
              | Storagebuffer8bitaccess -> [4448l]
              | Storagebufferarraydynamicindexing -> [30l]
              | Storagebufferarraynonuniformindexing -> [5308l]
              | Storageimagearraydynamicindexing -> [31l]
              | Storageimagearraynonuniformindexing -> [5309l]
              | Storageimageextendedformats -> [49l]
              | Storageimagemultisample -> [27l]
              | Storageimagereadwithoutformat -> [55l]
              | Storageimagewritewithoutformat -> [56l]
              | Storageinputoutput16 -> [4436l]
              | Storagepushconstant16 -> [4435l]
              | Storagepushconstant8 -> [4450l]
              | Storagetensorarraydynamicindexingarm -> [4175l]
              | Storagetensorarraynonuniformindexingarm -> [4176l]
              | Storagetexelbufferarraydynamicindexing -> [5305l]
              | Storagetexelbufferarraynonuniformindexing -> [5312l]
              | Subgroup2dblockiointel -> [6228l]
              | Subgroup2dblocktransformintel -> [6229l]
              | Subgroup2dblocktransposeintel -> [6230l]
              | Subgroupavcmotionestimationchromaintel -> [5698l]
              | Subgroupavcmotionestimationintel -> [5696l]
              | Subgroupavcmotionestimationintraintel -> [5697l]
              | Subgroupballotkhr -> [4423l]
              | Subgroupbufferblockiointel -> [5569l]
              | Subgroupbufferprefetchintel -> [6220l]
              | Subgroupdispatch -> [58l]
              | Subgroupimageblockiointel -> [5570l]
              | Subgroupimagemediablockiointel -> [5579l]
              | Subgroupmatrixmultiplyaccumulateintel -> [6236l]
              | Subgroupshuffleintel -> [5568l]
              | Subgroupvotekhr -> [4431l]
              | Tasksequencealtera -> [6162l]
              | Tensoraddressingnv -> [5439l]
              | Tensorfloat32roundingintel -> [6425l]
              | Tensorsarm -> [4174l]
              | Ternarybitwisefunctionintel -> [6241l]
              | Tessellation -> [3l]
              | Tessellationpointsize -> [23l]
              | Textureblockmatch2qcom -> [4498l]
              | Textureblockmatchqcom -> [4486l]
              | Textureboxfilterqcom -> [4485l]
              | Texturesampleweightedqcom -> [4484l]
              | Tileimagecolorreadaccessext -> [4166l]
              | Tileimagedepthreadaccessext -> [4167l]
              | Tileimagestencilreadaccessext -> [4168l]
              | Tileshadingqcom -> [4495l]
              | Transformfeedback -> [53l]
              | Uniformandstoragebuffer16bitaccess -> [4434l]
              | Uniformandstoragebuffer8bitaccess -> [4449l]
              | Uniformbufferarraydynamicindexing -> [28l]
              | Uniformbufferarraynonuniformindexing -> [5306l]
              | Uniformdecoration -> [71l]
              | Uniformtexelbufferarraydynamicindexing -> [5304l]
              | Uniformtexelbufferarraynonuniformindexing -> [5311l]
              | Unstructuredloopcontrolsintel -> [5886l]
              | Untypedpointerskhr -> [4473l]
              | Untypedvariablelengtharrayintel -> [6243l]
              | Usmstorageclassesaltera -> [5935l]
              | Variablelengtharrayintel -> [5817l]
              | Variablepointers -> [4442l]
              | Variablepointersstoragebuffer -> [4441l]
              | Vector16 -> [7l]
              | Vectoranyintel -> [5619l]
              | Vectorcomputeintel -> [5617l]
              | Vulkanmemorymodel -> [5345l]
              | Vulkanmemorymodeldevicescope -> [5346l]
              | Workgroupmemoryexplicitlayout16bitaccesskhr -> [4430l]
              | Workgroupmemoryexplicitlayout8bitaccesskhr -> [4429l]
              | Workgroupmemoryexplicitlayoutkhr -> [4428l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Addresses -> true
              | Arbitraryprecisionfixedpointaltera -> true
              | Arbitraryprecisionfloatingpointaltera -> true
              | Arbitraryprecisionintegersaltera -> true
              | Arithmeticfenceext -> true
              | Asmintel -> true
              | Atomicfloat16addext -> true
              | Atomicfloat16minmaxext -> true
              | Atomicfloat16vectornv -> true
              | Atomicfloat32addext -> true
              | Atomicfloat32minmaxext -> true
              | Atomicfloat64addext -> true
              | Atomicfloat64minmaxext -> true
              | Bfloat16conversionintel -> true
              | Bfloat16typekhr -> true
              | Bindlessimagesintel -> true
              | Bindlesstexturenv -> true
              | Bitinstructions -> true
              | Blockingpipesaltera -> true
              | Cachecontrolsintel -> true
              | Cooperativematrixblockloadsnv -> true
              | Cooperativematrixconversionsnv -> true
              | Cooperativematrixkhr -> true
              | Cooperativematrixlayoutsarm -> true
              | Cooperativematrixperelementoperationsnv -> true
              | Cooperativematrixreductionsnv -> true
              | Cooperativematrixtensoraddressingnv -> true
              | Cooperativevectornv -> true
              | Cooperativevectortrainingnv -> true
              | Corebuiltinsarm -> true
              | Debuginfomoduleintel -> true
              | Denormflushtozero -> true
              | Denormpreserve -> true
              | Devicegroup -> true
              | Dotproduct -> true
              | Dotproductinput4x8bitpacked -> true
              | Dotproductinputall -> true
              | Expectassumekhr -> true
              | Float16 -> true
              | Float64 -> true
              | Float8ext -> true
              | Floatcontrols2 -> true
              | Floatingpointmodeintel -> true
              | Fmakhr -> true
              | Fpgaargumentinterfacesaltera -> true
              | Fpgabufferlocationaltera -> true
              | Fpgaclusterattributesaltera -> true
              | Fpgadspcontrolaltera -> true
              | Fpgainvocationpipeliningattributesaltera -> true
              | Fpgakernelattributesintel -> true
              | Fpgalatencycontrolaltera -> true
              | Fpgaloopcontrolsaltera -> true
              | Fpgamemoryaccessesaltera -> true
              | Fpgamemoryattributesaltera -> true
              | Fpgaregaltera -> true
              | Fpmaxerrorintel -> true
              | Fragmentbarycentrickhr -> true
              | Functionfloatcontrolintel -> true
              | Functionpointersintel -> true
              | Globalvariablefpgadecorationsaltera -> true
              | Globalvariablehostaccessintel -> true
              | Grapharm -> true
              | Groupnonuniform -> true
              | Groupnonuniformpartitionednv -> true
              | Groups -> true
              | Groupuniformarithmetickhr -> true
              | Imagefootprintnv -> true
              | Indirectreferencesintel -> true
              | Int16 -> true
              | Int4typeintel -> true
              | Int64 -> true
              | Int8 -> true
              | Integerfunctions2intel -> true
              | Iopipesaltera -> true
              | Kernel -> true
              | Kernelattributesintel -> true
              | Linkage -> true
              | Longcompositesintel -> true
              | Longvectorext -> true
              | Loopfusealtera -> true
              | Maskedgatherscatterintel -> true
              | Matrix -> true
              | Memoryaccessaliasingintel -> true
              | Optnoneext -> true
              | Quadcontrolkhr -> true
              | Rawaccesschainsnv -> true
              | Raycullmaskkhr -> true
              | Raytracinglinearsweptspheresgeometrynv -> true
              | Raytracingspheresgeometrynv -> true
              | Registerlimitsintel -> true
              | Replicatedcompositesext -> true
              | Roundingmoderte -> true
              | Roundingmodertz -> true
              | Roundtoinfinityintel -> true
              | Runtimealignedattributealtera -> true
              | Sampled1d -> true
              | Sampledbuffer -> true
              | Samplemaskpostdepthcoverage -> true
              | Shader64bitindexingext -> true
              | Shaderclockkhr -> true
              | Shaderlayer -> true
              | Shaderviewportindex -> true
              | Signedzeroinfnanpreserve -> true
              | Specconditionalintel -> true
              | Splitbarrierintel -> true
              | Storagebuffer16bitaccess -> true
              | Storagebuffer8bitaccess -> true
              | Storageinputoutput16 -> true
              | Storagepushconstant16 -> true
              | Storagepushconstant8 -> true
              | Storagetensorarraydynamicindexingarm -> true
              | Storagetensorarraynonuniformindexingarm -> true
              | Subgroup2dblockiointel -> true
              | Subgroupavcmotionestimationchromaintel -> true
              | Subgroupavcmotionestimationintel -> true
              | Subgroupavcmotionestimationintraintel -> true
              | Subgroupballotkhr -> true
              | Subgroupbufferblockiointel -> true
              | Subgroupbufferprefetchintel -> true
              | Subgroupimageblockiointel -> true
              | Subgroupimagemediablockiointel -> true
              | Subgroupmatrixmultiplyaccumulateintel -> true
              | Subgroupshuffleintel -> true
              | Subgroupvotekhr -> true
              | Tasksequencealtera -> true
              | Tensoraddressingnv -> true
              | Tensorfloat32roundingintel -> true
              | Tensorsarm -> true
              | Ternarybitwisefunctionintel -> true
              | Textureblockmatch2qcom -> true
              | Textureblockmatchqcom -> true
              | Textureboxfilterqcom -> true
              | Texturesampleweightedqcom -> true
              | Tileimagecolorreadaccessext -> true
              | Tileimagedepthreadaccessext -> true
              | Tileimagestencilreadaccessext -> true
              | Uniformdecoration -> true
              | Unstructuredloopcontrolsintel -> true
              | Untypedpointerskhr -> true
              | Usmstorageclassesaltera -> true
              | Variablelengtharrayintel -> true
              | Vectoranyintel -> true
              | Vulkanmemorymodel -> true
              | Vulkanmemorymodeldevicescope -> true
              | Atomicstorage ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Atomicstorageops ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Atomicstorage] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Bfloat16cooperativematrixkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Bfloat16typekhr; Cooperativematrixkhr] |>
                             Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Bfloat16dotproductkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Bfloat16typekhr] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Clipdistance ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Computederivativegrouplinearkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Computederivativegroupquadskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cooperativematrixconversionqcom ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Cooperativematrixkhr] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Cooperativematrixnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Culldistance ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Demotetohelperinvocation ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Derivativecontrol ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Deviceenqueue ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Kernel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Displacementmicromapnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Dotproductinput4x8bit ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Int8] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Drawparameters ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Float16buffer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Kernel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Float16imageamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Float8cooperativematrixext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Float8ext; Cooperativematrixkhr] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Fpfastmathmodeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Kernel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fpgaclusterattributesv2altera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Fpgaclusterattributesaltera] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Fpgakernelattributesv2intel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Fpgakernelattributesintel] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Fragmentdensityext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragmentfullycoveredext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragmentmaskamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragmentshaderpixelinterlockext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragmentshadersampleinterlockext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragmentshadershadingrateinterlockext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragmentshadingratekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Functionvariantsintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Specconditionalintel] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Genericpointer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Addresses] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Geometry ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Geometrypointsize ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Geometry] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Geometryshaderpassthroughnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Geometry] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Geometrystreams ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Geometry] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Groupnonuniformarithmetic ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Groupnonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Groupnonuniformballot ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Groupnonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Groupnonuniformclustered ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Groupnonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Groupnonuniformquad ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Groupnonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Groupnonuniformrotatekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Groupnonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Groupnonuniformshuffle ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Groupnonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Groupnonuniformshufflerelative ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Groupnonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Groupnonuniformvote ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Groupnonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Image1d ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Sampled1d] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagebasic ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Kernel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagebuffer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Sampledbuffer] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagecubearray ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Sampledcubearray] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagegatherbiaslodamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagegatherextended ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagemipmap ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Imagebasic] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagemsarray ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagequery ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagereadwrite ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Imagebasic] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagereadwritelodamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Imagerect ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Sampledrect] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Inputattachment ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Inputattachmentarraydynamicindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Inputattachment] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Inputattachmentarraynonuniformindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Inputattachment; Shadernonuniform] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Int4cooperativematrixintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Int4typeintel; Cooperativematrixkhr] |>
                             Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Int64atomics ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Int64] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Int64imageext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Interpolationfunction ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Literalsampler ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Kernel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Meshshadingext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Meshshadingnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Minlod ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Multiview ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Multiviewport ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Geometry] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Namedbarrier ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Kernel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Perviewattributesnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Multiview] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Physicalstoragebufferaddresses ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pipes ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Kernel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pipestorage ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Pipes] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rayquerykhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rayquerypositionfetchkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rayqueryprovisionalkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytracingclusteraccelerationstructurenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Raytracingkhr] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytracingdisplacementmicromapnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Raytracingkhr] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytracingkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytracingmotionblurnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytracingnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytracingopacitymicromapext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytracingpositionfetchkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytracingprovisionalkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytraversalprimitivecullingkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Rayquerykhr; Raytracingkhr] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Runtimedescriptorarray ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sampledcubearray ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sampledimagearraydynamicindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sampledimagearraynonuniformindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shadernonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sampledrect ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Samplemaskoverridecoveragenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Samplerateshading] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Samplerateshading ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shader ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Matrix] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shaderenqueueamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shaderinvocationreorderext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Raytracingkhr] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shaderinvocationreordernv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Raytracingkhr] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shadernonuniform ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shadersmbuiltinsnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shaderstereoviewnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shaderviewportmasknv] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Shaderviewportindexlayerext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Multiviewport] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shaderviewportmasknv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shaderviewportindexlayerext] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Sparseresidency ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stencilexportext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storagebufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storagebufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shadernonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storageimagearraydynamicindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storageimagearraynonuniformindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shadernonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storageimageextendedformats ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storageimagemultisample ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storageimagereadwithoutformat ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storageimagewritewithoutformat ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storagetexelbufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Imagebuffer] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storagetexelbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Imagebuffer; Shadernonuniform] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Subgroup2dblocktransformintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Subgroup2dblockiointel] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Subgroup2dblocktransposeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Subgroup2dblockiointel] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Subgroupdispatch ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Deviceenqueue] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tessellation ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tessellationpointsize ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Tessellation] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tileshadingqcom ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Transformfeedback ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uniformandstoragebuffer16bitaccess ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Storagebuffer16bitaccess] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Uniformandstoragebuffer8bitaccess ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Storagebuffer8bitaccess] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Uniformbufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uniformbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shadernonuniform] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uniformtexelbufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Sampledbuffer] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uniformtexelbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Sampledbuffer; Shadernonuniform] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Untypedvariablelengtharrayintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Variablelengtharrayintel; Untypedpointerskhr] |>
                             Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Variablepointers ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Variablepointersstoragebuffer] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Variablepointersstoragebuffer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vector16 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Kernel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vectorcomputeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Vectoranyintel] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Workgroupmemoryexplicitlayout16bitaccesskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Workgroupmemoryexplicitlayoutkhr] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Workgroupmemoryexplicitlayout8bitaccesskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Workgroupmemoryexplicitlayoutkhr] |> Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Workgroupmemoryexplicitlayoutkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Shader] |> Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Addresses -> true
              | Atomicstorage -> true
              | Clipdistance -> true
              | Culldistance -> true
              | Derivativecontrol -> true
              | Deviceenqueue -> true
              | Float16 -> true
              | Float16buffer -> true
              | Float64 -> true
              | Genericpointer -> true
              | Geometry -> true
              | Geometrypointsize -> true
              | Geometrystreams -> true
              | Groupnonuniform -> true
              | Groupnonuniformarithmetic -> true
              | Groupnonuniformballot -> true
              | Groupnonuniformclustered -> true
              | Groupnonuniformquad -> true
              | Groupnonuniformshuffle -> true
              | Groupnonuniformshufflerelative -> true
              | Groupnonuniformvote -> true
              | Image1d -> true
              | Imagebasic -> true
              | Imagebuffer -> true
              | Imagecubearray -> true
              | Imagegatherextended -> true
              | Imagemipmap -> true
              | Imagemsarray -> true
              | Imagequery -> true
              | Imagereadwrite -> true
              | Imagerect -> true
              | Inputattachment -> true
              | Int16 -> true
              | Int64 -> true
              | Int64atomics -> true
              | Int8 -> true
              | Interpolationfunction -> true
              | Kernel -> true
              | Linkage -> true
              | Literalsampler -> true
              | Matrix -> true
              | Minlod -> true
              | Multiviewport -> true
              | Namedbarrier -> true
              | Pipes -> true
              | Pipestorage -> true
              | Sampled1d -> true
              | Sampledbuffer -> true
              | Sampledcubearray -> true
              | Sampledimagearraydynamicindexing -> true
              | Sampledrect -> true
              | Samplerateshading -> true
              | Shader -> true
              | Shaderlayer -> true
              | Shaderviewportindex -> true
              | Sparseresidency -> true
              | Storagebufferarraydynamicindexing -> true
              | Storageimagearraydynamicindexing -> true
              | Storageimageextendedformats -> true
              | Storageimagemultisample -> true
              | Storageimagereadwithoutformat -> true
              | Storageimagewritewithoutformat -> true
              | Subgroupdispatch -> true
              | Tessellation -> true
              | Tessellationpointsize -> true
              | Transformfeedback -> true
              | Uniformbufferarraydynamicindexing -> true
              | Uniformdecoration -> true
              | Vector16 -> true
              | Arbitraryprecisionfixedpointaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_arbitrary_precision_fixed_point;
                           Requirements.Extension.Spv_intel_arbitrary_precision_fixed_point]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Arbitraryprecisionfloatingpointaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_arbitrary_precision_floating_point;
                           Requirements.Extension.Spv_intel_arbitrary_precision_floating_point]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Arbitraryprecisionintegersaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_arbitrary_precision_integers;
                           Requirements.Extension.Spv_intel_arbitrary_precision_integers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Arithmeticfenceext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_arithmetic_fence]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Asmintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_inline_assembly]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Atomicfloat16addext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_atomic_float16_add]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Atomicfloat16minmaxext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_atomic_float_min_max]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Atomicfloat16vectornv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_atomic_fp16_vector]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Atomicfloat32addext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_atomic_float_add]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Atomicfloat32minmaxext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_atomic_float_min_max]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Atomicfloat64addext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_atomic_float_add]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Atomicfloat64minmaxext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_atomic_float_min_max]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Atomicstorageops ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_atomic_counter_ops]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Bfloat16conversionintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_bfloat16_conversion]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Bfloat16cooperativematrixkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_bfloat16] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Bfloat16dotproductkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_bfloat16] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Bfloat16typekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_bfloat16] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Bindlessimagesintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_bindless_images]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Bindlesstexturenv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_bindless_texture]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Bitinstructions ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_bit_instructions]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Blockingpipesaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_blocking_pipes;
                           Requirements.Extension.Spv_intel_blocking_pipes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cachecontrolsintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_cache_controls]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Computederivativegrouplinearkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_compute_shader_derivatives;
                           Requirements.Extension.Spv_khr_compute_shader_derivatives]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Computederivativegroupquadskhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_compute_shader_derivatives;
                           Requirements.Extension.Spv_khr_compute_shader_derivatives]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixblockloadsnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cooperative_matrix2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixconversionqcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_cooperative_matrix_conversion]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixconversionsnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cooperative_matrix2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_cooperative_matrix]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixlayoutsarm ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_arm_cooperative_matrix_layouts]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cooperative_matrix]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixperelementoperationsnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cooperative_matrix2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixreductionsnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cooperative_matrix2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativematrixtensoraddressingnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cooperative_matrix2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativevectornv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cooperative_vector]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Cooperativevectortrainingnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cooperative_vector]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Corebuiltinsarm ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_arm_core_builtins] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Debuginfomoduleintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_debug_module] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Demotetohelperinvocation ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_demote_to_helper_invocation]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Denormflushtozero ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Denormpreserve ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Devicegroup ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_device_group] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Displacementmicromapnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_displacement_micromap]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Dotproduct ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_integer_dot_product]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Dotproductinput4x8bit ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_integer_dot_product]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Dotproductinput4x8bitpacked ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_integer_dot_product]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Dotproductinputall ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_integer_dot_product]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Drawparameters ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_draw_parameters]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Expectassumekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_expect_assume] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Float16imageamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_gpu_shader_half_float_fetch]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Float8cooperativematrixext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_float8] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Float8ext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_float8] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Floatcontrols2 ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Floatingpointmodeintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_float_controls2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fmakhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_fma] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Fpfastmathmodeintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_fp_fast_math_mode]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgaargumentinterfacesaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_argument_interfaces;
                           Requirements.Extension.Spv_intel_fpga_argument_interfaces]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgabufferlocationaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_buffer_location;
                           Requirements.Extension.Spv_intel_fpga_buffer_location]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgaclusterattributesaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_cluster_attributes;
                           Requirements.Extension.Spv_intel_fpga_cluster_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgaclusterattributesv2altera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_cluster_attributes;
                           Requirements.Extension.Spv_intel_fpga_cluster_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgadspcontrolaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_dsp_control;
                           Requirements.Extension.Spv_intel_fpga_dsp_control]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgainvocationpipeliningattributesaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_invocation_pipelining_attributes;
                           Requirements.Extension.Spv_intel_fpga_invocation_pipelining_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgakernelattributesintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_kernel_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgakernelattributesv2intel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_kernel_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgalatencycontrolaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_latency_control;
                           Requirements.Extension.Spv_intel_fpga_latency_control]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgaloopcontrolsaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_loop_controls;
                           Requirements.Extension.Spv_intel_fpga_loop_controls]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgamemoryaccessesaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_memory_accesses;
                           Requirements.Extension.Spv_intel_fpga_memory_accesses]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgamemoryattributesaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_memory_attributes;
                           Requirements.Extension.Spv_intel_fpga_memory_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fpgaregaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_fpga_reg;
                           Requirements.Extension.Spv_intel_fpga_reg] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Fpmaxerrorintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_fp_max_error] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Fragmentbarycentrickhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_fragment_shader_barycentric;
                           Requirements.Extension.Spv_khr_fragment_shader_barycentric]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fragmentdensityext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_invocation_density;
                           Requirements.Extension.Spv_nv_shading_rate] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Fragmentfullycoveredext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_fully_covered]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fragmentmaskamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_fragment_mask]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fragmentshaderpixelinterlockext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fragmentshadersampleinterlockext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fragmentshadershadingrateinterlockext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fragmentshadingratekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_fragment_shading_rate]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Functionfloatcontrolintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_float_controls2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Functionpointersintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_function_pointers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Functionvariantsintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_function_variants]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Geometryshaderpassthroughnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_geometry_shader_passthrough]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Globalvariablefpgadecorationsaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_global_variable_fpga_decorations;
                           Requirements.Extension.Spv_intel_global_variable_fpga_decorations]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Globalvariablehostaccessintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_global_variable_host_access]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Grapharm ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_arm_graph] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Groupnonuniformpartitionednv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Groupnonuniformrotatekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_subgroup_rotate]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Groups ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_ballot] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Groupuniformarithmetickhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_uniform_group_instructions]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Imagefootprintnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_image_footprint]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Imagegatherbiaslodamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_texture_gather_bias_lod]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Imagereadwritelodamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_image_load_store_lod]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Indirectreferencesintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_function_pointers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Inputattachmentarraydynamicindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Inputattachmentarraynonuniformindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Int4cooperativematrixintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_int4] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Int4typeintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_int4] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Int64imageext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_image_int64]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Integerfunctions2intel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_shader_integer_functions2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Iopipesaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_io_pipes;
                           Requirements.Extension.Spv_intel_io_pipes] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Kernelattributesintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_kernel_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Longcompositesintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_long_composites]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Longvectorext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_long_vector] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Loopfusealtera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_loop_fuse;
                           Requirements.Extension.Spv_intel_loop_fuse] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Maskedgatherscatterintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_masked_gather_scatter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Memoryaccessaliasingintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_memory_access_aliasing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Meshshadingext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Meshshadingnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Multiview ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_multiview] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Optnoneext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_optnone;
                           Requirements.Extension.Spv_intel_optnone] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Perviewattributesnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nvx_multiview_per_view_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Physicalstoragebufferaddresses ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_physical_storage_buffer;
                           Requirements.Extension.Spv_khr_physical_storage_buffer]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Quadcontrolkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_quad_control] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Rawaccesschainsnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_raw_access_chains]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raycullmaskkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_cull_mask] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Rayquerykhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_query] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Rayquerypositionfetchkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_tracing_position_fetch]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Rayqueryprovisionalkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_query] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Raytracingclusteraccelerationstructurenv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cluster_acceleration_structure]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raytracingdisplacementmicromapnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_displacement_micromap]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raytracingkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Raytracinglinearsweptspheresgeometrynv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_linear_swept_spheres]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raytracingmotionblurnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing_motion_blur]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raytracingnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Raytracingopacitymicromapext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_opacity_micromap]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raytracingpositionfetchkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_tracing_position_fetch]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raytracingprovisionalkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Raytracingspheresgeometrynv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_linear_swept_spheres]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raytraversalprimitivecullingkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_query;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Registerlimitsintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_maximum_registers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Replicatedcompositesext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_replicated_composites]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Roundingmoderte ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Roundingmodertz ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Roundtoinfinityintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_float_controls2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Runtimealignedattributealtera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_runtime_aligned;
                           Requirements.Extension.Spv_intel_runtime_aligned]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Runtimedescriptorarray ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Sampledimagearraynonuniformindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Samplemaskoverridecoveragenv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_sample_mask_override_coverage]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Samplemaskpostdepthcoverage ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_post_depth_coverage]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shader64bitindexingext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_64bit_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shaderclockkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_clock] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Shaderenqueueamdx ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amdx_shader_enqueue]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shaderinvocationreorderext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_invocation_reorder]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shaderinvocationreordernv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_invocation_reorder]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shadernonuniform ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shadersmbuiltinsnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_sm_builtins]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shaderstereoviewnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_stereo_view_rendering]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shaderviewportindexlayerext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_viewport_index_layer;
                           Requirements.Extension.Spv_nv_viewport_array2] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Shaderviewportmasknv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_viewport_array2] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Signedzeroinfnanpreserve ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Specconditionalintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_function_variants]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Splitbarrierintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_split_barrier]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Stencilexportext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Storagebuffer16bitaccess ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_16bit_storage] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Storagebuffer8bitaccess ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_8bit_storage] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Storagebufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Storageimagearraynonuniformindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Storageinputoutput16 ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_16bit_storage] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Storagepushconstant16 ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_16bit_storage] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Storagepushconstant8 ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_8bit_storage] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Storagetensorarraydynamicindexingarm ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_arm_tensors] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Storagetensorarraynonuniformindexingarm ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_arm_tensors] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Storagetexelbufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Storagetexelbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroup2dblockiointel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_2d_block_io] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroup2dblocktransformintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_2d_block_io] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroup2dblocktransposeintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_2d_block_io] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroupavcmotionestimationchromaintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_device_side_avc_motion_estimation]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroupavcmotionestimationintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_device_side_avc_motion_estimation]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroupavcmotionestimationintraintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_device_side_avc_motion_estimation]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroupballotkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_ballot] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroupbufferblockiointel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_subgroups] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroupbufferprefetchintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_subgroup_buffer_prefetch]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroupimageblockiointel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_subgroups] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroupimagemediablockiointel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_media_block_io]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroupmatrixmultiplyaccumulateintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_subgroup_matrix_multiply_accumulate]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroupshuffleintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_subgroups] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroupvotekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_subgroup_vote] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Tasksequencealtera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_task_sequence;
                           Requirements.Extension.Spv_intel_task_sequence] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Tensoraddressingnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_tensor_addressing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Tensorfloat32roundingintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_tensor_float32_conversion]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Tensorsarm ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_arm_tensors] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Ternarybitwisefunctionintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_ternary_bitwise_function]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Textureblockmatch2qcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_image_processing2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Textureblockmatchqcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_image_processing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Textureboxfilterqcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_image_processing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Texturesampleweightedqcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_image_processing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Tileimagecolorreadaccessext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_tile_image]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Tileimagedepthreadaccessext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_tile_image]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Tileimagestencilreadaccessext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_tile_image]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Tileshadingqcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_tile_shading] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Uniformandstoragebuffer16bitaccess ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_16bit_storage] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Uniformandstoragebuffer8bitaccess ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_8bit_storage] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Uniformbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Uniformtexelbufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Uniformtexelbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Unstructuredloopcontrolsintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_unstructured_loop_controls]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Untypedpointerskhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_untyped_pointers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Untypedvariablelengtharrayintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_variable_length_array]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Usmstorageclassesaltera ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_altera_usm_storage_classes;
                           Requirements.Extension.Spv_intel_usm_storage_classes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Variablelengtharrayintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_variable_length_array]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Variablepointers ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_variable_pointers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Variablepointersstoragebuffer ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_variable_pointers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Vectoranyintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_vector_compute]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Vectorcomputeintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_vector_compute]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Vulkanmemorymodel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Vulkanmemorymodeldevicescope ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Workgroupmemoryexplicitlayout16bitaccesskhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_workgroup_memory_explicit_layout]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Workgroupmemoryexplicitlayout8bitaccesskhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_workgroup_memory_explicit_layout]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Workgroupmemoryexplicitlayoutkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_workgroup_memory_explicit_layout]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Addresses ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Arbitraryprecisionfixedpointaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Arbitraryprecisionfloatingpointaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Arbitraryprecisionintegersaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Arithmeticfenceext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Asmintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicfloat16addext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicfloat16minmaxext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicfloat16vectornv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicfloat32addext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicfloat32minmaxext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicfloat64addext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicfloat64minmaxext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicstorage ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomicstorageops ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bfloat16conversionintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bfloat16cooperativematrixkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bfloat16dotproductkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bfloat16typekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bindlessimagesintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bindlesstexturenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bitinstructions ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Blockingpipesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cachecontrolsintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Clipdistance ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Computederivativegrouplinearkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Computederivativegroupquadskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixblockloadsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixconversionqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixconversionsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixlayoutsarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixperelementoperationsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixreductionsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativematrixtensoraddressingnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativevectornv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cooperativevectortrainingnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Corebuiltinsarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Culldistance ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Debuginfomoduleintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Demotetohelperinvocation ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_6) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Denormflushtozero ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Denormpreserve ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Derivativecontrol ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Deviceenqueue ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Devicegroup ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Displacementmicromapnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dotproduct ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_6) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dotproductinput4x8bit ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_6) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dotproductinput4x8bitpacked ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_6) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dotproductinputall ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_6) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Drawparameters ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Expectassumekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float16buffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float16imageamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float64 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float8cooperativematrixext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float8ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Floatcontrols2 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Floatingpointmodeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fmakhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpfastmathmodeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgaargumentinterfacesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgabufferlocationaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgaclusterattributesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgaclusterattributesv2altera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgadspcontrolaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgainvocationpipeliningattributesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgakernelattributesintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgakernelattributesv2intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgalatencycontrolaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgaloopcontrolsaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgamemoryaccessesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgamemoryattributesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpgaregaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpmaxerrorintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragmentbarycentrickhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragmentdensityext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragmentfullycoveredext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragmentmaskamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragmentshaderpixelinterlockext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragmentshadersampleinterlockext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragmentshadershadingrateinterlockext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragmentshadingratekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Functionfloatcontrolintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Functionpointersintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Functionvariantsintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Genericpointer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Geometry ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Geometrypointsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Geometryshaderpassthroughnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Geometrystreams ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Globalvariablefpgadecorationsaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Globalvariablehostaccessintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Grapharm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniform ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformarithmetic ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformballot ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformclustered ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformpartitionednv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformquad ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformrotatekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformshuffle ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformshufflerelative ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupnonuniformvote ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groups ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Groupuniformarithmetickhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Image1d ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagebasic ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagebuffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagecubearray ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagefootprintnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagegatherbiaslodamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagegatherextended ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagemipmap ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagemsarray ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagequery ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagereadwrite ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagereadwritelodamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagerect ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Indirectreferencesintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inputattachment ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inputattachmentarraydynamicindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inputattachmentarraynonuniformindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Int16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Int4cooperativematrixintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Int4typeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Int64 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Int64atomics ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Int64imageext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Int8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Integerfunctions2intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Interpolationfunction ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Iopipesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Kernel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Kernelattributesintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Linkage ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Literalsampler ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Longcompositesintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Longvectorext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Loopfusealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maskedgatherscatterintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrix ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Memoryaccessaliasingintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Meshshadingext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Meshshadingnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Minlod ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Multiview ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Multiviewport ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Namedbarrier ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Optnoneext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Perviewattributesnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Physicalstoragebufferaddresses ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pipes ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pipestorage ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Quadcontrolkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rawaccesschainsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raycullmaskkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rayquerykhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rayquerypositionfetchkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rayqueryprovisionalkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingclusteraccelerationstructurenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingdisplacementmicromapnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracinglinearsweptspheresgeometrynv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingmotionblurnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingopacitymicromapext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingpositionfetchkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingprovisionalkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytracingspheresgeometrynv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytraversalprimitivecullingkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Registerlimitsintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Replicatedcompositesext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Roundingmoderte ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Roundingmodertz ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Roundtoinfinityintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Runtimealignedattributealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Runtimedescriptorarray ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampled1d ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampledbuffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampledcubearray ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampledimagearraydynamicindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampledimagearraynonuniformindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampledrect ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Samplemaskoverridecoveragenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Samplemaskpostdepthcoverage ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Samplerateshading ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shader ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shader64bitindexingext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderclockkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderenqueueamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderinvocationreorderext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderinvocationreordernv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderlayer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shadernonuniform ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shadersmbuiltinsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderstereoviewnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderviewportindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderviewportindexlayerext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderviewportmasknv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedzeroinfnanpreserve ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sparseresidency ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Specconditionalintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Splitbarrierintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stencilexportext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagebuffer16bitaccess ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagebuffer8bitaccess ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagebufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagebufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storageimagearraydynamicindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storageimagearraynonuniformindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storageimageextendedformats ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storageimagemultisample ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storageimagereadwithoutformat ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storageimagewritewithoutformat ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storageinputoutput16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagepushconstant16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagepushconstant8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagetensorarraydynamicindexingarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagetensorarraynonuniformindexingarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagetexelbufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagetexelbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroup2dblockiointel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroup2dblocktransformintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroup2dblocktransposeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupavcmotionestimationchromaintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupavcmotionestimationintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupavcmotionestimationintraintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupballotkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupbufferblockiointel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupbufferprefetchintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupdispatch ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupimageblockiointel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupimagemediablockiointel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupmatrixmultiplyaccumulateintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupshuffleintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupvotekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tasksequencealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tensoraddressingnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tensorfloat32roundingintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tensorsarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Ternarybitwisefunctionintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tessellation ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tessellationpointsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Textureblockmatch2qcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Textureblockmatchqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Textureboxfilterqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Texturesampleweightedqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileimagecolorreadaccessext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileimagedepthreadaccessext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileimagestencilreadaccessext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileshadingqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Transformfeedback ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformandstoragebuffer16bitaccess ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformandstoragebuffer8bitaccess ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformbufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformdecoration ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_6) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformtexelbufferarraydynamicindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformtexelbufferarraynonuniformindexing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unstructuredloopcontrolsintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Untypedpointerskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Untypedvariablelengtharrayintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Usmstorageclassesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Variablelengtharrayintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Variablepointers ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Variablepointersstoragebuffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vector16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vectoranyintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vectorcomputeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vulkanmemorymodel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vulkanmemorymodeldevicescope ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workgroupmemoryexplicitlayout16bitaccesskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workgroupmemoryexplicitlayout8bitaccesskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workgroupmemoryexplicitlayoutkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Accessqualifier =
          struct
            type t =
              | Readonly 
              | Readwrite 
              | Writeonly [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Readonly -> [0l]
              | Readwrite -> [2l]
              | Writeonly -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Readonly ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Readwrite ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Writeonly ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Readonly -> true
              | Readwrite -> true
              | Writeonly -> true
            let satisfies_version t ~version =
              match t with
              | Readonly ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Readwrite ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Writeonly ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Addressingmodel =
          struct
            type t =
              | Logical 
              | Physical32 
              | Physical64 
              | Physicalstoragebuffer64 [@@deriving
                                          compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Logical -> [0l]
              | Physical32 -> [1l]
              | Physical64 -> [2l]
              | Physicalstoragebuffer64 -> [5348l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Logical -> true
              | Physical32 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Addresses] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Physical64 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Addresses] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Physicalstoragebuffer64 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Physicalstoragebufferaddresses] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Logical -> true
              | Physical32 -> true
              | Physical64 -> true
              | Physicalstoragebuffer64 ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_physical_storage_buffer;
                           Requirements.Extension.Spv_khr_physical_storage_buffer]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Logical ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Physical32 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Physical64 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Physicalstoragebuffer64 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Builtin =
          struct
            type t =
              | Barycoordkhr 
              | Barycoordnoperspamd 
              | Barycoordnoperspcentroidamd 
              | Barycoordnoperspkhr 
              | Barycoordnoperspsampleamd 
              | Barycoordpullmodelamd 
              | Barycoordsmoothamd 
              | Barycoordsmoothcentroidamd 
              | Barycoordsmoothsampleamd 
              | Baseinstance 
              | Basevertex 
              | Clipdistance 
              | Clipdistanceperviewnv 
              | Clusteridnv 
              | Corecountarm 
              | Coreidarm 
              | Coremaxidarm 
              | Culldistance 
              | Culldistanceperviewnv 
              | Cullmaskkhr 
              | Cullprimitiveext 
              | Currentraytimenv 
              | Deviceindex 
              | Drawindex 
              | Enqueuedworkgroupsize 
              | Fragcoord 
              | Fragdepth 
              | Fraginvocationcountext 
              | Fragsizeext 
              | Fragstencilrefext 
              | Frontfacing 
              | Fullycoveredext 
              | Globalinvocationid 
              | Globallinearid 
              | Globaloffset 
              | Globalsize 
              | Helperinvocation 
              | Hitislssnv 
              | Hitisspherenv 
              | Hitkindbackfacingmicrotrianglenv 
              | Hitkindfrontfacingmicrotrianglenv 
              | Hitkindkhr 
              | Hitlsspositionsnv 
              | Hitlssradiinv 
              | Hitmicrotrianglevertexbarycentricsnv 
              | Hitmicrotrianglevertexpositionsnv 
              | Hitspherepositionnv 
              | Hitsphereradiusnv 
              | Hittnv 
              | Hittrianglevertexpositionskhr 
              | Incomingrayflagskhr 
              | Instancecustomindexkhr 
              | Instanceid 
              | Instanceindex 
              | Invocationid 
              | Launchidkhr 
              | Launchsizekhr 
              | Layer 
              | Layerperviewnv 
              | Localinvocationid 
              | Localinvocationindex 
              | Meshviewcountnv 
              | Meshviewindicesnv 
              | Numenqueuedsubgroups 
              | Numsubgroups 
              | Numworkgroups 
              | Objectraydirectionkhr 
              | Objectrayoriginkhr 
              | Objecttoworldkhr 
              | Patchvertices 
              | Pointcoord 
              | Pointsize 
              | Position 
              | Positionperviewnv 
              | Primitivecountnv 
              | Primitiveid 
              | Primitiveindicesnv 
              | Primitivelineindicesext 
              | Primitivepointindicesext 
              | Primitiveshadingratekhr 
              | Primitivetriangleindicesext 
              | Raygeometryindexkhr 
              | Raytmaxkhr 
              | Raytminkhr 
              | Remainingrecursionlevelsamdx 
              | Sampleid 
              | Samplemask 
              | Sampleposition 
              | Secondarypositionnv 
              | Secondaryviewportmasknv 
              | Shaderindexamdx 
              | Shadingratekhr 
              | Smcountnv 
              | Smidnv 
              | Subgroupeqmask 
              | Subgroupgemask 
              | Subgroupgtmask 
              | Subgroupid 
              | Subgrouplemask 
              | Subgrouplocalinvocationid 
              | Subgroupltmask 
              | Subgroupmaxsize 
              | Subgroupsize 
              | Taskcountnv 
              | Tesscoord 
              | Tesslevelinner 
              | Tesslevelouter 
              | Tileapronsizeqcom 
              | Tiledimensionqcom 
              | Tileoffsetqcom 
              | Vertexid 
              | Vertexindex 
              | Viewindex 
              | Viewportindex 
              | Viewportmasknv 
              | Viewportmaskperviewnv 
              | Warpidarm 
              | Warpidnv 
              | Warpmaxidarm 
              | Warpspersmnv 
              | Workdim 
              | Workgroupid 
              | Workgroupsize 
              | Worldraydirectionkhr 
              | Worldrayoriginkhr 
              | Worldtoobjectkhr [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Barycoordkhr -> [5286l]
              | Barycoordnoperspamd -> [4992l]
              | Barycoordnoperspcentroidamd -> [4993l]
              | Barycoordnoperspkhr -> [5287l]
              | Barycoordnoperspsampleamd -> [4994l]
              | Barycoordpullmodelamd -> [4998l]
              | Barycoordsmoothamd -> [4995l]
              | Barycoordsmoothcentroidamd -> [4996l]
              | Barycoordsmoothsampleamd -> [4997l]
              | Baseinstance -> [4425l]
              | Basevertex -> [4424l]
              | Clipdistance -> [3l]
              | Clipdistanceperviewnv -> [5277l]
              | Clusteridnv -> [5436l]
              | Corecountarm -> [4161l]
              | Coreidarm -> [4160l]
              | Coremaxidarm -> [4162l]
              | Culldistance -> [4l]
              | Culldistanceperviewnv -> [5278l]
              | Cullmaskkhr -> [6021l]
              | Cullprimitiveext -> [5299l]
              | Currentraytimenv -> [5334l]
              | Deviceindex -> [4438l]
              | Drawindex -> [4426l]
              | Enqueuedworkgroupsize -> [32l]
              | Fragcoord -> [15l]
              | Fragdepth -> [22l]
              | Fraginvocationcountext -> [5293l]
              | Fragsizeext -> [5292l]
              | Fragstencilrefext -> [5014l]
              | Frontfacing -> [17l]
              | Fullycoveredext -> [5264l]
              | Globalinvocationid -> [28l]
              | Globallinearid -> [34l]
              | Globaloffset -> [33l]
              | Globalsize -> [31l]
              | Helperinvocation -> [23l]
              | Hitislssnv -> [5360l]
              | Hitisspherenv -> [5359l]
              | Hitkindbackfacingmicrotrianglenv -> [5406l]
              | Hitkindfrontfacingmicrotrianglenv -> [5405l]
              | Hitkindkhr -> [5333l]
              | Hitlsspositionsnv -> [5396l]
              | Hitlssradiinv -> [5421l]
              | Hitmicrotrianglevertexbarycentricsnv -> [5344l]
              | Hitmicrotrianglevertexpositionsnv -> [5337l]
              | Hitspherepositionnv -> [5361l]
              | Hitsphereradiusnv -> [5420l]
              | Hittnv -> [5332l]
              | Hittrianglevertexpositionskhr -> [5335l]
              | Incomingrayflagskhr -> [5351l]
              | Instancecustomindexkhr -> [5327l]
              | Instanceid -> [6l]
              | Instanceindex -> [43l]
              | Invocationid -> [8l]
              | Launchidkhr -> [5319l]
              | Launchsizekhr -> [5320l]
              | Layer -> [9l]
              | Layerperviewnv -> [5279l]
              | Localinvocationid -> [27l]
              | Localinvocationindex -> [29l]
              | Meshviewcountnv -> [5280l]
              | Meshviewindicesnv -> [5281l]
              | Numenqueuedsubgroups -> [39l]
              | Numsubgroups -> [38l]
              | Numworkgroups -> [24l]
              | Objectraydirectionkhr -> [5324l]
              | Objectrayoriginkhr -> [5323l]
              | Objecttoworldkhr -> [5330l]
              | Patchvertices -> [14l]
              | Pointcoord -> [16l]
              | Pointsize -> [1l]
              | Position -> [0l]
              | Positionperviewnv -> [5261l]
              | Primitivecountnv -> [5275l]
              | Primitiveid -> [7l]
              | Primitiveindicesnv -> [5276l]
              | Primitivelineindicesext -> [5295l]
              | Primitivepointindicesext -> [5294l]
              | Primitiveshadingratekhr -> [4432l]
              | Primitivetriangleindicesext -> [5296l]
              | Raygeometryindexkhr -> [5352l]
              | Raytmaxkhr -> [5326l]
              | Raytminkhr -> [5325l]
              | Remainingrecursionlevelsamdx -> [5021l]
              | Sampleid -> [18l]
              | Samplemask -> [20l]
              | Sampleposition -> [19l]
              | Secondarypositionnv -> [5257l]
              | Secondaryviewportmasknv -> [5258l]
              | Shaderindexamdx -> [5073l]
              | Shadingratekhr -> [4444l]
              | Smcountnv -> [5375l]
              | Smidnv -> [5377l]
              | Subgroupeqmask -> [4416l]
              | Subgroupgemask -> [4417l]
              | Subgroupgtmask -> [4418l]
              | Subgroupid -> [40l]
              | Subgrouplemask -> [4419l]
              | Subgrouplocalinvocationid -> [41l]
              | Subgroupltmask -> [4420l]
              | Subgroupmaxsize -> [37l]
              | Subgroupsize -> [36l]
              | Taskcountnv -> [5274l]
              | Tesscoord -> [13l]
              | Tesslevelinner -> [12l]
              | Tesslevelouter -> [11l]
              | Tileapronsizeqcom -> [4494l]
              | Tiledimensionqcom -> [4493l]
              | Tileoffsetqcom -> [4492l]
              | Vertexid -> [5l]
              | Vertexindex -> [42l]
              | Viewindex -> [4440l]
              | Viewportindex -> [10l]
              | Viewportmasknv -> [5253l]
              | Viewportmaskperviewnv -> [5262l]
              | Warpidarm -> [4163l]
              | Warpidnv -> [5376l]
              | Warpmaxidarm -> [4164l]
              | Warpspersmnv -> [5374l]
              | Workdim -> [30l]
              | Workgroupid -> [26l]
              | Workgroupsize -> [25l]
              | Worldraydirectionkhr -> [5322l]
              | Worldrayoriginkhr -> [5321l]
              | Worldtoobjectkhr -> [5331l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Barycoordnoperspamd -> true
              | Barycoordnoperspcentroidamd -> true
              | Barycoordnoperspsampleamd -> true
              | Barycoordpullmodelamd -> true
              | Barycoordsmoothamd -> true
              | Barycoordsmoothcentroidamd -> true
              | Barycoordsmoothsampleamd -> true
              | Globalinvocationid -> true
              | Localinvocationid -> true
              | Localinvocationindex -> true
              | Numworkgroups -> true
              | Workgroupid -> true
              | Workgroupsize -> true
              | Barycoordkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentbarycentrickhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Barycoordnoperspkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentbarycentrickhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Baseinstance ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Drawparameters] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Basevertex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Drawparameters] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Clipdistance ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Clipdistance] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Clipdistanceperviewnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Clusteridnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingclusteraccelerationstructurenv]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Corecountarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Corebuiltinsarm] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Coreidarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Corebuiltinsarm] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Coremaxidarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Corebuiltinsarm] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Culldistance ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Culldistance] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Culldistanceperviewnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cullmaskkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raycullmaskkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cullprimitiveext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Currentraytimenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingmotionblurnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Deviceindex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Devicegroup] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Drawindex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Drawparameters;
                           Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Enqueuedworkgroupsize ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Fragcoord ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Fragdepth ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Fraginvocationcountext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentdensityext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragsizeext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentdensityext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragstencilrefext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Stencilexportext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Frontfacing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Fullycoveredext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentfullycoveredext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Globallinearid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Globaloffset ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Globalsize ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Helperinvocation ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Hitislssnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracinglinearsweptspheresgeometrynv]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitisspherenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingspheresgeometrynv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitkindbackfacingmicrotrianglenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingdisplacementmicromapnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitkindfrontfacingmicrotrianglenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingdisplacementmicromapnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitkindkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitlsspositionsnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracinglinearsweptspheresgeometrynv]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitlssradiinv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracinglinearsweptspheresgeometrynv]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitmicrotrianglevertexbarycentricsnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingdisplacementmicromapnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitmicrotrianglevertexpositionsnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingdisplacementmicromapnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitspherepositionnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingspheresgeometrynv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitsphereradiusnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingspheresgeometrynv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hittnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hittrianglevertexpositionskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingpositionfetchkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Incomingrayflagskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Instancecustomindexkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Instanceid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Instanceindex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Invocationid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry; Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Launchidkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Launchsizekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Layer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry;
                           Capability.Shaderlayer;
                           Capability.Shaderviewportindexlayerext;
                           Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Layerperviewnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Meshviewcountnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Meshviewindicesnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Numenqueuedsubgroups ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Numsubgroups ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel; Capability.Groupnonuniform] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Objectraydirectionkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Objectrayoriginkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Objecttoworldkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Patchvertices ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pointcoord ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Pointsize ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Position ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Positionperviewnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Perviewattributesnv;
                           Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Primitivecountnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Primitiveid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry;
                           Capability.Tessellation;
                           Capability.Raytracingnv;
                           Capability.Raytracingkhr;
                           Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Primitiveindicesnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Primitivelineindicesext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Primitivepointindicesext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Primitiveshadingratekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadingratekhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Primitivetriangleindicesext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raygeometryindexkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytmaxkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raytminkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Remainingrecursionlevelsamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sampleid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Samplerateshading] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Samplemask ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Sampleposition ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Samplerateshading] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Secondarypositionnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderstereoviewnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Secondaryviewportmasknv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderstereoviewnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shaderindexamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shadingratekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadingratekhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Smcountnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shadersmbuiltinsnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Smidnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shadersmbuiltinsnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupeqmask ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Subgroupballotkhr;
                           Capability.Groupnonuniformballot] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupgemask ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Subgroupballotkhr;
                           Capability.Groupnonuniformballot] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupgtmask ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Subgroupballotkhr;
                           Capability.Groupnonuniformballot] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel; Capability.Groupnonuniform] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgrouplemask ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Subgroupballotkhr;
                           Capability.Groupnonuniformballot] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgrouplocalinvocationid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel;
                           Capability.Groupnonuniform;
                           Capability.Subgroupballotkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupltmask ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Subgroupballotkhr;
                           Capability.Groupnonuniformballot] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupmaxsize ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Subgroupsize ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel;
                           Capability.Groupnonuniform;
                           Capability.Subgroupballotkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Taskcountnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tesscoord ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tesslevelinner ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tesslevelouter ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tileapronsizeqcom ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileshadingqcom] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tiledimensionqcom ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileshadingqcom] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tileoffsetqcom ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileshadingqcom] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vertexid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Vertexindex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Viewindex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Multiview] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Viewportindex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Multiviewport;
                           Capability.Shaderviewportindex;
                           Capability.Shaderviewportindexlayerext;
                           Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Viewportmasknv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderviewportmasknv;
                           Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Viewportmaskperviewnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Perviewattributesnv;
                           Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Warpidarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Corebuiltinsarm] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Warpidnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shadersmbuiltinsnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Warpmaxidarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Corebuiltinsarm] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Warpspersmnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shadersmbuiltinsnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Workdim ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Worldraydirectionkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Worldrayoriginkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Worldtoobjectkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Clipdistance -> true
              | Corecountarm -> true
              | Coreidarm -> true
              | Coremaxidarm -> true
              | Culldistance -> true
              | Enqueuedworkgroupsize -> true
              | Fragcoord -> true
              | Fragdepth -> true
              | Frontfacing -> true
              | Globalinvocationid -> true
              | Globallinearid -> true
              | Globaloffset -> true
              | Globalsize -> true
              | Helperinvocation -> true
              | Hitkindbackfacingmicrotrianglenv -> true
              | Hitkindfrontfacingmicrotrianglenv -> true
              | Hitmicrotrianglevertexbarycentricsnv -> true
              | Hitmicrotrianglevertexpositionsnv -> true
              | Hittrianglevertexpositionskhr -> true
              | Instanceid -> true
              | Instanceindex -> true
              | Invocationid -> true
              | Layer -> true
              | Localinvocationid -> true
              | Localinvocationindex -> true
              | Numenqueuedsubgroups -> true
              | Numsubgroups -> true
              | Numworkgroups -> true
              | Patchvertices -> true
              | Pointcoord -> true
              | Pointsize -> true
              | Position -> true
              | Primitiveid -> true
              | Remainingrecursionlevelsamdx -> true
              | Sampleid -> true
              | Samplemask -> true
              | Sampleposition -> true
              | Shaderindexamdx -> true
              | Subgroupid -> true
              | Subgrouplocalinvocationid -> true
              | Subgroupmaxsize -> true
              | Subgroupsize -> true
              | Tesscoord -> true
              | Tesslevelinner -> true
              | Tesslevelouter -> true
              | Tileapronsizeqcom -> true
              | Tiledimensionqcom -> true
              | Tileoffsetqcom -> true
              | Vertexid -> true
              | Vertexindex -> true
              | Viewportindex -> true
              | Warpidarm -> true
              | Warpmaxidarm -> true
              | Workdim -> true
              | Workgroupid -> true
              | Workgroupsize -> true
              | Barycoordkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_fragment_shader_barycentric;
                           Requirements.Extension.Spv_khr_fragment_shader_barycentric]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Barycoordnoperspamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Barycoordnoperspcentroidamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Barycoordnoperspkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_fragment_shader_barycentric;
                           Requirements.Extension.Spv_khr_fragment_shader_barycentric]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Barycoordnoperspsampleamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Barycoordpullmodelamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Barycoordsmoothamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Barycoordsmoothcentroidamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Barycoordsmoothsampleamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Baseinstance ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_draw_parameters]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Basevertex ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_draw_parameters]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Clipdistanceperviewnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Clusteridnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_cluster_acceleration_structure]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Culldistanceperviewnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Cullmaskkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_cull_mask] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Cullprimitiveext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Currentraytimenv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing_motion_blur]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Deviceindex ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_device_group] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Drawindex ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_draw_parameters;
                           Requirements.Extension.Spv_nv_mesh_shader;
                           Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Fraginvocationcountext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_invocation_density;
                           Requirements.Extension.Spv_nv_shading_rate] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Fragsizeext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_invocation_density;
                           Requirements.Extension.Spv_nv_shading_rate] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Fragstencilrefext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Fullycoveredext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_fully_covered]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Hitislssnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_linear_swept_spheres]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Hitisspherenv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_linear_swept_spheres]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Hitkindkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Hitlsspositionsnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_linear_swept_spheres]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Hitlssradiinv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_linear_swept_spheres]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Hitspherepositionnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_linear_swept_spheres]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Hitsphereradiusnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_linear_swept_spheres]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Hittnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Incomingrayflagskhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Instancecustomindexkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Launchidkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Launchsizekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Layerperviewnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Meshviewcountnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Meshviewindicesnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Objectraydirectionkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Objectrayoriginkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Objecttoworldkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Positionperviewnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nvx_multiview_per_view_attributes;
                           Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Primitivecountnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Primitiveindicesnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Primitivelineindicesext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Primitivepointindicesext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Primitiveshadingratekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_fragment_shading_rate]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Primitivetriangleindicesext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Raygeometryindexkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Raytmaxkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Raytminkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Secondarypositionnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_stereo_view_rendering]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Secondaryviewportmasknv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_stereo_view_rendering]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shadingratekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_fragment_shading_rate]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Smcountnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_sm_builtins]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Smidnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_sm_builtins]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroupeqmask ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_ballot] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroupgemask ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_ballot] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroupgtmask ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_ballot] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgrouplemask ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_ballot] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Subgroupltmask ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_shader_ballot] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Taskcountnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Viewindex ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_multiview] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Viewportmasknv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_viewport_array2;
                           Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Viewportmaskperviewnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nvx_multiview_per_view_attributes;
                           Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Warpidnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_sm_builtins]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Warpspersmnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_sm_builtins]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Worldraydirectionkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Worldrayoriginkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Worldtoobjectkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Barycoordkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Barycoordnoperspamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Barycoordnoperspcentroidamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Barycoordnoperspkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Barycoordnoperspsampleamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Barycoordpullmodelamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Barycoordsmoothamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Barycoordsmoothcentroidamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Barycoordsmoothsampleamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Baseinstance ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Basevertex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Clipdistance ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Clipdistanceperviewnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Clusteridnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Corecountarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Coreidarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Coremaxidarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Culldistance ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Culldistanceperviewnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cullmaskkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cullprimitiveext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Currentraytimenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Deviceindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Drawindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Enqueuedworkgroupsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragcoord ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragdepth ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fraginvocationcountext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragsizeext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragstencilrefext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Frontfacing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fullycoveredext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Globalinvocationid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Globallinearid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Globaloffset ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Globalsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Helperinvocation ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitislssnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitisspherenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitkindbackfacingmicrotrianglenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitkindfrontfacingmicrotrianglenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitkindkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitlsspositionsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitlssradiinv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitmicrotrianglevertexbarycentricsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitmicrotrianglevertexpositionsnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitspherepositionnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitsphereradiusnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hittnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hittrianglevertexpositionskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Incomingrayflagskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Instancecustomindexkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Instanceid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Instanceindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Invocationid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Launchidkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Launchsizekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Layer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Layerperviewnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Localinvocationid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Localinvocationindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Meshviewcountnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Meshviewindicesnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Numenqueuedsubgroups ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Numsubgroups ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Numworkgroups ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Objectraydirectionkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Objectrayoriginkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Objecttoworldkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Patchvertices ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pointcoord ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pointsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Position ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Positionperviewnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Primitivecountnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Primitiveid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Primitiveindicesnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Primitivelineindicesext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Primitivepointindicesext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Primitiveshadingratekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Primitivetriangleindicesext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raygeometryindexkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytmaxkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raytminkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Remainingrecursionlevelsamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampleid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Samplemask ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampleposition ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Secondarypositionnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Secondaryviewportmasknv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderindexamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shadingratekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Smcountnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Smidnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupeqmask ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupgemask ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupgtmask ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgrouplemask ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgrouplocalinvocationid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupltmask ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupmaxsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Taskcountnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tesscoord ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tesslevelinner ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tesslevelouter ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileapronsizeqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tiledimensionqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileoffsetqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vertexid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vertexindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Viewindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Viewportindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Viewportmasknv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Viewportmaskperviewnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Warpidarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Warpidnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Warpmaxidarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Warpspersmnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workdim ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workgroupid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workgroupsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Worldraydirectionkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Worldrayoriginkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Worldtoobjectkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Componenttype =
          struct
            type t =
              | Float16nv 
              | Float32nv 
              | Float64nv 
              | Floate4m3nv 
              | Floate5m2nv 
              | Signedint16nv 
              | Signedint32nv 
              | Signedint64nv 
              | Signedint8nv 
              | Signedint8packednv 
              | Unsignedint16nv 
              | Unsignedint32nv 
              | Unsignedint64nv 
              | Unsignedint8nv 
              | Unsignedint8packednv [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Float16nv -> [0l]
              | Float32nv -> [1l]
              | Float64nv -> [2l]
              | Floate4m3nv -> [1000491002l]
              | Floate5m2nv -> [1000491003l]
              | Signedint16nv -> [4l]
              | Signedint32nv -> [5l]
              | Signedint64nv -> [6l]
              | Signedint8nv -> [3l]
              | Signedint8packednv -> [1000491000l]
              | Unsignedint16nv -> [8l]
              | Unsignedint32nv -> [9l]
              | Unsignedint64nv -> [10l]
              | Unsignedint8nv -> [7l]
              | Unsignedint8packednv -> [1000491001l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Float16nv -> true
              | Float32nv -> true
              | Float64nv -> true
              | Floate4m3nv -> true
              | Floate5m2nv -> true
              | Signedint16nv -> true
              | Signedint32nv -> true
              | Signedint64nv -> true
              | Signedint8nv -> true
              | Signedint8packednv -> true
              | Unsignedint16nv -> true
              | Unsignedint32nv -> true
              | Unsignedint64nv -> true
              | Unsignedint8nv -> true
              | Unsignedint8packednv -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Float16nv -> true
              | Float32nv -> true
              | Float64nv -> true
              | Floate4m3nv -> true
              | Floate5m2nv -> true
              | Signedint16nv -> true
              | Signedint32nv -> true
              | Signedint64nv -> true
              | Signedint8nv -> true
              | Signedint8packednv -> true
              | Unsignedint16nv -> true
              | Unsignedint32nv -> true
              | Unsignedint64nv -> true
              | Unsignedint8nv -> true
              | Unsignedint8packednv -> true
            let satisfies_version t ~version =
              match t with
              | Float16nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float32nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float64nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Floate4m3nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Floate5m2nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedint16nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedint32nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedint64nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedint8nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedint8packednv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint16nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint32nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint64nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint8nv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint8packednv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Cooperativematrixlayout =
          struct
            type t =
              | Columnblockedinterleavedarm 
              | Columnmajorkhr 
              | Rowblockedinterleavedarm 
              | Rowmajorkhr [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Columnblockedinterleavedarm -> [4203l]
              | Columnmajorkhr -> [1l]
              | Rowblockedinterleavedarm -> [4202l]
              | Rowmajorkhr -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Columnmajorkhr -> true
              | Rowmajorkhr -> true
              | Columnblockedinterleavedarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cooperativematrixlayoutsarm] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rowblockedinterleavedarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cooperativematrixlayoutsarm] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Columnblockedinterleavedarm -> true
              | Columnmajorkhr -> true
              | Rowblockedinterleavedarm -> true
              | Rowmajorkhr -> true
            let satisfies_version t ~version =
              match t with
              | Columnblockedinterleavedarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Columnmajorkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rowblockedinterleavedarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rowmajorkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Cooperativematrixoperands =
          struct
            type t =
              | Matrixasignedcomponentskhr 
              | Matrixbsignedcomponentskhr 
              | Matrixcsignedcomponentskhr 
              | Matrixresultsignedcomponentskhr 
              | Nonekhr 
              | Saturatingaccumulationkhr [@@deriving
                                            compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Matrixasignedcomponentskhr -> [1l]
              | Matrixbsignedcomponentskhr -> [2l]
              | Matrixcsignedcomponentskhr -> [4l]
              | Matrixresultsignedcomponentskhr -> [8l]
              | Nonekhr -> [0l]
              | Saturatingaccumulationkhr -> [16l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Matrixasignedcomponentskhr -> true
              | Matrixbsignedcomponentskhr -> true
              | Matrixcsignedcomponentskhr -> true
              | Matrixresultsignedcomponentskhr -> true
              | Nonekhr -> true
              | Saturatingaccumulationkhr -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Matrixasignedcomponentskhr -> true
              | Matrixbsignedcomponentskhr -> true
              | Matrixcsignedcomponentskhr -> true
              | Matrixresultsignedcomponentskhr -> true
              | Nonekhr -> true
              | Saturatingaccumulationkhr -> true
            let satisfies_version t ~version =
              match t with
              | Matrixasignedcomponentskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixbsignedcomponentskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixcsignedcomponentskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixresultsignedcomponentskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Saturatingaccumulationkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Cooperativematrixreduce =
          struct
            type t =
              | Column 
              | Row 
              | V2x2 [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function | Column -> [2l] | Row -> [1l] | V2x2 -> [4l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with | Column -> true | Row -> true | V2x2 -> true
            let satisfies_extensions t ~extensions:_ =
              match t with | Column -> true | Row -> true | V2x2 -> true
            let satisfies_version t ~version =
              match t with
              | Column ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Row ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | V2x2 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Cooperativematrixuse =
          struct
            type t =
              | Matrixaccumulatorkhr 
              | Matrixakhr 
              | Matrixbkhr [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Matrixaccumulatorkhr -> [2l]
              | Matrixakhr -> [0l]
              | Matrixbkhr -> [1l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Matrixaccumulatorkhr -> true
              | Matrixakhr -> true
              | Matrixbkhr -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Matrixaccumulatorkhr -> true
              | Matrixakhr -> true
              | Matrixbkhr -> true
            let satisfies_version t ~version =
              match t with
              | Matrixaccumulatorkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixakhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixbkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Cooperativevectormatrixlayout =
          struct
            type t =
              | Columnmajornv 
              | Inferencingoptimalnv 
              | Rowmajornv 
              | Trainingoptimalnv [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Columnmajornv -> [1l]
              | Inferencingoptimalnv -> [2l]
              | Rowmajornv -> [0l]
              | Trainingoptimalnv -> [3l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Columnmajornv -> true
              | Inferencingoptimalnv -> true
              | Rowmajornv -> true
              | Trainingoptimalnv -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Columnmajornv -> true
              | Inferencingoptimalnv -> true
              | Rowmajornv -> true
              | Trainingoptimalnv -> true
            let satisfies_version t ~version =
              match t with
              | Columnmajornv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inferencingoptimalnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rowmajornv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Trainingoptimalnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Decoration =
          struct
            type t =
              | Aliased 
              | Aliasedpointer 
              | Aliasscopeintel 
              | Alignment 
              | Alignmentid 
              | Arraystride 
              | Bankbitsaltera 
              | Bankwidthaltera 
              | Binding 
              | Bindlessimagenv 
              | Bindlesssamplernv 
              | Block 
              | Blockmatchsamplerqcom 
              | Blockmatchtextureqcom 
              | Boundimagenv 
              | Boundsamplernv 
              | Bufferblock 
              | Bufferlocationaltera 
              | Builtin 
              | Burstcoalescealtera 
              | Cachecontrolloadintel 
              | Cachecontrolstoreintel 
              | Cachesizealtera 
              | Centroid 
              | Clobberintel 
              | Coherent 
              | Colmajor 
              | Component 
              | Conditionalintel 
              | Conduitkernelargumentaltera 
              | Constant 
              | Counterbuffer 
              | Cpacked 
              | Descriptorset 
              | Dontstaticallycoalescealtera 
              | Doublepumpaltera 
              | Explicitinterpamd 
              | Flat 
              | Forcepow2depthaltera 
              | Fpfastmathmode 
              | Fpmaxerrordecorationintel 
              | Fproundingmode 
              | Funcparamattr 
              | Funcparamiokindintel 
              | Functiondenormmodeintel 
              | Functionfloatingpointmodeintel 
              | Functionroundingmodeintel 
              | Fuseloopsinfunctionaltera 
              | Globalvariableoffsetintel 
              | Glslpacked 
              | Glslshared 
              | Hitobjectshaderrecordbufferext 
              | Hitobjectshaderrecordbuffernv 
              | Hostaccessintel 
              | Implementinregistermapaltera 
              | Index 
              | Initiationintervalaltera 
              | Initmodealtera 
              | Inputattachmentindex 
              | Invariant 
              | Iopipestoragealtera 
              | Latencycontrolconstraintaltera 
              | Latencycontrollabelaltera 
              | Linkageattributes 
              | Location 
              | Mathopdspmodealtera 
              | Matrixstride 
              | Maxbyteoffset 
              | Maxbyteoffsetid 
              | Maxconcurrencyaltera 
              | Maxprivatecopiesaltera 
              | Maxreplicatesaltera 
              | Mediablockiointel 
              | Memoryaltera 
              | Mergealtera 
              | Mmhostinterfaceaddresswidthaltera 
              | Mmhostinterfacedatawidthaltera 
              | Mmhostinterfacelatencyaltera 
              | Mmhostinterfacemaxburstaltera 
              | Mmhostinterfacereadwritemodealtera 
              | Mmhostinterfacewaitrequestaltera 
              | Noaliasintel 
              | Nocontraction 
              | Nodemaxpayloadsamdx 
              | Nodesharespayloadlimitswithamdx 
              | Nonreadable 
              | Nonuniform 
              | Nonwritable 
              | Noperspective 
              | Nosignedwrap 
              | Nounsignedwrap 
              | Numbanksaltera 
              | Offset 
              | Overridecoveragenv 
              | Passthroughnv 
              | Patch 
              | Payloaddispatchindirectamdx 
              | Payloadnodearraysizeamdx 
              | Payloadnodebaseindexamdx 
              | Payloadnodenameamdx 
              | Payloadnodesparsearrayamdx 
              | Perprimitiveext 
              | Pertasknv 
              | Pervertexkhr 
              | Perviewnv 
              | Pipelineenablealtera 
              | Prefetchaltera 
              | Referencedindirectlyintel 
              | Registeraltera 
              | Registermapkernelargumentaltera 
              | Relaxedprecision 
              | Restrict 
              | Restrictpointer 
              | Rowmajor 
              | Sample 
              | Saturatedconversion 
              | Saturatedtolargestfloat8normalconversionext 
              | Secondaryviewportrelativenv 
              | Sideeffectsintel 
              | Simpledualportaltera 
              | Simtcallintel 
              | Singleelementvectorintel 
              | Singlepumpaltera 
              | Specid 
              | Stablekernelargumentaltera 
              | Stackcallintel 
              | Stallenablealtera 
              | Stallfreealtera 
              | Stream 
              | Stridesizealtera 
              | Trackfinishwritingamdx 
              | Truedualportaltera 
              | Uniform 
              | Uniformid 
              | Usersemantic 
              | Usertypegoogle 
              | Vectorcomputecallablefunctionintel 
              | Vectorcomputefunctionintel 
              | Vectorcomputevariableintel 
              | Viewportrelativenv 
              | Volatile 
              | Weighttextureqcom 
              | Wordsizealtera 
              | Xfbbuffer 
              | Xfbstride [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Aliased -> [20l]
              | Aliasedpointer -> [5356l]
              | Aliasscopeintel -> [5914l]
              | Alignment -> [44l]
              | Alignmentid -> [46l]
              | Arraystride -> [6l]
              | Bankbitsaltera -> [5835l]
              | Bankwidthaltera -> [5828l]
              | Binding -> [33l]
              | Bindlessimagenv -> [5399l]
              | Bindlesssamplernv -> [5398l]
              | Block -> [2l]
              | Blockmatchsamplerqcom -> [4499l]
              | Blockmatchtextureqcom -> [4488l]
              | Boundimagenv -> [5401l]
              | Boundsamplernv -> [5400l]
              | Bufferblock -> [3l]
              | Bufferlocationaltera -> [5921l]
              | Builtin -> [11l]
              | Burstcoalescealtera -> [5899l]
              | Cachecontrolloadintel -> [6442l]
              | Cachecontrolstoreintel -> [6443l]
              | Cachesizealtera -> [5900l]
              | Centroid -> [16l]
              | Clobberintel -> [5607l]
              | Coherent -> [23l]
              | Colmajor -> [5l]
              | Component -> [31l]
              | Conditionalintel -> [6247l]
              | Conduitkernelargumentaltera -> [6175l]
              | Constant -> [22l]
              | Counterbuffer -> [5634l]
              | Cpacked -> [10l]
              | Descriptorset -> [34l]
              | Dontstaticallycoalescealtera -> [5901l]
              | Doublepumpaltera -> [5831l]
              | Explicitinterpamd -> [4999l]
              | Flat -> [14l]
              | Forcepow2depthaltera -> [5836l]
              | Fpfastmathmode -> [40l]
              | Fpmaxerrordecorationintel -> [6170l]
              | Fproundingmode -> [39l]
              | Funcparamattr -> [38l]
              | Funcparamiokindintel -> [5625l]
              | Functiondenormmodeintel -> [5823l]
              | Functionfloatingpointmodeintel -> [6080l]
              | Functionroundingmodeintel -> [5822l]
              | Fuseloopsinfunctionaltera -> [5907l]
              | Globalvariableoffsetintel -> [5628l]
              | Glslpacked -> [9l]
              | Glslshared -> [8l]
              | Hitobjectshaderrecordbufferext -> [5389l]
              | Hitobjectshaderrecordbuffernv -> [5386l]
              | Hostaccessintel -> [6188l]
              | Implementinregistermapaltera -> [6191l]
              | Index -> [32l]
              | Initiationintervalaltera -> [5917l]
              | Initmodealtera -> [6190l]
              | Inputattachmentindex -> [43l]
              | Invariant -> [18l]
              | Iopipestoragealtera -> [5944l]
              | Latencycontrolconstraintaltera -> [6173l]
              | Latencycontrollabelaltera -> [6172l]
              | Linkageattributes -> [41l]
              | Location -> [30l]
              | Mathopdspmodealtera -> [5909l]
              | Matrixstride -> [7l]
              | Maxbyteoffset -> [45l]
              | Maxbyteoffsetid -> [47l]
              | Maxconcurrencyaltera -> [5918l]
              | Maxprivatecopiesaltera -> [5829l]
              | Maxreplicatesaltera -> [5832l]
              | Mediablockiointel -> [6140l]
              | Memoryaltera -> [5826l]
              | Mergealtera -> [5834l]
              | Mmhostinterfaceaddresswidthaltera -> [6177l]
              | Mmhostinterfacedatawidthaltera -> [6178l]
              | Mmhostinterfacelatencyaltera -> [6179l]
              | Mmhostinterfacemaxburstaltera -> [6181l]
              | Mmhostinterfacereadwritemodealtera -> [6180l]
              | Mmhostinterfacewaitrequestaltera -> [6182l]
              | Noaliasintel -> [5915l]
              | Nocontraction -> [42l]
              | Nodemaxpayloadsamdx -> [5020l]
              | Nodesharespayloadlimitswithamdx -> [5019l]
              | Nonreadable -> [25l]
              | Nonuniform -> [5300l]
              | Nonwritable -> [24l]
              | Noperspective -> [13l]
              | Nosignedwrap -> [4469l]
              | Nounsignedwrap -> [4470l]
              | Numbanksaltera -> [5827l]
              | Offset -> [35l]
              | Overridecoveragenv -> [5248l]
              | Passthroughnv -> [5250l]
              | Patch -> [15l]
              | Payloaddispatchindirectamdx -> [5105l]
              | Payloadnodearraysizeamdx -> [5100l]
              | Payloadnodebaseindexamdx -> [5098l]
              | Payloadnodenameamdx -> [5091l]
              | Payloadnodesparsearrayamdx -> [5099l]
              | Perprimitiveext -> [5271l]
              | Pertasknv -> [5273l]
              | Pervertexkhr -> [5285l]
              | Perviewnv -> [5272l]
              | Pipelineenablealtera -> [5919l]
              | Prefetchaltera -> [5902l]
              | Referencedindirectlyintel -> [5602l]
              | Registeraltera -> [5825l]
              | Registermapkernelargumentaltera -> [6176l]
              | Relaxedprecision -> [0l]
              | Restrict -> [19l]
              | Restrictpointer -> [5355l]
              | Rowmajor -> [4l]
              | Sample -> [17l]
              | Saturatedconversion -> [28l]
              | Saturatedtolargestfloat8normalconversionext -> [4216l]
              | Secondaryviewportrelativenv -> [5256l]
              | Sideeffectsintel -> [5608l]
              | Simpledualportaltera -> [5833l]
              | Simtcallintel -> [5599l]
              | Singleelementvectorintel -> [6085l]
              | Singlepumpaltera -> [5830l]
              | Specid -> [1l]
              | Stablekernelargumentaltera -> [6183l]
              | Stackcallintel -> [5627l]
              | Stallenablealtera -> [5905l]
              | Stallfreealtera -> [6151l]
              | Stream -> [29l]
              | Stridesizealtera -> [5883l]
              | Trackfinishwritingamdx -> [5078l]
              | Truedualportaltera -> [5885l]
              | Uniform -> [26l]
              | Uniformid -> [27l]
              | Usersemantic -> [5635l]
              | Usertypegoogle -> [5636l]
              | Vectorcomputecallablefunctionintel -> [6087l]
              | Vectorcomputefunctionintel -> [5626l]
              | Vectorcomputevariableintel -> [5624l]
              | Viewportrelativenv -> [5252l]
              | Volatile -> [21l]
              | Weighttextureqcom -> [4487l]
              | Wordsizealtera -> [5884l]
              | Xfbbuffer -> [36l]
              | Xfbstride -> [37l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Aliased -> true
              | Blockmatchsamplerqcom -> true
              | Blockmatchtextureqcom -> true
              | Builtin -> true
              | Coherent -> true
              | Counterbuffer -> true
              | Explicitinterpamd -> true
              | Fproundingmode -> true
              | Nonreadable -> true
              | Nonwritable -> true
              | Nosignedwrap -> true
              | Nounsignedwrap -> true
              | Restrict -> true
              | Usersemantic -> true
              | Usertypegoogle -> true
              | Volatile -> true
              | Weighttextureqcom -> true
              | Aliasedpointer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Physicalstoragebufferaddresses] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Aliasscopeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Memoryaccessaliasingintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Alignment ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Alignmentid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Arraystride ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Bankbitsaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Bankwidthaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Binding ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Bindlessimagenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Bindlesstexturenv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Bindlesssamplernv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Bindlesstexturenv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Block ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Boundimagenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Bindlesstexturenv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Boundsamplernv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Bindlesstexturenv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Bufferblock ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Bufferlocationaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgabufferlocationaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Burstcoalescealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryaccessesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cachecontrolloadintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cachecontrolstoreintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cachesizealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryaccessesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Centroid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Clobberintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Asmintel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Colmajor ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Matrix] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Component ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Conditionalintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Specconditionalintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Conduitkernelargumentaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Constant ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Cpacked ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Descriptorset ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Dontstaticallycoalescealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryaccessesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Doublepumpaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Flat ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Forcepow2depthaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fpfastmathmode ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel; Capability.Floatcontrols2] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fpmaxerrordecorationintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpmaxerrorintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Funcparamattr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Funcparamiokindintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Functiondenormmodeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Functionfloatcontrolintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Functionfloatingpointmodeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Functionfloatcontrolintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Functionroundingmodeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Functionfloatcontrolintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fuseloopsinfunctionaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Loopfusealtera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Globalvariableoffsetintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Glslpacked ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Glslshared ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Hitobjectshaderrecordbufferext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderinvocationreorderext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitobjectshaderrecordbuffernv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderinvocationreordernv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hostaccessintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablehostaccessintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Implementinregistermapaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablefpgadecorationsaltera]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Index ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Initiationintervalaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgainvocationpipeliningattributesaltera]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Initmodealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablefpgadecorationsaltera]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Inputattachmentindex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Inputattachment] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Invariant ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Iopipestoragealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Iopipesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Latencycontrolconstraintaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgalatencycontrolaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Latencycontrollabelaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgalatencycontrolaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Linkageattributes ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Linkage] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Location ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Mathopdspmodealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgadspcontrolaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Matrixstride ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Matrix] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Maxbyteoffset ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Addresses] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Maxbyteoffsetid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Addresses] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Maxconcurrencyaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgainvocationpipeliningattributesaltera]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxprivatecopiesaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxreplicatesaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Mediablockiointel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Memoryaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Mergealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Mmhostinterfaceaddresswidthaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Mmhostinterfacedatawidthaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Mmhostinterfacelatencyaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Mmhostinterfacemaxburstaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Mmhostinterfacereadwritemodealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Mmhostinterfacewaitrequestaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noaliasintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Memoryaccessaliasingintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Nocontraction ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Nodemaxpayloadsamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Nodesharespayloadlimitswithamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Nonuniform ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shadernonuniform] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noperspective ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Numbanksaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Offset ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Overridecoveragenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Samplemaskoverridecoveragenv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Passthroughnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometryshaderpassthroughnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Patch ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Payloaddispatchindirectamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Payloadnodearraysizeamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Payloadnodebaseindexamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Payloadnodenameamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Payloadnodesparsearrayamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Perprimitiveext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pertasknv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pervertexkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentbarycentrickhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Perviewnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pipelineenablealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgainvocationpipeliningattributesaltera]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Prefetchaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryaccessesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Referencedindirectlyintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Indirectreferencesintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Registeraltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Registermapkernelargumentaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Relaxedprecision ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Restrictpointer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Physicalstoragebufferaddresses] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rowmajor ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Matrix] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Sample ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Samplerateshading] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Saturatedconversion ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Saturatedtolargestfloat8normalconversionext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Float8ext] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Secondaryviewportrelativenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderstereoviewnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sideeffectsintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Asmintel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Simpledualportaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Simtcallintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Singleelementvectorintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Singlepumpaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Specid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader; Capability.Kernel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stablekernelargumentaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaargumentinterfacesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stackcallintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stallenablealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaclusterattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stallfreealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaclusterattributesv2altera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stream ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometrystreams] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stridesizealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Trackfinishwritingamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Truedualportaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uniform ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader; Capability.Uniformdecoration]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uniformid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader; Capability.Uniformdecoration]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vectorcomputecallablefunctionintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vectorcomputefunctionintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vectorcomputevariableintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Viewportrelativenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderviewportmasknv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Wordsizealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgamemoryattributesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Xfbbuffer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Transformfeedback] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Xfbstride ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Transformfeedback] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Aliased -> true
              | Aliasscopeintel -> true
              | Alignment -> true
              | Alignmentid -> true
              | Arraystride -> true
              | Bankbitsaltera -> true
              | Bankwidthaltera -> true
              | Binding -> true
              | Bindlessimagenv -> true
              | Bindlesssamplernv -> true
              | Block -> true
              | Boundimagenv -> true
              | Boundsamplernv -> true
              | Bufferblock -> true
              | Bufferlocationaltera -> true
              | Builtin -> true
              | Burstcoalescealtera -> true
              | Cachecontrolloadintel -> true
              | Cachecontrolstoreintel -> true
              | Cachesizealtera -> true
              | Centroid -> true
              | Clobberintel -> true
              | Coherent -> true
              | Colmajor -> true
              | Component -> true
              | Conditionalintel -> true
              | Conduitkernelargumentaltera -> true
              | Constant -> true
              | Cpacked -> true
              | Descriptorset -> true
              | Dontstaticallycoalescealtera -> true
              | Doublepumpaltera -> true
              | Flat -> true
              | Forcepow2depthaltera -> true
              | Fpfastmathmode -> true
              | Fpmaxerrordecorationintel -> true
              | Fproundingmode -> true
              | Funcparamattr -> true
              | Funcparamiokindintel -> true
              | Functiondenormmodeintel -> true
              | Functionfloatingpointmodeintel -> true
              | Functionroundingmodeintel -> true
              | Fuseloopsinfunctionaltera -> true
              | Globalvariableoffsetintel -> true
              | Glslpacked -> true
              | Glslshared -> true
              | Hitobjectshaderrecordbufferext -> true
              | Hitobjectshaderrecordbuffernv -> true
              | Hostaccessintel -> true
              | Implementinregistermapaltera -> true
              | Index -> true
              | Initiationintervalaltera -> true
              | Initmodealtera -> true
              | Inputattachmentindex -> true
              | Invariant -> true
              | Iopipestoragealtera -> true
              | Latencycontrolconstraintaltera -> true
              | Latencycontrollabelaltera -> true
              | Linkageattributes -> true
              | Location -> true
              | Mathopdspmodealtera -> true
              | Matrixstride -> true
              | Maxbyteoffset -> true
              | Maxbyteoffsetid -> true
              | Maxconcurrencyaltera -> true
              | Maxprivatecopiesaltera -> true
              | Maxreplicatesaltera -> true
              | Mediablockiointel -> true
              | Memoryaltera -> true
              | Mergealtera -> true
              | Mmhostinterfaceaddresswidthaltera -> true
              | Mmhostinterfacedatawidthaltera -> true
              | Mmhostinterfacelatencyaltera -> true
              | Mmhostinterfacemaxburstaltera -> true
              | Mmhostinterfacereadwritemodealtera -> true
              | Mmhostinterfacewaitrequestaltera -> true
              | Noaliasintel -> true
              | Nocontraction -> true
              | Nodemaxpayloadsamdx -> true
              | Nodesharespayloadlimitswithamdx -> true
              | Nonreadable -> true
              | Nonwritable -> true
              | Noperspective -> true
              | Numbanksaltera -> true
              | Offset -> true
              | Patch -> true
              | Payloaddispatchindirectamdx -> true
              | Payloadnodearraysizeamdx -> true
              | Payloadnodebaseindexamdx -> true
              | Payloadnodenameamdx -> true
              | Payloadnodesparsearrayamdx -> true
              | Pipelineenablealtera -> true
              | Prefetchaltera -> true
              | Registeraltera -> true
              | Registermapkernelargumentaltera -> true
              | Relaxedprecision -> true
              | Restrict -> true
              | Rowmajor -> true
              | Sample -> true
              | Saturatedconversion -> true
              | Saturatedtolargestfloat8normalconversionext -> true
              | Sideeffectsintel -> true
              | Simpledualportaltera -> true
              | Simtcallintel -> true
              | Singleelementvectorintel -> true
              | Singlepumpaltera -> true
              | Specid -> true
              | Stablekernelargumentaltera -> true
              | Stackcallintel -> true
              | Stallenablealtera -> true
              | Stallfreealtera -> true
              | Stream -> true
              | Stridesizealtera -> true
              | Trackfinishwritingamdx -> true
              | Truedualportaltera -> true
              | Uniform -> true
              | Uniformid -> true
              | Vectorcomputecallablefunctionintel -> true
              | Vectorcomputefunctionintel -> true
              | Vectorcomputevariableintel -> true
              | Viewportrelativenv -> true
              | Volatile -> true
              | Wordsizealtera -> true
              | Xfbbuffer -> true
              | Xfbstride -> true
              | Aliasedpointer ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_physical_storage_buffer;
                           Requirements.Extension.Spv_khr_physical_storage_buffer]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Blockmatchsamplerqcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_image_processing2]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Blockmatchtextureqcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_image_processing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Counterbuffer ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_google_hlsl_functionality1]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Explicitinterpamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Nonuniform ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_descriptor_indexing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Nosignedwrap ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_no_integer_wrap_decoration]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Nounsignedwrap ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_no_integer_wrap_decoration]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Overridecoveragenv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_sample_mask_override_coverage]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Passthroughnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_geometry_shader_passthrough]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Perprimitiveext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader;
                           Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Pertasknv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Pervertexkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_fragment_shader_barycentric;
                           Requirements.Extension.Spv_khr_fragment_shader_barycentric]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Perviewnv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Referencedindirectlyintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_function_pointers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Restrictpointer ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_physical_storage_buffer;
                           Requirements.Extension.Spv_khr_physical_storage_buffer]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Secondaryviewportrelativenv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_stereo_view_rendering]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Usersemantic ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_google_hlsl_functionality1]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Usertypegoogle ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_google_user_type] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Weighttextureqcom ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_qcom_image_processing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Aliased ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Aliasedpointer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Aliasscopeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Alignment ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Alignmentid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_2) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Arraystride ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bankbitsaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bankwidthaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Binding ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bindlessimagenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bindlesssamplernv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Block ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Blockmatchsamplerqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Blockmatchtextureqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Boundimagenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Boundsamplernv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bufferblock ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:(Some V1_3))
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bufferlocationaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Builtin ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Burstcoalescealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cachecontrolloadintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cachecontrolstoreintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cachesizealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Centroid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Clobberintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Coherent ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Colmajor ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Component ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Conditionalintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Conduitkernelargumentaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Constant ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Counterbuffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cpacked ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Descriptorset ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dontstaticallycoalescealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Doublepumpaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Explicitinterpamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Flat ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Forcepow2depthaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpfastmathmode ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpmaxerrordecorationintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fproundingmode ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Funcparamattr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Funcparamiokindintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Functiondenormmodeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Functionfloatingpointmodeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Functionroundingmodeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fuseloopsinfunctionaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Globalvariableoffsetintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Glslpacked ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Glslshared ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitobjectshaderrecordbufferext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitobjectshaderrecordbuffernv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hostaccessintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Implementinregistermapaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Index ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Initiationintervalaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Initmodealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inputattachmentindex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Invariant ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Iopipestoragealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Latencycontrolconstraintaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Latencycontrollabelaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Linkageattributes ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Location ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mathopdspmodealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixstride ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxbyteoffset ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxbyteoffsetid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_2) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxconcurrencyaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxprivatecopiesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxreplicatesaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mediablockiointel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Memoryaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mergealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mmhostinterfaceaddresswidthaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mmhostinterfacedatawidthaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mmhostinterfacelatencyaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mmhostinterfacemaxburstaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mmhostinterfacereadwritemodealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Mmhostinterfacewaitrequestaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noaliasintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nocontraction ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nodemaxpayloadsamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nodesharespayloadlimitswithamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonreadable ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonuniform ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonwritable ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noperspective ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nosignedwrap ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nounsignedwrap ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Numbanksaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Offset ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Overridecoveragenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Passthroughnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Patch ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Payloaddispatchindirectamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Payloadnodearraysizeamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Payloadnodebaseindexamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Payloadnodenameamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Payloadnodesparsearrayamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Perprimitiveext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pertasknv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pervertexkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Perviewnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pipelineenablealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Prefetchaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Referencedindirectlyintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Registeraltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Registermapkernelargumentaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Relaxedprecision ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Restrict ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Restrictpointer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rowmajor ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sample ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Saturatedconversion ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Saturatedtolargestfloat8normalconversionext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Secondaryviewportrelativenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sideeffectsintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Simpledualportaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Simtcallintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Singleelementvectorintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Singlepumpaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Specid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stablekernelargumentaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stackcallintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stallenablealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stallfreealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stream ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stridesizealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Trackfinishwritingamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Truedualportaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniform ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Usersemantic ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Usertypegoogle ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vectorcomputecallablefunctionintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vectorcomputefunctionintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vectorcomputevariableintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Viewportrelativenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Volatile ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Weighttextureqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Wordsizealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Xfbbuffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Xfbstride ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Dim =
          struct
            type t =
              | Buffer 
              | Cube 
              | Rect 
              | Subpassdata 
              | Tileimagedataext 
              | V1d 
              | V2d 
              | V3d [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Buffer -> [5l]
              | Cube -> [3l]
              | Rect -> [4l]
              | Subpassdata -> [6l]
              | Tileimagedataext -> [4173l]
              | V1d -> [0l]
              | V2d -> [1l]
              | V3d -> [2l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | V2d -> true
              | V3d -> true
              | Buffer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Sampledbuffer] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cube ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rect ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Sampledrect] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Subpassdata ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Inputattachment] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tileimagedataext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileimagecolorreadaccessext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | V1d ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Sampled1d] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Buffer -> true
              | Cube -> true
              | Rect -> true
              | Subpassdata -> true
              | Tileimagedataext -> true
              | V1d -> true
              | V2d -> true
              | V3d -> true
            let satisfies_version t ~version =
              match t with
              | Buffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cube ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rect ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subpassdata ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileimagedataext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | V1d ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | V2d ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | V3d ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Executionmode =
          struct
            type t =
              | Coalescingamdx 
              | Contractionoff 
              | Denormflushtozero 
              | Denormpreserve 
              | Depthgreater 
              | Depthless 
              | Depthreplacing 
              | Depthunchanged 
              | Derivativegrouplinearkhr 
              | Derivativegroupquadskhr 
              | Earlyandlatefragmenttestsamd 
              | Earlyfragmenttests 
              | Finalizer 
              | Floatingpointmodealtintel 
              | Floatingpointmodeieeeintel 
              | Fpfastmathdefault 
              | Initializer 
              | Inputlines 
              | Inputlinesadjacency 
              | Inputpoints 
              | Inputtrianglesadjacency 
              | Invocations 
              | Isapientryamdx 
              | Isolines 
              | Localsize 
              | Localsizehint 
              | Localsizehintid 
              | Localsizeid 
              | Maximallyreconvergeskhr 
              | Maximumregistersidintel 
              | Maximumregistersintel 
              | Maxnoderecursionamdx 
              | Maxnumworkgroupsamdx 
              | Maxworkdimintel 
              | Maxworkgroupsizeintel 
              | Namedbarriercountintel 
              | Namedmaximumregistersintel 
              | Noglobaloffsetintel 
              | Noncoherentcolorattachmentreadext 
              | Noncoherentdepthattachmentreadext 
              | Noncoherentstencilattachmentreadext 
              | Noncoherenttileattachmentreadqcom 
              | Numsimdworkitemsintel 
              | Originlowerleft 
              | Originupperleft 
              | Outputlinesext 
              | Outputlinestrip 
              | Outputpoints 
              | Outputprimitivesext 
              | Outputtrianglesext 
              | Outputtrianglestrip 
              | Outputvertices 
              | Pixelcenterinteger 
              | Pixelinterlockorderedext 
              | Pixelinterlockunorderedext 
              | Pointmode 
              | Postdepthcoverage 
              | Quadderivativeskhr 
              | Quads 
              | Registermapinterfaceintel 
              | Requirefullquadskhr 
              | Roundingmoderte 
              | Roundingmodertnintel 
              | Roundingmodertpintel 
              | Roundingmodertz 
              | Sampleinterlockorderedext 
              | Sampleinterlockunorderedext 
              | Schedulertargetfmaxmhzintel 
              | Shader64bitindexingext 
              | Shaderindexamdx 
              | Shadingrateinterlockorderedext 
              | Shadingrateinterlockunorderedext 
              | Sharedlocalmemorysizeintel 
              | Sharesinputwithamdx 
              | Signedzeroinfnanpreserve 
              | Spacingequal 
              | Spacingfractionaleven 
              | Spacingfractionalodd 
              | Staticnumworkgroupsamdx 
              | Stencilrefgreaterbackamd 
              | Stencilrefgreaterfrontamd 
              | Stencilreflessbackamd 
              | Stencilreflessfrontamd 
              | Stencilrefreplacingext 
              | Stencilrefunchangedbackamd 
              | Stencilrefunchangedfrontamd 
              | Streaminginterfaceintel 
              | Subgroupsize 
              | Subgroupsperworkgroup 
              | Subgroupsperworkgroupid 
              | Subgroupuniformcontrolflowkhr 
              | Tileshadingrateqcom 
              | Triangles 
              | Vectypehint 
              | Vertexorderccw 
              | Vertexordercw 
              | Xfb [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Coalescingamdx -> [5069l]
              | Contractionoff -> [31l]
              | Denormflushtozero -> [4460l]
              | Denormpreserve -> [4459l]
              | Depthgreater -> [14l]
              | Depthless -> [15l]
              | Depthreplacing -> [12l]
              | Depthunchanged -> [16l]
              | Derivativegrouplinearkhr -> [5290l]
              | Derivativegroupquadskhr -> [5289l]
              | Earlyandlatefragmenttestsamd -> [5017l]
              | Earlyfragmenttests -> [9l]
              | Finalizer -> [34l]
              | Floatingpointmodealtintel -> [5622l]
              | Floatingpointmodeieeeintel -> [5623l]
              | Fpfastmathdefault -> [6028l]
              | Initializer -> [33l]
              | Inputlines -> [20l]
              | Inputlinesadjacency -> [21l]
              | Inputpoints -> [19l]
              | Inputtrianglesadjacency -> [23l]
              | Invocations -> [0l]
              | Isapientryamdx -> [5070l]
              | Isolines -> [25l]
              | Localsize -> [17l]
              | Localsizehint -> [18l]
              | Localsizehintid -> [39l]
              | Localsizeid -> [38l]
              | Maximallyreconvergeskhr -> [6023l]
              | Maximumregistersidintel -> [6462l]
              | Maximumregistersintel -> [6461l]
              | Maxnoderecursionamdx -> [5071l]
              | Maxnumworkgroupsamdx -> [5077l]
              | Maxworkdimintel -> [5894l]
              | Maxworkgroupsizeintel -> [5893l]
              | Namedbarriercountintel -> [6417l]
              | Namedmaximumregistersintel -> [6463l]
              | Noglobaloffsetintel -> [5895l]
              | Noncoherentcolorattachmentreadext -> [4169l]
              | Noncoherentdepthattachmentreadext -> [4170l]
              | Noncoherentstencilattachmentreadext -> [4171l]
              | Noncoherenttileattachmentreadqcom -> [4489l]
              | Numsimdworkitemsintel -> [5896l]
              | Originlowerleft -> [8l]
              | Originupperleft -> [7l]
              | Outputlinesext -> [5269l]
              | Outputlinestrip -> [28l]
              | Outputpoints -> [27l]
              | Outputprimitivesext -> [5270l]
              | Outputtrianglesext -> [5298l]
              | Outputtrianglestrip -> [29l]
              | Outputvertices -> [26l]
              | Pixelcenterinteger -> [6l]
              | Pixelinterlockorderedext -> [5366l]
              | Pixelinterlockunorderedext -> [5367l]
              | Pointmode -> [10l]
              | Postdepthcoverage -> [4446l]
              | Quadderivativeskhr -> [5088l]
              | Quads -> [24l]
              | Registermapinterfaceintel -> [6160l]
              | Requirefullquadskhr -> [5089l]
              | Roundingmoderte -> [4462l]
              | Roundingmodertnintel -> [5621l]
              | Roundingmodertpintel -> [5620l]
              | Roundingmodertz -> [4463l]
              | Sampleinterlockorderedext -> [5368l]
              | Sampleinterlockunorderedext -> [5369l]
              | Schedulertargetfmaxmhzintel -> [5903l]
              | Shader64bitindexingext -> [5427l]
              | Shaderindexamdx -> [5073l]
              | Shadingrateinterlockorderedext -> [5370l]
              | Shadingrateinterlockunorderedext -> [5371l]
              | Sharedlocalmemorysizeintel -> [5618l]
              | Sharesinputwithamdx -> [5102l]
              | Signedzeroinfnanpreserve -> [4461l]
              | Spacingequal -> [1l]
              | Spacingfractionaleven -> [2l]
              | Spacingfractionalodd -> [3l]
              | Staticnumworkgroupsamdx -> [5072l]
              | Stencilrefgreaterbackamd -> [5083l]
              | Stencilrefgreaterfrontamd -> [5080l]
              | Stencilreflessbackamd -> [5084l]
              | Stencilreflessfrontamd -> [5081l]
              | Stencilrefreplacingext -> [5027l]
              | Stencilrefunchangedbackamd -> [5082l]
              | Stencilrefunchangedfrontamd -> [5079l]
              | Streaminginterfaceintel -> [6154l]
              | Subgroupsize -> [35l]
              | Subgroupsperworkgroup -> [36l]
              | Subgroupsperworkgroupid -> [37l]
              | Subgroupuniformcontrolflowkhr -> [4421l]
              | Tileshadingrateqcom -> [4490l]
              | Triangles -> [22l]
              | Vectypehint -> [30l]
              | Vertexorderccw -> [5l]
              | Vertexordercw -> [4l]
              | Xfb -> [11l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Localsize -> true
              | Localsizeid -> true
              | Coalescingamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Contractionoff ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Denormflushtozero ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Denormflushtozero] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Denormpreserve ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Denormpreserve] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Depthgreater ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Depthless ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Depthreplacing ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Depthunchanged ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Derivativegrouplinearkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Computederivativegrouplinearkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Derivativegroupquadskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Computederivativegroupquadskhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Earlyandlatefragmenttestsamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Earlyfragmenttests ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Finalizer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Floatingpointmodealtintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Roundtoinfinityintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Floatingpointmodeieeeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Roundtoinfinityintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fpfastmathdefault ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Floatcontrols2] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Initializer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Inputlines ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Inputlinesadjacency ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Inputpoints ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Inputtrianglesadjacency ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Invocations ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Isapientryamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Isolines ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Localsizehint ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Localsizehintid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Maximallyreconvergeskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Maximumregistersidintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Registerlimitsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maximumregistersintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Registerlimitsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxnoderecursionamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxnumworkgroupsamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxworkdimintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernelattributesintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxworkgroupsizeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernelattributesintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Namedbarriercountintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Namedmaximumregistersintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Registerlimitsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noglobaloffsetintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernelattributesintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noncoherentcolorattachmentreadext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileimagecolorreadaccessext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noncoherentdepthattachmentreadext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileimagedepthreadaccessext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noncoherentstencilattachmentreadext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileimagestencilreadaccessext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noncoherenttileattachmentreadqcom ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileshadingqcom] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Numsimdworkitemsintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgakernelattributesintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Originlowerleft ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Originupperleft ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Outputlinesext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Outputlinestrip ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Outputpoints ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry;
                           Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Outputprimitivesext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Outputtrianglesext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Outputtrianglestrip ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Outputvertices ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry;
                           Capability.Tessellation;
                           Capability.Meshshadingnv;
                           Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pixelcenterinteger ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Pixelinterlockorderedext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshaderpixelinterlockext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pixelinterlockunorderedext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshaderpixelinterlockext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pointmode ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Postdepthcoverage ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Samplemaskpostdepthcoverage] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Quadderivativeskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Quadcontrolkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Quads ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Registermapinterfaceintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgakernelattributesv2intel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Requirefullquadskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Quadcontrolkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Roundingmoderte ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Roundingmoderte] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Roundingmodertnintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Roundtoinfinityintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Roundingmodertpintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Roundtoinfinityintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Roundingmodertz ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Roundingmodertz] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sampleinterlockorderedext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadersampleinterlockext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sampleinterlockunorderedext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadersampleinterlockext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Schedulertargetfmaxmhzintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgakernelattributesintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shader64bitindexingext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader64bitindexingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shaderindexamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shadingrateinterlockorderedext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadershadingrateinterlockext]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shadingrateinterlockunorderedext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadershadingrateinterlockext]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sharedlocalmemorysizeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vectorcomputeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sharesinputwithamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Signedzeroinfnanpreserve ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Signedzeroinfnanpreserve] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Spacingequal ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Spacingfractionaleven ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Spacingfractionalodd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Staticnumworkgroupsamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stencilrefgreaterbackamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Stencilexportext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stencilrefgreaterfrontamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Stencilexportext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stencilreflessbackamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Stencilexportext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stencilreflessfrontamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Stencilexportext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stencilrefreplacingext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Stencilexportext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stencilrefunchangedbackamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Stencilexportext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Stencilrefunchangedfrontamd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Stencilexportext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Streaminginterfaceintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgakernelattributesintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupsize ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Subgroupdispatch] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupsperworkgroup ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Subgroupdispatch] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupsperworkgroupid ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Subgroupdispatch] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Subgroupuniformcontrolflowkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Tileshadingrateqcom ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileshadingqcom] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Triangles ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry; Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vectypehint ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Vertexorderccw ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vertexordercw ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Xfb ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Transformfeedback] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Coalescingamdx -> true
              | Contractionoff -> true
              | Depthgreater -> true
              | Depthless -> true
              | Depthreplacing -> true
              | Depthunchanged -> true
              | Earlyfragmenttests -> true
              | Finalizer -> true
              | Floatingpointmodealtintel -> true
              | Floatingpointmodeieeeintel -> true
              | Fpfastmathdefault -> true
              | Initializer -> true
              | Inputlines -> true
              | Inputlinesadjacency -> true
              | Inputpoints -> true
              | Inputtrianglesadjacency -> true
              | Invocations -> true
              | Isapientryamdx -> true
              | Isolines -> true
              | Localsize -> true
              | Localsizehint -> true
              | Localsizehintid -> true
              | Localsizeid -> true
              | Maximumregistersidintel -> true
              | Maximumregistersintel -> true
              | Maxnoderecursionamdx -> true
              | Maxnumworkgroupsamdx -> true
              | Namedbarriercountintel -> true
              | Namedmaximumregistersintel -> true
              | Noncoherentcolorattachmentreadext -> true
              | Noncoherentdepthattachmentreadext -> true
              | Noncoherentstencilattachmentreadext -> true
              | Noncoherenttileattachmentreadqcom -> true
              | Originlowerleft -> true
              | Originupperleft -> true
              | Outputlinestrip -> true
              | Outputpoints -> true
              | Outputtrianglestrip -> true
              | Outputvertices -> true
              | Pixelcenterinteger -> true
              | Pointmode -> true
              | Quadderivativeskhr -> true
              | Quads -> true
              | Registermapinterfaceintel -> true
              | Requirefullquadskhr -> true
              | Roundingmodertnintel -> true
              | Roundingmodertpintel -> true
              | Schedulertargetfmaxmhzintel -> true
              | Shader64bitindexingext -> true
              | Shaderindexamdx -> true
              | Sharedlocalmemorysizeintel -> true
              | Sharesinputwithamdx -> true
              | Spacingequal -> true
              | Spacingfractionaleven -> true
              | Spacingfractionalodd -> true
              | Staticnumworkgroupsamdx -> true
              | Streaminginterfaceintel -> true
              | Subgroupsize -> true
              | Subgroupsperworkgroup -> true
              | Subgroupsperworkgroupid -> true
              | Tileshadingrateqcom -> true
              | Triangles -> true
              | Vectypehint -> true
              | Vertexorderccw -> true
              | Vertexordercw -> true
              | Xfb -> true
              | Denormflushtozero ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Denormpreserve ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Derivativegrouplinearkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_compute_shader_derivatives;
                           Requirements.Extension.Spv_khr_compute_shader_derivatives]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Derivativegroupquadskhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_compute_shader_derivatives;
                           Requirements.Extension.Spv_khr_compute_shader_derivatives]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Earlyandlatefragmenttestsamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Maximallyreconvergeskhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_maximal_reconvergence]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Maxworkdimintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_kernel_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Maxworkgroupsizeintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_kernel_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Noglobaloffsetintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_kernel_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Numsimdworkitemsintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_kernel_attributes]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Outputlinesext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader;
                           Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Outputprimitivesext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader;
                           Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Outputtrianglesext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_mesh_shader;
                           Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Pixelinterlockorderedext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Pixelinterlockunorderedext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Postdepthcoverage ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_post_depth_coverage]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Roundingmoderte ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Roundingmodertz ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Sampleinterlockorderedext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Sampleinterlockunorderedext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shadingrateinterlockorderedext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Shadingrateinterlockunorderedext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Signedzeroinfnanpreserve ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_float_controls] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Stencilrefgreaterbackamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                           Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Stencilrefgreaterfrontamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                           Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Stencilreflessbackamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                           Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Stencilreflessfrontamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                           Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Stencilrefreplacingext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Stencilrefunchangedbackamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                           Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Stencilrefunchangedfrontamd ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                           Requirements.Extension.Spv_ext_shader_stencil_export]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Subgroupuniformcontrolflowkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_subgroup_uniform_control_flow]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Coalescingamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Contractionoff ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Denormflushtozero ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Denormpreserve ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Depthgreater ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Depthless ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Depthreplacing ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Depthunchanged ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Derivativegrouplinearkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Derivativegroupquadskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Earlyandlatefragmenttestsamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Earlyfragmenttests ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Finalizer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Floatingpointmodealtintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Floatingpointmodeieeeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fpfastmathdefault ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Initializer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inputlines ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inputlinesadjacency ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inputpoints ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inputtrianglesadjacency ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Invocations ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Isapientryamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Isolines ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Localsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Localsizehint ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Localsizehintid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_2) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Localsizeid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_2) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maximallyreconvergeskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maximumregistersidintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maximumregistersintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxnoderecursionamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxnumworkgroupsamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxworkdimintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxworkgroupsizeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Namedbarriercountintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Namedmaximumregistersintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noglobaloffsetintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noncoherentcolorattachmentreadext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noncoherentdepthattachmentreadext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noncoherentstencilattachmentreadext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noncoherenttileattachmentreadqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Numsimdworkitemsintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Originlowerleft ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Originupperleft ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outputlinesext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outputlinestrip ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outputpoints ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outputprimitivesext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outputtrianglesext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outputtrianglestrip ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outputvertices ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pixelcenterinteger ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pixelinterlockorderedext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pixelinterlockunorderedext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pointmode ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Postdepthcoverage ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Quadderivativeskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Quads ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Registermapinterfaceintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Requirefullquadskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Roundingmoderte ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Roundingmodertnintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Roundingmodertpintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Roundingmodertz ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampleinterlockorderedext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sampleinterlockunorderedext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Schedulertargetfmaxmhzintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shader64bitindexingext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderindexamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shadingrateinterlockorderedext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shadingrateinterlockunorderedext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sharedlocalmemorysizeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sharesinputwithamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedzeroinfnanpreserve ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Spacingequal ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Spacingfractionaleven ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Spacingfractionalodd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Staticnumworkgroupsamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stencilrefgreaterbackamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stencilrefgreaterfrontamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stencilreflessbackamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stencilreflessfrontamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stencilrefreplacingext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stencilrefunchangedbackamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Stencilrefunchangedfrontamd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Streaminginterfaceintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupsize ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupsperworkgroup ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupsperworkgroupid ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_2) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupuniformcontrolflowkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileshadingrateqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Triangles ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vectypehint ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vertexorderccw ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vertexordercw ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Xfb ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Executionmodel =
          struct
            type t =
              | Anyhitkhr 
              | Callablekhr 
              | Closesthitkhr 
              | Fragment 
              | Geometry 
              | Glcompute 
              | Intersectionkhr 
              | Kernel 
              | Meshext 
              | Meshnv 
              | Misskhr 
              | Raygenerationkhr 
              | Taskext 
              | Tasknv 
              | Tessellationcontrol 
              | Tessellationevaluation 
              | Vertex [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Anyhitkhr -> [5315l]
              | Callablekhr -> [5318l]
              | Closesthitkhr -> [5316l]
              | Fragment -> [4l]
              | Geometry -> [3l]
              | Glcompute -> [5l]
              | Intersectionkhr -> [5314l]
              | Kernel -> [6l]
              | Meshext -> [5365l]
              | Meshnv -> [5268l]
              | Misskhr -> [5317l]
              | Raygenerationkhr -> [5313l]
              | Taskext -> [5364l]
              | Tasknv -> [5267l]
              | Tessellationcontrol -> [1l]
              | Tessellationevaluation -> [2l]
              | Vertex -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Anyhitkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Callablekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Closesthitkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Fragment ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Geometry ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Geometry] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Glcompute ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Intersectionkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Kernel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Meshext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Meshnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Misskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Raygenerationkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Taskext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tasknv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tessellationcontrol ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tessellationevaluation ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tessellation] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vertex ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Anyhitkhr -> true
              | Callablekhr -> true
              | Closesthitkhr -> true
              | Fragment -> true
              | Geometry -> true
              | Glcompute -> true
              | Intersectionkhr -> true
              | Kernel -> true
              | Meshext -> true
              | Meshnv -> true
              | Misskhr -> true
              | Raygenerationkhr -> true
              | Taskext -> true
              | Tasknv -> true
              | Tessellationcontrol -> true
              | Tessellationevaluation -> true
              | Vertex -> true
            let satisfies_version t ~version =
              match t with
              | Anyhitkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Callablekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Closesthitkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fragment ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Geometry ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Glcompute ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Intersectionkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Kernel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Meshext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Meshnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Misskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raygenerationkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Taskext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tasknv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tessellationcontrol ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tessellationevaluation ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vertex ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Fpdenormmode =
          struct
            type t =
              | Flushtozero 
              | Preserve [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Flushtozero -> [1l] | Preserve -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Flushtozero ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Functionfloatcontrolintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Preserve ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Functionfloatcontrolintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with | Flushtozero -> true | Preserve -> true
            let satisfies_version t ~version =
              match t with
              | Flushtozero ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Preserve ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Fpencoding =
          struct
            type t =
              | Bfloat16khr 
              | Float8e4m3ext 
              | Float8e5m2ext [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Bfloat16khr -> [0l]
              | Float8e4m3ext -> [4214l]
              | Float8e5m2ext -> [4215l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Bfloat16khr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Bfloat16typekhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Float8e4m3ext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Float8ext] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Float8e5m2ext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Float8ext] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Bfloat16khr -> true
              | Float8e4m3ext -> true
              | Float8e5m2ext -> true
            let satisfies_version t ~version =
              match t with
              | Bfloat16khr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float8e4m3ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Float8e5m2ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Fpfastmathmode =
          struct
            type t =
              | Allowcontract 
              | Allowreassoc 
              | Allowrecip 
              | Allowtransform 
              | Fast 
              | None 
              | Notinf 
              | Notnan 
              | Nsz [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Allowcontract -> [65536l]
              | Allowreassoc -> [131072l]
              | Allowrecip -> [8l]
              | Allowtransform -> [262144l]
              | Fast -> [16l]
              | None -> [0l]
              | Notinf -> [2l]
              | Notnan -> [1l]
              | Nsz -> [4l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Allowrecip -> true
              | Fast -> true
              | None -> true
              | Notinf -> true
              | Notnan -> true
              | Nsz -> true
              | Allowcontract ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Floatcontrols2;
                           Capability.Fpfastmathmodeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Allowreassoc ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Floatcontrols2;
                           Capability.Fpfastmathmodeintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Allowtransform ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Floatcontrols2] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Allowcontract -> true
              | Allowreassoc -> true
              | Allowrecip -> true
              | Allowtransform -> true
              | Fast -> true
              | None -> true
              | Notinf -> true
              | Notnan -> true
              | Nsz -> true
            let satisfies_version t ~version =
              match t with
              | Allowcontract ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Allowreassoc ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Allowrecip ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Allowtransform ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Fast ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Notinf ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Notnan ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nsz ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Fpoperationmode =
          struct
            type t =
              | Alt 
              | Ieee [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Alt -> [1l] | Ieee -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Alt ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Functionfloatcontrolintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Ieee ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Functionfloatcontrolintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with | Alt -> true | Ieee -> true
            let satisfies_version t ~version =
              match t with
              | Alt ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Ieee ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Fproundingmode =
          struct
            type t =
              | Rte 
              | Rtn 
              | Rtp 
              | Rtz [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rte -> [0l]
              | Rtn -> [3l]
              | Rtp -> [2l]
              | Rtz -> [1l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Rte -> true
              | Rtn -> true
              | Rtp -> true
              | Rtz -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Rte -> true
              | Rtn -> true
              | Rtp -> true
              | Rtz -> true
            let satisfies_version t ~version =
              match t with
              | Rte ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rtn ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rtp ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rtz ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Fragmentshadingrate =
          struct
            type t =
              | Horizontal2pixels 
              | Horizontal4pixels 
              | Vertical2pixels 
              | Vertical4pixels [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Horizontal2pixels -> [4l]
              | Horizontal4pixels -> [8l]
              | Vertical2pixels -> [1l]
              | Vertical4pixels -> [2l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Horizontal2pixels ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadingratekhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Horizontal4pixels ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadingratekhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vertical2pixels ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadingratekhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Vertical4pixels ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fragmentshadingratekhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Horizontal2pixels -> true
              | Horizontal4pixels -> true
              | Vertical2pixels -> true
              | Vertical4pixels -> true
            let satisfies_version t ~version =
              match t with
              | Horizontal2pixels ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Horizontal4pixels ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vertical2pixels ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vertical4pixels ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Functioncontrol =
          struct
            type t =
              | Const 
              | Dontinline 
              | Inline 
              | None 
              | Optnoneext 
              | Pure [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Const -> [8l]
              | Dontinline -> [2l]
              | Inline -> [1l]
              | None -> [0l]
              | Optnoneext -> [65536l]
              | Pure -> [4l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Const -> true
              | Dontinline -> true
              | Inline -> true
              | None -> true
              | Pure -> true
              | Optnoneext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Optnoneext] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Const -> true
              | Dontinline -> true
              | Inline -> true
              | None -> true
              | Optnoneext -> true
              | Pure -> true
            let satisfies_version t ~version =
              match t with
              | Const ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dontinline ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inline ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Optnoneext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pure ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Functionparameterattribute =
          struct
            type t =
              | Byval 
              | Noalias 
              | Nocapture 
              | Noreadwrite 
              | Nowrite 
              | Runtimealignedaltera 
              | Sext 
              | Sret 
              | Zext [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Byval -> [2l]
              | Noalias -> [4l]
              | Nocapture -> [5l]
              | Noreadwrite -> [7l]
              | Nowrite -> [6l]
              | Runtimealignedaltera -> [5940l]
              | Sext -> [1l]
              | Sret -> [3l]
              | Zext -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Byval ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Noalias ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Nocapture ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Noreadwrite ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Nowrite ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Runtimealignedaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Runtimealignedattributealtera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Sret ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Zext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Byval -> true
              | Noalias -> true
              | Nocapture -> true
              | Noreadwrite -> true
              | Nowrite -> true
              | Runtimealignedaltera -> true
              | Sext -> true
              | Sret -> true
              | Zext -> true
            let satisfies_version t ~version =
              match t with
              | Byval ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noalias ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nocapture ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noreadwrite ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nowrite ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Runtimealignedaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sret ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Zext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Groupoperation =
          struct
            type t =
              | Clusteredreduce 
              | Exclusivescan 
              | Inclusivescan 
              | Partitionedexclusivescannv 
              | Partitionedinclusivescannv 
              | Partitionedreducenv 
              | Reduce [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Clusteredreduce -> [3l]
              | Exclusivescan -> [2l]
              | Inclusivescan -> [1l]
              | Partitionedexclusivescannv -> [8l]
              | Partitionedinclusivescannv -> [7l]
              | Partitionedreducenv -> [6l]
              | Reduce -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Clusteredreduce ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Groupnonuniformclustered] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Exclusivescan ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel;
                           Capability.Groupnonuniformarithmetic;
                           Capability.Groupnonuniformballot] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Inclusivescan ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel;
                           Capability.Groupnonuniformarithmetic;
                           Capability.Groupnonuniformballot] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Partitionedexclusivescannv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Groupnonuniformpartitionednv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Partitionedinclusivescannv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Groupnonuniformpartitionednv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Partitionedreducenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Groupnonuniformpartitionednv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Reduce ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel;
                           Capability.Groupnonuniformarithmetic;
                           Capability.Groupnonuniformballot] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Clusteredreduce -> true
              | Exclusivescan -> true
              | Inclusivescan -> true
              | Reduce -> true
              | Partitionedexclusivescannv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Partitionedinclusivescannv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Partitionedreducenv ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Clusteredreduce ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Exclusivescan ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Inclusivescan ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Partitionedexclusivescannv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Partitionedinclusivescannv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Partitionedreducenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Reduce ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Hostaccessqualifier =
          struct
            type t =
              | Noneintel 
              | Readintel 
              | Readwriteintel 
              | Writeintel [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Noneintel -> [0l]
              | Readintel -> [1l]
              | Readwriteintel -> [3l]
              | Writeintel -> [2l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Noneintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablehostaccessintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Readintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablehostaccessintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Readwriteintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablehostaccessintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Writeintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablehostaccessintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Noneintel -> true
              | Readintel -> true
              | Readwriteintel -> true
              | Writeintel -> true
            let satisfies_version t ~version =
              match t with
              | Noneintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Readintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Readwriteintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Writeintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Idmemorysemantics =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc =
              Some
                "Reference to an <id> representing a 32-bit integer that is a mask from the MemorySemantics operand kind"
            let value t = [t]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Idref =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc = Some "Reference to an <id>"
            let value t = [t]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Idresult =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc =
              Some
                "Definition of an <id> representing the result of the enclosing instruction"
            let value t = [t]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Idresulttype =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc =
              Some
                "Reference to an <id> representing the result's type of the enclosing instruction"
            let value t = [t]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Idscope =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc =
              Some
                "Reference to an <id> representing a 32-bit integer that is a mask from the Scope operand kind"
            let value t = [t]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Imagechanneldatatype =
          struct
            type t =
              | Float 
              | Halffloat 
              | Signedint16 
              | Signedint32 
              | Signedint8 
              | Snormint16 
              | Snormint8 
              | Unormint101010 
              | Unormint101010_2 
              | Unormint10x6ext 
              | Unormint12x4ext 
              | Unormint14x2ext 
              | Unormint16 
              | Unormint24 
              | Unormint2_101010ext 
              | Unormint8 
              | Unormshort555 
              | Unormshort565 
              | Unsignedint10x6ext 
              | Unsignedint12x4ext 
              | Unsignedint14x2ext 
              | Unsignedint16 
              | Unsignedint32 
              | Unsignedint8 
              | Unsignedintraw10ext 
              | Unsignedintraw12ext [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Float -> [14l]
              | Halffloat -> [13l]
              | Signedint16 -> [8l]
              | Signedint32 -> [9l]
              | Signedint8 -> [7l]
              | Snormint16 -> [1l]
              | Snormint8 -> [0l]
              | Unormint101010 -> [6l]
              | Unormint101010_2 -> [16l]
              | Unormint10x6ext -> [17l]
              | Unormint12x4ext -> [25l]
              | Unormint14x2ext -> [26l]
              | Unormint16 -> [3l]
              | Unormint24 -> [15l]
              | Unormint2_101010ext -> [21l]
              | Unormint8 -> [2l]
              | Unormshort555 -> [5l]
              | Unormshort565 -> [4l]
              | Unsignedint10x6ext -> [22l]
              | Unsignedint12x4ext -> [23l]
              | Unsignedint14x2ext -> [24l]
              | Unsignedint16 -> [11l]
              | Unsignedint32 -> [12l]
              | Unsignedint8 -> [10l]
              | Unsignedintraw10ext -> [19l]
              | Unsignedintraw12ext -> [20l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Float -> true
              | Halffloat -> true
              | Signedint16 -> true
              | Signedint32 -> true
              | Signedint8 -> true
              | Snormint16 -> true
              | Snormint8 -> true
              | Unormint101010 -> true
              | Unormint101010_2 -> true
              | Unormint10x6ext -> true
              | Unormint12x4ext -> true
              | Unormint14x2ext -> true
              | Unormint16 -> true
              | Unormint24 -> true
              | Unormint2_101010ext -> true
              | Unormint8 -> true
              | Unormshort555 -> true
              | Unormshort565 -> true
              | Unsignedint10x6ext -> true
              | Unsignedint12x4ext -> true
              | Unsignedint14x2ext -> true
              | Unsignedint16 -> true
              | Unsignedint32 -> true
              | Unsignedint8 -> true
              | Unsignedintraw10ext -> true
              | Unsignedintraw12ext -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Float -> true
              | Halffloat -> true
              | Signedint16 -> true
              | Signedint32 -> true
              | Signedint8 -> true
              | Snormint16 -> true
              | Snormint8 -> true
              | Unormint101010 -> true
              | Unormint101010_2 -> true
              | Unormint10x6ext -> true
              | Unormint12x4ext -> true
              | Unormint14x2ext -> true
              | Unormint16 -> true
              | Unormint24 -> true
              | Unormint2_101010ext -> true
              | Unormint8 -> true
              | Unormshort555 -> true
              | Unormshort565 -> true
              | Unsignedint10x6ext -> true
              | Unsignedint12x4ext -> true
              | Unsignedint14x2ext -> true
              | Unsignedint16 -> true
              | Unsignedint32 -> true
              | Unsignedint8 -> true
              | Unsignedintraw10ext -> true
              | Unsignedintraw12ext -> true
            let satisfies_version t ~version =
              match t with
              | Float ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Halffloat ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedint16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedint32 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signedint8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Snormint16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Snormint8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint101010 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint101010_2 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint10x6ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint12x4ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint14x2ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint24 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint2_101010ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormint8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormshort555 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unormshort565 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint10x6ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint12x4ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint14x2ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint32 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedint8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedintraw10ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unsignedintraw12ext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Imagechannelorder =
          struct
            type t =
              | A 
              | Abgr 
              | Argb 
              | Bgra 
              | Depth 
              | Depthstencil 
              | Intensity 
              | Luminance 
              | R 
              | Ra 
              | Rg 
              | Rgb 
              | Rgba 
              | Rgbx 
              | Rgx 
              | Rx 
              | Sbgra 
              | Srgb 
              | Srgba 
              | Srgbx [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | A -> [1l]
              | Abgr -> [19l]
              | Argb -> [7l]
              | Bgra -> [6l]
              | Depth -> [13l]
              | Depthstencil -> [14l]
              | Intensity -> [8l]
              | Luminance -> [9l]
              | R -> [0l]
              | Ra -> [3l]
              | Rg -> [2l]
              | Rgb -> [4l]
              | Rgba -> [5l]
              | Rgbx -> [12l]
              | Rgx -> [11l]
              | Rx -> [10l]
              | Sbgra -> [18l]
              | Srgb -> [15l]
              | Srgba -> [17l]
              | Srgbx -> [16l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | A -> true
              | Abgr -> true
              | Argb -> true
              | Bgra -> true
              | Depth -> true
              | Depthstencil -> true
              | Intensity -> true
              | Luminance -> true
              | R -> true
              | Ra -> true
              | Rg -> true
              | Rgb -> true
              | Rgba -> true
              | Rgbx -> true
              | Rgx -> true
              | Rx -> true
              | Sbgra -> true
              | Srgb -> true
              | Srgba -> true
              | Srgbx -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | A -> true
              | Abgr -> true
              | Argb -> true
              | Bgra -> true
              | Depth -> true
              | Depthstencil -> true
              | Intensity -> true
              | Luminance -> true
              | R -> true
              | Ra -> true
              | Rg -> true
              | Rgb -> true
              | Rgba -> true
              | Rgbx -> true
              | Rgx -> true
              | Rx -> true
              | Sbgra -> true
              | Srgb -> true
              | Srgba -> true
              | Srgbx -> true
            let satisfies_version t ~version =
              match t with
              | A ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Abgr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Argb ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Bgra ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Depth ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Depthstencil ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Intensity ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Luminance ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Ra ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgb ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgbx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sbgra ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Srgb ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Srgba ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Srgbx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Imageformat =
          struct
            type t =
              | R11fg11fb10f 
              | R16 
              | R16f 
              | R16i 
              | R16snorm 
              | R16ui 
              | R32f 
              | R32i 
              | R32ui 
              | R64i 
              | R64ui 
              | R8 
              | R8i 
              | R8snorm 
              | R8ui 
              | Rg16 
              | Rg16f 
              | Rg16i 
              | Rg16snorm 
              | Rg16ui 
              | Rg32f 
              | Rg32i 
              | Rg32ui 
              | Rg8 
              | Rg8i 
              | Rg8snorm 
              | Rg8ui 
              | Rgb10a2 
              | Rgb10a2ui 
              | Rgba16 
              | Rgba16f 
              | Rgba16i 
              | Rgba16snorm 
              | Rgba16ui 
              | Rgba32f 
              | Rgba32i 
              | Rgba32ui 
              | Rgba8 
              | Rgba8i 
              | Rgba8snorm 
              | Rgba8ui 
              | Unknown [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | R11fg11fb10f -> [8l]
              | R16 -> [14l]
              | R16f -> [9l]
              | R16i -> [28l]
              | R16snorm -> [19l]
              | R16ui -> [38l]
              | R32f -> [3l]
              | R32i -> [24l]
              | R32ui -> [33l]
              | R64i -> [41l]
              | R64ui -> [40l]
              | R8 -> [15l]
              | R8i -> [29l]
              | R8snorm -> [20l]
              | R8ui -> [39l]
              | Rg16 -> [12l]
              | Rg16f -> [7l]
              | Rg16i -> [26l]
              | Rg16snorm -> [17l]
              | Rg16ui -> [36l]
              | Rg32f -> [6l]
              | Rg32i -> [25l]
              | Rg32ui -> [35l]
              | Rg8 -> [13l]
              | Rg8i -> [27l]
              | Rg8snorm -> [18l]
              | Rg8ui -> [37l]
              | Rgb10a2 -> [11l]
              | Rgb10a2ui -> [34l]
              | Rgba16 -> [10l]
              | Rgba16f -> [2l]
              | Rgba16i -> [22l]
              | Rgba16snorm -> [16l]
              | Rgba16ui -> [31l]
              | Rgba32f -> [1l]
              | Rgba32i -> [21l]
              | Rgba32ui -> [30l]
              | Rgba8 -> [4l]
              | Rgba8i -> [23l]
              | Rgba8snorm -> [5l]
              | Rgba8ui -> [32l]
              | Unknown -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Unknown -> true
              | R11fg11fb10f ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R16 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R16f ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R16i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R16snorm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R16ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R32f ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | R32i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | R32ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | R64i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Int64imageext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R64ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Int64imageext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R8 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R8i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R8snorm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | R8ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg16 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg16f ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg16i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg16snorm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg16ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg32f ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg32i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg32ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg8 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg8i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg8snorm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rg8ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rgb10a2 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rgb10a2ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rgba16 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rgba16f ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba16i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba16snorm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Storageimageextendedformats] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rgba16ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba32f ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba32i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba32ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba8 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba8i ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba8snorm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rgba8ui ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | R11fg11fb10f -> true
              | R16 -> true
              | R16f -> true
              | R16i -> true
              | R16snorm -> true
              | R16ui -> true
              | R32f -> true
              | R32i -> true
              | R32ui -> true
              | R64i -> true
              | R64ui -> true
              | R8 -> true
              | R8i -> true
              | R8snorm -> true
              | R8ui -> true
              | Rg16 -> true
              | Rg16f -> true
              | Rg16i -> true
              | Rg16snorm -> true
              | Rg16ui -> true
              | Rg32f -> true
              | Rg32i -> true
              | Rg32ui -> true
              | Rg8 -> true
              | Rg8i -> true
              | Rg8snorm -> true
              | Rg8ui -> true
              | Rgb10a2 -> true
              | Rgb10a2ui -> true
              | Rgba16 -> true
              | Rgba16f -> true
              | Rgba16i -> true
              | Rgba16snorm -> true
              | Rgba16ui -> true
              | Rgba32f -> true
              | Rgba32i -> true
              | Rgba32ui -> true
              | Rgba8 -> true
              | Rgba8i -> true
              | Rgba8snorm -> true
              | Rgba8ui -> true
              | Unknown -> true
            let satisfies_version t ~version =
              match t with
              | R11fg11fb10f ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R16f ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R16i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R16snorm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R16ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R32f ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R32i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R32ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R64i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R64ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R8i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R8snorm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | R8ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg16f ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg16i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg16snorm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg16ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg32f ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg32i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg32ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg8i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg8snorm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rg8ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgb10a2 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgb10a2ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba16 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba16f ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba16i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba16snorm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba16ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba32f ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba32i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba32ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba8 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba8i ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba8snorm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rgba8ui ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unknown ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Imageoperands =
          struct
            type t =
              | Bias 
              | Constoffset 
              | Constoffsets 
              | Grad 
              | Lod 
              | Maketexelavailable 
              | Maketexelvisible 
              | Minlod 
              | None 
              | Nonprivatetexel 
              | Nontemporal 
              | Offset 
              | Offsets 
              | Sample 
              | Signextend 
              | Volatiletexel 
              | Zeroextend [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Bias -> [1l]
              | Constoffset -> [8l]
              | Constoffsets -> [32l]
              | Grad -> [4l]
              | Lod -> [2l]
              | Maketexelavailable -> [256l]
              | Maketexelvisible -> [512l]
              | Minlod -> [128l]
              | None -> [0l]
              | Nonprivatetexel -> [1024l]
              | Nontemporal -> [16384l]
              | Offset -> [16l]
              | Offsets -> [65536l]
              | Sample -> [64l]
              | Signextend -> [4096l]
              | Volatiletexel -> [2048l]
              | Zeroextend -> [8192l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Constoffset -> true
              | Grad -> true
              | Lod -> true
              | None -> true
              | Nontemporal -> true
              | Offsets -> true
              | Sample -> true
              | Signextend -> true
              | Zeroextend -> true
              | Bias ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Constoffsets ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Imagegatherextended] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maketexelavailable ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maketexelvisible ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Minlod ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Minlod] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Nonprivatetexel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Offset ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Imagegatherextended] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Volatiletexel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Bias -> true
              | Constoffset -> true
              | Constoffsets -> true
              | Grad -> true
              | Lod -> true
              | Minlod -> true
              | None -> true
              | Nontemporal -> true
              | Offset -> true
              | Offsets -> true
              | Sample -> true
              | Signextend -> true
              | Zeroextend -> true
              | Maketexelavailable ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Maketexelvisible ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Nonprivatetexel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Volatiletexel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Bias ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Constoffset ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Constoffsets ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Grad ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Lod ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maketexelavailable ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maketexelvisible ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Minlod ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonprivatetexel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nontemporal ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_6) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Offset ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Offsets ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sample ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Signextend ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Volatiletexel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Zeroextend ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Initializationmodequalifier =
          struct
            type t =
              | Initondevicereprogramaltera 
              | Initondeviceresetaltera [@@deriving
                                          compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Initondevicereprogramaltera -> [0l]
              | Initondeviceresetaltera -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Initondevicereprogramaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablefpgadecorationsaltera]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Initondeviceresetaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Globalvariablefpgadecorationsaltera]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Initondevicereprogramaltera -> true
              | Initondeviceresetaltera -> true
            let satisfies_version t ~version =
              match t with
              | Initondevicereprogramaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Initondeviceresetaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Kernelenqueueflags =
          struct
            type t =
              | Nowait 
              | Waitkernel 
              | Waitworkgroup [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Nowait -> [0l]
              | Waitkernel -> [1l]
              | Waitworkgroup -> [2l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Nowait ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Waitkernel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Waitworkgroup ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Nowait -> true
              | Waitkernel -> true
              | Waitworkgroup -> true
            let satisfies_version t ~version =
              match t with
              | Nowait ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Waitkernel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Waitworkgroup ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Kernelprofilinginfo =
          struct
            type t =
              | Cmdexectime 
              | None [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value = function | Cmdexectime -> [1l] | None -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | None -> true
              | Cmdexectime ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with | Cmdexectime -> true | None -> true
            let satisfies_version t ~version =
              match t with
              | Cmdexectime ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Linkagetype =
          struct
            type t =
              | Export 
              | Import 
              | Linkonceodr [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Export -> [0l]
              | Import -> [1l]
              | Linkonceodr -> [2l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Export ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Linkage] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Import ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Linkage] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Linkonceodr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Linkage] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Export -> true
              | Import -> true
              | Linkonceodr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_linkonce_odr] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Export ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Import ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Linkonceodr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Literalcontextdependentnumber =
          struct
            type t =
              | I32 of int32 
              | I64 of int64 [@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc =
              Some
                "A literal number whose size and format are determined by a previous operand in the enclosing instruction"
            let value =
              function
              | I32 int32 -> [int32]
              | I64 int64 ->
                  let low = Int64.to_int32_trunc int64 in
                  let high =
                    Int64.to_int32_trunc (Int64.shift_right_logical int64 32) in
                  [low; high]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Literalextinstinteger =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc =
              Some
                "A 32-bit unsigned integer indicating which instruction to use and determining the layout of following operands (for OpExtInst)"
            let value t = [t]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Literalfloat =
          struct
            type t =
              | F32 of float 
              | F64 of float [@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc = Some "A float consuming one word"
            let value =
              function
              | F32 float -> [Int32.bits_of_float float]
              | F64 float ->
                  let int64 = Int64.bits_of_float float in
                  let low = Int64.to_int32_trunc int64 in
                  let high =
                    Int64.to_int32_trunc (Int64.shift_right_logical int64 32) in
                  [low; high]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Literalinteger =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc = Some "An integer consuming one or more words"
            let value t = [t]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Literalspecconstantopinteger =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc =
              Some
                "An opcode indicating the operation to be performed and determining the layout of following operands (for OpSpecConstantOp)"
            let value t = [t]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Literalstring =
          struct
            type t = string[@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc =
              Some
                "A null-terminated stream of characters consuming an integral number of words"
            let value t =
              let int32_size = 4 in
              let input_size = String.length t in
              let output_size = (input_size / int32_size) + 1 in
              let bytes = Bytes.make (output_size * int32_size) '\000' in
              Bytes.blit ~src:(Bytes.of_string t) ~src_pos:0 ~dst:bytes
                ~dst_pos:0 ~len:input_size;
              List.init output_size
                ~f:(fun idx ->
                      EndianBytes.LittleEndian.get_int32 bytes
                        (idx * int32_size))
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Loadcachecontrol =
          struct
            type t =
              | Cachedintel 
              | Constcachedintel 
              | Invalidateafterreadintel 
              | Streamingintel 
              | Uncachedintel [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Cachedintel -> [1l]
              | Constcachedintel -> [4l]
              | Invalidateafterreadintel -> [3l]
              | Streamingintel -> [2l]
              | Uncachedintel -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Cachedintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Constcachedintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Invalidateafterreadintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Streamingintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uncachedintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Cachedintel -> true
              | Constcachedintel -> true
              | Invalidateafterreadintel -> true
              | Streamingintel -> true
              | Uncachedintel -> true
            let satisfies_version t ~version =
              match t with
              | Cachedintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Constcachedintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Invalidateafterreadintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Streamingintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uncachedintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Loopcontrol =
          struct
            type t =
              | Dependencyarrayaltera 
              | Dependencyinfinite 
              | Dependencylength 
              | Dontunroll 
              | Initiationintervalaltera 
              | Iterationmultiple 
              | Loopcoalescealtera 
              | Loopcountaltera 
              | Maxconcurrencyaltera 
              | Maxinterleavingaltera 
              | Maxiterations 
              | Maxreinvocationdelayaltera 
              | Miniterations 
              | Nofusionaltera 
              | None 
              | Partialcount 
              | Peelcount 
              | Pipelineenablealtera 
              | Speculatediterationsaltera 
              | Unroll [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Dependencyarrayaltera -> [262144l]
              | Dependencyinfinite -> [4l]
              | Dependencylength -> [8l]
              | Dontunroll -> [2l]
              | Initiationintervalaltera -> [65536l]
              | Iterationmultiple -> [64l]
              | Loopcoalescealtera -> [1048576l]
              | Loopcountaltera -> [16777216l]
              | Maxconcurrencyaltera -> [131072l]
              | Maxinterleavingaltera -> [2097152l]
              | Maxiterations -> [32l]
              | Maxreinvocationdelayaltera -> [33554432l]
              | Miniterations -> [16l]
              | Nofusionaltera -> [8388608l]
              | None -> [0l]
              | Partialcount -> [256l]
              | Peelcount -> [128l]
              | Pipelineenablealtera -> [524288l]
              | Speculatediterationsaltera -> [4194304l]
              | Unroll -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Dependencyinfinite -> true
              | Dependencylength -> true
              | Dontunroll -> true
              | Iterationmultiple -> true
              | Maxiterations -> true
              | Miniterations -> true
              | None -> true
              | Partialcount -> true
              | Peelcount -> true
              | Unroll -> true
              | Dependencyarrayaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Initiationintervalaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Loopcoalescealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Loopcountaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxconcurrencyaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxinterleavingaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Maxreinvocationdelayaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Nofusionaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pipelineenablealtera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Speculatediterationsaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Fpgaloopcontrolsaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Dependencyarrayaltera -> true
              | Dependencyinfinite -> true
              | Dependencylength -> true
              | Dontunroll -> true
              | Initiationintervalaltera -> true
              | Iterationmultiple -> true
              | Loopcoalescealtera -> true
              | Loopcountaltera -> true
              | Maxconcurrencyaltera -> true
              | Maxinterleavingaltera -> true
              | Maxiterations -> true
              | Maxreinvocationdelayaltera -> true
              | Miniterations -> true
              | Nofusionaltera -> true
              | None -> true
              | Partialcount -> true
              | Peelcount -> true
              | Pipelineenablealtera -> true
              | Speculatediterationsaltera -> true
              | Unroll -> true
            let satisfies_version t ~version =
              match t with
              | Dependencyarrayaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dependencyinfinite ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dependencylength ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_1) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Dontunroll ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Initiationintervalaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Iterationmultiple ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Loopcoalescealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Loopcountaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxconcurrencyaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxinterleavingaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxiterations ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Maxreinvocationdelayaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Miniterations ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nofusionaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Partialcount ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Peelcount ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pipelineenablealtera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Speculatediterationsaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unroll ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Matrixmultiplyaccumulateoperands =
          struct
            type t =
              | Matrixapackedbfloat16intel 
              | Matrixapackedfloat16intel 
              | Matrixapackedint4intel 
              | Matrixapackedint8intel 
              | Matrixasignedcomponentsintel 
              | Matrixatf32intel 
              | Matrixbpackedbfloat16intel 
              | Matrixbpackedfloat16intel 
              | Matrixbpackedint4intel 
              | Matrixbpackedint8intel 
              | Matrixbsignedcomponentsintel 
              | Matrixbtf32intel 
              | Matrixcbfloat16intel 
              | Matrixresultbfloat16intel 
              | None [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Matrixapackedbfloat16intel -> [4096l]
              | Matrixapackedfloat16intel -> [1024l]
              | Matrixapackedint4intel -> [64l]
              | Matrixapackedint8intel -> [16l]
              | Matrixasignedcomponentsintel -> [1l]
              | Matrixatf32intel -> [256l]
              | Matrixbpackedbfloat16intel -> [8192l]
              | Matrixbpackedfloat16intel -> [2048l]
              | Matrixbpackedint4intel -> [128l]
              | Matrixbpackedint8intel -> [32l]
              | Matrixbsignedcomponentsintel -> [2l]
              | Matrixbtf32intel -> [512l]
              | Matrixcbfloat16intel -> [4l]
              | Matrixresultbfloat16intel -> [8l]
              | None -> [0l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Matrixapackedbfloat16intel -> true
              | Matrixapackedfloat16intel -> true
              | Matrixapackedint4intel -> true
              | Matrixapackedint8intel -> true
              | Matrixasignedcomponentsintel -> true
              | Matrixatf32intel -> true
              | Matrixbpackedbfloat16intel -> true
              | Matrixbpackedfloat16intel -> true
              | Matrixbpackedint4intel -> true
              | Matrixbpackedint8intel -> true
              | Matrixbsignedcomponentsintel -> true
              | Matrixbtf32intel -> true
              | Matrixcbfloat16intel -> true
              | Matrixresultbfloat16intel -> true
              | None -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Matrixapackedbfloat16intel -> true
              | Matrixapackedfloat16intel -> true
              | Matrixapackedint4intel -> true
              | Matrixapackedint8intel -> true
              | Matrixasignedcomponentsintel -> true
              | Matrixatf32intel -> true
              | Matrixbpackedbfloat16intel -> true
              | Matrixbpackedfloat16intel -> true
              | Matrixbpackedint4intel -> true
              | Matrixbpackedint8intel -> true
              | Matrixbsignedcomponentsintel -> true
              | Matrixbtf32intel -> true
              | Matrixcbfloat16intel -> true
              | Matrixresultbfloat16intel -> true
              | None -> true
            let satisfies_version t ~version =
              match t with
              | Matrixapackedbfloat16intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixapackedfloat16intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixapackedint4intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixapackedint8intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixasignedcomponentsintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixatf32intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixbpackedbfloat16intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixbpackedfloat16intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixbpackedint4intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixbpackedint8intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixbsignedcomponentsintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixbtf32intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixcbfloat16intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Matrixresultbfloat16intel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Memoryaccess =
          struct
            type t =
              | Aliasscopeintelmask 
              | Aligned 
              | Makepointeravailable 
              | Makepointervisible 
              | Noaliasintelmask 
              | None 
              | Nonprivatepointer 
              | Nontemporal 
              | Volatile [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Aliasscopeintelmask -> [65536l]
              | Aligned -> [2l]
              | Makepointeravailable -> [8l]
              | Makepointervisible -> [16l]
              | Noaliasintelmask -> [131072l]
              | None -> [0l]
              | Nonprivatepointer -> [32l]
              | Nontemporal -> [4l]
              | Volatile -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Aligned -> true
              | None -> true
              | Nontemporal -> true
              | Volatile -> true
              | Aliasscopeintelmask ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Memoryaccessaliasingintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Makepointeravailable ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Makepointervisible ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noaliasintelmask ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Memoryaccessaliasingintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Nonprivatepointer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Aligned -> true
              | None -> true
              | Nontemporal -> true
              | Volatile -> true
              | Aliasscopeintelmask ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_memory_access_aliasing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Makepointeravailable ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Makepointervisible ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Noaliasintelmask ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_memory_access_aliasing]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Nonprivatepointer ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Aliasscopeintelmask ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Aligned ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Makepointeravailable ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Makepointervisible ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noaliasintelmask ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonprivatepointer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nontemporal ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Volatile ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Memorymodel =
          struct
            type t =
              | Glsl450 
              | Opencl 
              | Simple 
              | Vulkan [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Glsl450 -> [1l]
              | Opencl -> [2l]
              | Simple -> [0l]
              | Vulkan -> [3l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Glsl450 ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Opencl ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Kernel] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Simple ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Vulkan ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Glsl450 -> true
              | Opencl -> true
              | Simple -> true
              | Vulkan ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Glsl450 ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Opencl ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Simple ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Vulkan ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Memorysemantics =
          struct
            type t =
              | Acquire 
              | Acquirerelease 
              | Atomiccountermemory 
              | Crossworkgroupmemory 
              | Imagememory 
              | Makeavailable 
              | Makevisible 
              | Outputmemory 
              | Relaxed 
              | Release 
              | Sequentiallyconsistent 
              | Subgroupmemory 
              | Uniformmemory 
              | Volatile 
              | Workgroupmemory [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Acquire -> [2l]
              | Acquirerelease -> [8l]
              | Atomiccountermemory -> [1024l]
              | Crossworkgroupmemory -> [512l]
              | Imagememory -> [2048l]
              | Makeavailable -> [8192l]
              | Makevisible -> [16384l]
              | Outputmemory -> [4096l]
              | Relaxed -> [0l]
              | Release -> [4l]
              | Sequentiallyconsistent -> [16l]
              | Subgroupmemory -> [128l]
              | Uniformmemory -> [64l]
              | Volatile -> [32768l]
              | Workgroupmemory -> [256l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Acquire -> true
              | Acquirerelease -> true
              | Crossworkgroupmemory -> true
              | Imagememory -> true
              | Relaxed -> true
              | Release -> true
              | Sequentiallyconsistent -> true
              | Subgroupmemory -> true
              | Workgroupmemory -> true
              | Atomiccountermemory ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Atomicstorage] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Makeavailable ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Makevisible ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Outputmemory ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uniformmemory ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Volatile ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Acquire -> true
              | Acquirerelease -> true
              | Atomiccountermemory -> true
              | Crossworkgroupmemory -> true
              | Imagememory -> true
              | Relaxed -> true
              | Release -> true
              | Sequentiallyconsistent -> true
              | Subgroupmemory -> true
              | Uniformmemory -> true
              | Workgroupmemory -> true
              | Makeavailable ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Makevisible ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Outputmemory ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Volatile ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_vulkan_memory_model]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Acquire ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Acquirerelease ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Atomiccountermemory ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Crossworkgroupmemory ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Imagememory ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Makeavailable ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Makevisible ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outputmemory ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Relaxed ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Release ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sequentiallyconsistent ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroupmemory ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformmemory ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Volatile ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workgroupmemory ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Namedmaximumnumberofregisters =
          struct
            type t =
              | Autointel [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Autointel -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Autointel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Registerlimitsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with | Autointel -> true
            let satisfies_version t ~version =
              match t with
              | Autointel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Overflowmodes =
          struct
            type t =
              | Sat 
              | Sat_sym 
              | Sat_zero 
              | Wrap [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Sat -> [1l]
              | Sat_sym -> [3l]
              | Sat_zero -> [2l]
              | Wrap -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Sat ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sat_sym ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Sat_zero ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Wrap ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Sat -> true
              | Sat_sym -> true
              | Sat_zero -> true
              | Wrap -> true
            let satisfies_version t ~version =
              match t with
              | Sat ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sat_sym ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sat_zero ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Wrap ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Packedvectorformat =
          struct
            type t =
              | Packedvectorformat4x8bit [@@deriving
                                           compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Packedvectorformat4x8bit -> [0l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with | Packedvectorformat4x8bit -> true
            let satisfies_extensions t ~extensions =
              match t with
              | Packedvectorformat4x8bit ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_integer_dot_product]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Packedvectorformat4x8bit ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_6) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Pairidrefidref =
          struct
            type t = (Idref.t * Idref.t)[@@deriving compare, sexp_of]
            let category = Category.Composite
            let doc = None
            let value (idref0, idref1) = [idref0; idref1]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Pairidrefliteralinteger =
          struct
            type t = (Idref.t * Literalinteger.t)[@@deriving
                                                   compare, sexp_of]
            let category = Category.Composite
            let doc = None
            let value (idref0, literalinteger1) = [idref0; literalinteger1]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Pairliteralintegeridref =
          struct
            type t = (Literalinteger.t * Idref.t)[@@deriving
                                                   compare, sexp_of]
            let category = Category.Composite
            let doc = None
            let value (literalinteger0, idref1) = [literalinteger0; idref1]
            let satisfies_capabilities (_ : t) ~capabilities:_ = true
            let satisfies_extensions (_ : t) ~extensions:_ = true
            let satisfies_version (_ : t) ~version:_ = true
          end
        module Quantizationmodes =
          struct
            type t =
              | Rnd 
              | Rnd_conv 
              | Rnd_conv_odd 
              | Rnd_inf 
              | Rnd_min_inf 
              | Rnd_zero 
              | Trn 
              | Trn_zero [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rnd -> [2l]
              | Rnd_conv -> [6l]
              | Rnd_conv_odd -> [7l]
              | Rnd_inf -> [4l]
              | Rnd_min_inf -> [5l]
              | Rnd_zero -> [3l]
              | Trn -> [0l]
              | Trn_zero -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Rnd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rnd_conv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rnd_conv_odd ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rnd_inf ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rnd_min_inf ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Rnd_zero ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Trn ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Trn_zero ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Arbitraryprecisionfixedpointaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Rnd -> true
              | Rnd_conv -> true
              | Rnd_conv_odd -> true
              | Rnd_inf -> true
              | Rnd_min_inf -> true
              | Rnd_zero -> true
              | Trn -> true
              | Trn_zero -> true
            let satisfies_version t ~version =
              match t with
              | Rnd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rnd_conv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rnd_conv_odd ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rnd_inf ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rnd_min_inf ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rnd_zero ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Trn ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Trn_zero ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Rawaccesschainoperands =
          struct
            type t =
              | None 
              | Robustnesspercomponentnv 
              | Robustnessperelementnv [@@deriving
                                         compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | None -> [0l]
              | Robustnesspercomponentnv -> [1l]
              | Robustnessperelementnv -> [2l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | None -> true
              | Robustnesspercomponentnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rawaccesschainsnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Robustnessperelementnv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rawaccesschainsnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | None -> true
              | Robustnesspercomponentnv -> true
              | Robustnessperelementnv -> true
            let satisfies_version t ~version =
              match t with
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Robustnesspercomponentnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Robustnessperelementnv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Rayflags =
          struct
            type t =
              | Cullbackfacingtriangleskhr 
              | Cullfrontfacingtriangleskhr 
              | Cullnoopaquekhr 
              | Cullopaquekhr 
              | Forceopacitymicromap2stateext 
              | Nonekhr 
              | Noopaquekhr 
              | Opaquekhr 
              | Skipaabbskhr 
              | Skipclosesthitshaderkhr 
              | Skiptriangleskhr 
              | Terminateonfirsthitkhr [@@deriving
                                         compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Cullbackfacingtriangleskhr -> [16l]
              | Cullfrontfacingtriangleskhr -> [32l]
              | Cullnoopaquekhr -> [128l]
              | Cullopaquekhr -> [64l]
              | Forceopacitymicromap2stateext -> [1024l]
              | Nonekhr -> [0l]
              | Noopaquekhr -> [2l]
              | Opaquekhr -> [1l]
              | Skipaabbskhr -> [512l]
              | Skipclosesthitshaderkhr -> [8l]
              | Skiptriangleskhr -> [256l]
              | Terminateonfirsthitkhr -> [4l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Cullbackfacingtriangleskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cullfrontfacingtriangleskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cullnoopaquekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Cullopaquekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Forceopacitymicromap2stateext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingopacitymicromapext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Nonekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Noopaquekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Opaquekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Skipaabbskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytraversalprimitivecullingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Skipclosesthitshaderkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Skiptriangleskhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytraversalprimitivecullingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Terminateonfirsthitkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr; Capability.Raytracingkhr]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Cullbackfacingtriangleskhr -> true
              | Cullfrontfacingtriangleskhr -> true
              | Cullnoopaquekhr -> true
              | Cullopaquekhr -> true
              | Forceopacitymicromap2stateext -> true
              | Nonekhr -> true
              | Noopaquekhr -> true
              | Opaquekhr -> true
              | Skipaabbskhr -> true
              | Skipclosesthitshaderkhr -> true
              | Skiptriangleskhr -> true
              | Terminateonfirsthitkhr -> true
            let satisfies_version t ~version =
              match t with
              | Cullbackfacingtriangleskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cullfrontfacingtriangleskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cullnoopaquekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Cullopaquekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Forceopacitymicromap2stateext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Noopaquekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Opaquekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Skipaabbskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Skipclosesthitshaderkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Skiptriangleskhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Terminateonfirsthitkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Rayquerycandidateintersectiontype =
          struct
            type t =
              | Rayquerycandidateintersectionaabbkhr 
              | Rayquerycandidateintersectiontrianglekhr [@@deriving
                                                           compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rayquerycandidateintersectionaabbkhr -> [1l]
              | Rayquerycandidateintersectiontrianglekhr -> [0l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Rayquerycandidateintersectionaabbkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rayquerycandidateintersectiontrianglekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Rayquerycandidateintersectionaabbkhr -> true
              | Rayquerycandidateintersectiontrianglekhr -> true
            let satisfies_version t ~version =
              match t with
              | Rayquerycandidateintersectionaabbkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rayquerycandidateintersectiontrianglekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Rayquerycommittedintersectiontype =
          struct
            type t =
              | Rayquerycommittedintersectiongeneratedkhr 
              | Rayquerycommittedintersectionnonekhr 
              | Rayquerycommittedintersectiontrianglekhr [@@deriving
                                                           compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rayquerycommittedintersectiongeneratedkhr -> [2l]
              | Rayquerycommittedintersectionnonekhr -> [0l]
              | Rayquerycommittedintersectiontrianglekhr -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Rayquerycommittedintersectiongeneratedkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rayquerycommittedintersectionnonekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rayquerycommittedintersectiontrianglekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Rayquerycommittedintersectiongeneratedkhr -> true
              | Rayquerycommittedintersectionnonekhr -> true
              | Rayquerycommittedintersectiontrianglekhr -> true
            let satisfies_version t ~version =
              match t with
              | Rayquerycommittedintersectiongeneratedkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rayquerycommittedintersectionnonekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rayquerycommittedintersectiontrianglekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Rayqueryintersection =
          struct
            type t =
              | Rayquerycandidateintersectionkhr 
              | Rayquerycommittedintersectionkhr [@@deriving
                                                   compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rayquerycandidateintersectionkhr -> [0l]
              | Rayquerycommittedintersectionkhr -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Rayquerycandidateintersectionkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Rayquerycommittedintersectionkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Rayquerykhr] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Rayquerycandidateintersectionkhr -> true
              | Rayquerycommittedintersectionkhr -> true
            let satisfies_version t ~version =
              match t with
              | Rayquerycandidateintersectionkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rayquerycommittedintersectionkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Sampleraddressingmode =
          struct
            type t =
              | Clamp 
              | Clamptoedge 
              | None 
              | Repeat 
              | Repeatmirrored [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Clamp -> [2l]
              | Clamptoedge -> [1l]
              | None -> [0l]
              | Repeat -> [3l]
              | Repeatmirrored -> [4l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Clamp -> true
              | Clamptoedge -> true
              | None -> true
              | Repeat -> true
              | Repeatmirrored -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Clamp -> true
              | Clamptoedge -> true
              | None -> true
              | Repeat -> true
              | Repeatmirrored -> true
            let satisfies_version t ~version =
              match t with
              | Clamp ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Clamptoedge ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Repeat ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Repeatmirrored ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Samplerfiltermode =
          struct
            type t =
              | Linear 
              | Nearest [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Linear -> [1l] | Nearest -> [0l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with | Linear -> true | Nearest -> true
            let satisfies_extensions t ~extensions:_ =
              match t with | Linear -> true | Nearest -> true
            let satisfies_version t ~version =
              match t with
              | Linear ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nearest ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Scope =
          struct
            type t =
              | Crossdevice 
              | Device 
              | Invocation 
              | Queuefamily 
              | Shadercallkhr 
              | Subgroup 
              | Workgroup [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Crossdevice -> [0l]
              | Device -> [1l]
              | Invocation -> [4l]
              | Queuefamily -> [5l]
              | Shadercallkhr -> [6l]
              | Subgroup -> [3l]
              | Workgroup -> [2l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Crossdevice -> true
              | Device -> true
              | Invocation -> true
              | Subgroup -> true
              | Workgroup -> true
              | Queuefamily ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Vulkanmemorymodel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shadercallkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Crossdevice -> true
              | Device -> true
              | Invocation -> true
              | Queuefamily -> true
              | Shadercallkhr -> true
              | Subgroup -> true
              | Workgroup -> true
            let satisfies_version t ~version =
              match t with
              | Crossdevice ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Device ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Invocation ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Queuefamily ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shadercallkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Subgroup ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workgroup ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Selectioncontrol =
          struct
            type t =
              | Dontflatten 
              | Flatten 
              | None [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function | Dontflatten -> [2l] | Flatten -> [1l] | None -> [0l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Dontflatten -> true
              | Flatten -> true
              | None -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Dontflatten -> true
              | Flatten -> true
              | None -> true
            let satisfies_version t ~version =
              match t with
              | Dontflatten ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Flatten ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Sourcelanguage =
          struct
            type t =
              | Cpp_for_opencl 
              | Essl 
              | Glsl 
              | Hero_c 
              | Hlsl 
              | Nzsl 
              | Opencl_c 
              | Opencl_cpp 
              | Rust 
              | Slang 
              | Sycl 
              | Unknown 
              | Wgsl 
              | Zig [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Cpp_for_opencl -> [6l]
              | Essl -> [1l]
              | Glsl -> [2l]
              | Hero_c -> [8l]
              | Hlsl -> [5l]
              | Nzsl -> [9l]
              | Opencl_c -> [3l]
              | Opencl_cpp -> [4l]
              | Rust -> [13l]
              | Slang -> [11l]
              | Sycl -> [7l]
              | Unknown -> [0l]
              | Wgsl -> [10l]
              | Zig -> [12l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Cpp_for_opencl -> true
              | Essl -> true
              | Glsl -> true
              | Hero_c -> true
              | Hlsl -> true
              | Nzsl -> true
              | Opencl_c -> true
              | Opencl_cpp -> true
              | Rust -> true
              | Slang -> true
              | Sycl -> true
              | Unknown -> true
              | Wgsl -> true
              | Zig -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Cpp_for_opencl -> true
              | Essl -> true
              | Glsl -> true
              | Hero_c -> true
              | Hlsl -> true
              | Nzsl -> true
              | Opencl_c -> true
              | Opencl_cpp -> true
              | Rust -> true
              | Slang -> true
              | Sycl -> true
              | Unknown -> true
              | Wgsl -> true
              | Zig -> true
            let satisfies_version t ~version =
              match t with
              | Cpp_for_opencl ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Essl ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Glsl ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hero_c ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hlsl ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nzsl ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Opencl_c ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Opencl_cpp ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Rust ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Slang ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Sycl ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Unknown ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Wgsl ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Zig ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Storageclass =
          struct
            type t =
              | Atomiccounter 
              | Callabledatakhr 
              | Codesectionintel 
              | Crossworkgroup 
              | Deviceonlyaltera 
              | Function 
              | Generic 
              | Hitattributekhr 
              | Hitobjectattributeext 
              | Hitobjectattributenv 
              | Hostonlyaltera 
              | Image 
              | Incomingcallabledatakhr 
              | Incomingraypayloadkhr 
              | Input 
              | Nodepayloadamdx 
              | Output 
              | Physicalstoragebuffer 
              | Private 
              | Pushconstant 
              | Raypayloadkhr 
              | Shaderrecordbufferkhr 
              | Storagebuffer 
              | Taskpayloadworkgroupext 
              | Tileattachmentqcom 
              | Tileimageext 
              | Uniform 
              | Uniformconstant 
              | Workgroup [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Atomiccounter -> [10l]
              | Callabledatakhr -> [5328l]
              | Codesectionintel -> [5605l]
              | Crossworkgroup -> [5l]
              | Deviceonlyaltera -> [5936l]
              | Function -> [7l]
              | Generic -> [8l]
              | Hitattributekhr -> [5339l]
              | Hitobjectattributeext -> [5411l]
              | Hitobjectattributenv -> [5385l]
              | Hostonlyaltera -> [5937l]
              | Image -> [11l]
              | Incomingcallabledatakhr -> [5329l]
              | Incomingraypayloadkhr -> [5342l]
              | Input -> [1l]
              | Nodepayloadamdx -> [5068l]
              | Output -> [3l]
              | Physicalstoragebuffer -> [5349l]
              | Private -> [6l]
              | Pushconstant -> [9l]
              | Raypayloadkhr -> [5338l]
              | Shaderrecordbufferkhr -> [5343l]
              | Storagebuffer -> [12l]
              | Taskpayloadworkgroupext -> [5402l]
              | Tileattachmentqcom -> [4491l]
              | Tileimageext -> [4172l]
              | Uniform -> [2l]
              | Uniformconstant -> [0l]
              | Workgroup -> [4l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Crossworkgroup -> true
              | Function -> true
              | Image -> true
              | Input -> true
              | Uniformconstant -> true
              | Workgroup -> true
              | Atomiccounter ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Atomicstorage] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Callabledatakhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Codesectionintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Functionpointersintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Deviceonlyaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Usmstorageclassesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Generic ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Genericpointer] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitattributekhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitobjectattributeext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderinvocationreorderext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hitobjectattributenv ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderinvocationreordernv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Hostonlyaltera ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Usmstorageclassesaltera] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Incomingcallabledatakhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Incomingraypayloadkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Nodepayloadamdx ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shaderenqueueamdx] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Output ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Physicalstoragebuffer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Physicalstoragebufferaddresses] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Private ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader; Capability.Vectorcomputeintel]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Pushconstant ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Raypayloadkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Shaderrecordbufferkhr ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Raytracingnv;
                           Capability.Raytracingkhr] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Storagebuffer ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Taskpayloadworkgroupext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Meshshadingext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tileattachmentqcom ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileshadingqcom] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tileimageext ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tileimagecolorreadaccessext] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uniform ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Shader] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions =
              match t with
              | Atomiccounter -> true
              | Crossworkgroup -> true
              | Deviceonlyaltera -> true
              | Function -> true
              | Generic -> true
              | Hitobjectattributeext -> true
              | Hitobjectattributenv -> true
              | Hostonlyaltera -> true
              | Image -> true
              | Input -> true
              | Nodepayloadamdx -> true
              | Output -> true
              | Private -> true
              | Pushconstant -> true
              | Tileattachmentqcom -> true
              | Tileimageext -> true
              | Uniform -> true
              | Uniformconstant -> true
              | Workgroup -> true
              | Callabledatakhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Codesectionintel ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_intel_function_pointers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Hitattributekhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Incomingcallabledatakhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Incomingraypayloadkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Physicalstoragebuffer ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_physical_storage_buffer;
                           Requirements.Extension.Spv_khr_physical_storage_buffer]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Raypayloadkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Shaderrecordbufferkhr ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_nv_ray_tracing;
                           Requirements.Extension.Spv_khr_ray_tracing] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
              | Storagebuffer ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_khr_storage_buffer_storage_class;
                           Requirements.Extension.Spv_khr_variable_pointers]
                             |> Requirements.Extension.Set.of_list)
                          extensions)] ~f:(fun fn -> fn ~extensions)
              | Taskpayloadworkgroupext ->
                  List.for_all
                    [(fun ~extensions ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Requirements.Extension.Spv_ext_mesh_shader] |>
                             Requirements.Extension.Set.of_list) extensions)]
                    ~f:(fun fn -> fn ~extensions)
            let satisfies_version t ~version =
              match t with
              | Atomiccounter ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Callabledatakhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Codesectionintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Crossworkgroup ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Deviceonlyaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Function ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Generic ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitattributekhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitobjectattributeext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hitobjectattributenv ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Hostonlyaltera ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Image ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Incomingcallabledatakhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Incomingraypayloadkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Input ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nodepayloadamdx ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Output ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Physicalstoragebuffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_5) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Private ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Pushconstant ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Raypayloadkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Shaderrecordbufferkhr ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Storagebuffer ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_3) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Taskpayloadworkgroupext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_4) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileattachmentqcom ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tileimageext ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniform ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uniformconstant ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Workgroup ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:(Some V1_0) ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Storecachecontrol =
          struct
            type t =
              | Streamingintel 
              | Uncachedintel 
              | Writebackintel 
              | Writethroughintel [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Streamingintel -> [3l]
              | Uncachedintel -> [0l]
              | Writebackintel -> [2l]
              | Writethroughintel -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Streamingintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Uncachedintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Writebackintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Writethroughintel ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cachecontrolsintel] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Streamingintel -> true
              | Uncachedintel -> true
              | Writebackintel -> true
              | Writethroughintel -> true
            let satisfies_version t ~version =
              match t with
              | Streamingintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Uncachedintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Writebackintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Writethroughintel ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Tensoraddressingoperands =
          struct
            type t =
              | Decodefunc 
              | None 
              | Tensorview [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Decodefunc -> [2l]
              | None -> [0l]
              | Tensorview -> [1l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | None -> true
              | Decodefunc ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cooperativematrixblockloadsnv] |>
                             Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
              | Tensorview ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Cooperativematrixtensoraddressingnv]
                             |> Capability.Set.of_list) capabilities)]
                    ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Decodefunc -> true
              | None -> true
              | Tensorview -> true
            let satisfies_version t ~version =
              match t with
              | Decodefunc ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | None ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Tensorview ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Tensorclampmode =
          struct
            type t =
              | Clamptoedge 
              | Constant 
              | Repeat 
              | Repeatmirrored 
              | Undefined [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Clamptoedge -> [2l]
              | Constant -> [1l]
              | Repeat -> [3l]
              | Repeatmirrored -> [4l]
              | Undefined -> [0l]
            let satisfies_capabilities t ~capabilities:_ =
              match t with
              | Clamptoedge -> true
              | Constant -> true
              | Repeat -> true
              | Repeatmirrored -> true
              | Undefined -> true
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Clamptoedge -> true
              | Constant -> true
              | Repeat -> true
              | Repeatmirrored -> true
              | Undefined -> true
            let satisfies_version t ~version =
              match t with
              | Clamptoedge ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Constant ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Repeat ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Repeatmirrored ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Undefined ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
        module Tensoroperands =
          struct
            type t =
              | Makeelementavailablearm 
              | Makeelementvisiblearm 
              | Nonearm 
              | Nonprivateelementarm 
              | Nontemporalarm 
              | Outofboundsvaluearm [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Makeelementavailablearm -> [4l]
              | Makeelementvisiblearm -> [8l]
              | Nonearm -> [0l]
              | Nonprivateelementarm -> [16l]
              | Nontemporalarm -> [1l]
              | Outofboundsvaluearm -> [2l]
            let satisfies_capabilities t ~capabilities =
              match t with
              | Makeelementavailablearm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tensorsarm] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Makeelementvisiblearm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tensorsarm] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Nonearm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tensorsarm] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Nonprivateelementarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tensorsarm] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Nontemporalarm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tensorsarm] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
              | Outofboundsvaluearm ->
                  List.for_all
                    [(fun ~capabilities ->
                        (fun set1 set2 ->
                           not (Core.Set.are_disjoint set1 set2))
                          ([Capability.Tensorsarm] |> Capability.Set.of_list)
                          capabilities)] ~f:(fun fn -> fn ~capabilities)
            let satisfies_extensions t ~extensions:_ =
              match t with
              | Makeelementavailablearm -> true
              | Makeelementvisiblearm -> true
              | Nonearm -> true
              | Nonprivateelementarm -> true
              | Nontemporalarm -> true
              | Outofboundsvaluearm -> true
            let satisfies_version t ~version =
              match t with
              | Makeelementavailablearm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Makeelementvisiblearm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonearm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nonprivateelementarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Nontemporalarm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
              | Outofboundsvaluearm ->
                  List.for_all
                    [(fun ~version ->
                        Core.Set.mem
                          ((Requirements.Version.valid_versions
                              ~required:None ~last:None)
                             |> Requirements.Version.Set.of_list) version)]
                    ~f:(fun fn -> fn ~version)
          end
      end
  end
module Instruction =
  struct
    module Annotation =
      struct
        type t =
          | Opdecorate of
          {
          target: Operand_kind.Payload.Idref.t ;
          decoration: Operand_kind.Payload.Decoration.t } 
          | Opdecorateid of
          {
          target: Operand_kind.Payload.Idref.t ;
          decoration: Operand_kind.Payload.Decoration.t } 
          | Opdecoratestring of
          {
          target: Operand_kind.Payload.Idref.t ;
          decoration: Operand_kind.Payload.Decoration.t } 
          | Opdecorationgroup of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opgroupdecorate of
          {
          decorationgroup: Operand_kind.Payload.Idref.t ;
          targets: Operand_kind.Payload.Idref.t list } 
          | Opgroupmemberdecorate of
          {
          decorationgroup: Operand_kind.Payload.Idref.t ;
          targets: Operand_kind.Payload.Pairidrefliteralinteger.t list } 
          | Opmemberdecorate of
          {
          structuretype: Operand_kind.Payload.Idref.t ;
          member: Operand_kind.Payload.Literalinteger.t ;
          decoration: Operand_kind.Payload.Decoration.t } 
          | Opmemberdecoratestring of
          {
          structtype: Operand_kind.Payload.Idref.t ;
          member: Operand_kind.Payload.Literalinteger.t ;
          decoration: Operand_kind.Payload.Decoration.t } [@@deriving
                                                            compare, sexp_of]
        let provisional =
          function
          | Opdecorate _ -> false
          | Opdecorateid _ -> false
          | Opdecoratestring _ -> false
          | Opdecorationgroup _ -> false
          | Opgroupdecorate _ -> false
          | Opgroupmemberdecorate _ -> false
          | Opmemberdecorate _ -> false
          | Opmemberdecoratestring _ -> false
        let value =
          function
          | Opdecorate t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Decoration.value t.decoration]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 71l in
              heading :: payload
          | Opdecorateid t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Decoration.value t.decoration]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 332l in
              heading :: payload
          | Opdecoratestring t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Decoration.value t.decoration]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5632l in
              heading :: payload
          | Opdecorationgroup t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 73l in
              heading :: payload
          | Opgroupdecorate t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.decorationgroup];
                 List.map t.targets ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 74l in
              heading :: payload
          | Opgroupmemberdecorate t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.decorationgroup];
                 List.map t.targets
                   ~f:Operand_kind.Payload.Pairidrefliteralinteger.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 75l in
              heading :: payload
          | Opmemberdecorate t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.structuretype];
                 [Operand_kind.Payload.Literalinteger.value t.member];
                 [Operand_kind.Payload.Decoration.value t.decoration]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 72l in
              heading :: payload
          | Opmemberdecoratestring t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.structtype];
                 [Operand_kind.Payload.Literalinteger.value t.member];
                 [Operand_kind.Payload.Decoration.value t.decoration]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5633l in
              heading :: payload
        let satisfies_capabilities t ~capabilities:_ =
          match t with
          | Opdecorate _ -> true
          | Opdecorateid _ -> true
          | Opdecoratestring _ -> true
          | Opdecorationgroup _ -> true
          | Opgroupdecorate _ -> true
          | Opgroupmemberdecorate _ -> true
          | Opmemberdecorate _ -> true
          | Opmemberdecoratestring _ -> true
        let satisfies_extensions t ~extensions =
          match t with
          | Opdecorate _ -> true
          | Opdecorationgroup _ -> true
          | Opgroupdecorate _ -> true
          | Opgroupmemberdecorate _ -> true
          | Opmemberdecorate _ -> true
          | Opdecorateid t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_google_hlsl_functionality1]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.target];
                 [Operand_kind.Payload.Decoration.satisfies_extensions
                    t.decoration]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opdecoratestring t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_google_decorate_string;
                       Requirements.Extension.Spv_google_hlsl_functionality1]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.target];
                 [Operand_kind.Payload.Decoration.satisfies_extensions
                    t.decoration]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opmemberdecoratestring t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_google_decorate_string;
                       Requirements.Extension.Spv_google_hlsl_functionality1]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions
                     t.structtype];
                 [Operand_kind.Payload.Literalinteger.satisfies_extensions
                    t.member];
                 [Operand_kind.Payload.Decoration.satisfies_extensions
                    t.decoration]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opdecorate t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Decoration.satisfies_version
                    t.decoration]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opdecorateid t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_2) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Decoration.satisfies_version
                    t.decoration]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opdecoratestring t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_4) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Decoration.satisfies_version
                    t.decoration]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opdecorationgroup t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupdecorate t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version
                     t.decorationgroup];
                 List.map t.targets
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupmemberdecorate t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version
                     t.decorationgroup];
                 List.map t.targets
                   ~f:Operand_kind.Payload.Pairidrefliteralinteger.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmemberdecorate t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version
                     t.structuretype];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.member];
                 [Operand_kind.Payload.Decoration.satisfies_version
                    t.decoration]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmemberdecoratestring t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_4) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.structtype];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.member];
                 [Operand_kind.Payload.Decoration.satisfies_version
                    t.decoration]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Arithmetic =
      struct
        type t =
          | Opcooperativematrixmuladdkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          b: Operand_kind.Payload.Idref.t ;
          c: Operand_kind.Payload.Idref.t ;
          cooperativematrixoperands:
            Operand_kind.Payload.Cooperativematrixoperands.t option }
          
          | Opcooperativematrixreducenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          reduce: Operand_kind.Payload.Cooperativematrixreduce.t ;
          combinefunc: Operand_kind.Payload.Idref.t } 
          | Opdot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t } 
          | Opfadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfdiv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfmakhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t ;
          operand3: Operand_kind.Payload.Idref.t } 
          | Opfmod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfmul of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfnegate of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opfrem of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfsub of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiaddcarry of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opimul of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opisub of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opisubborrow of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opmatrixtimesmatrix of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          leftmatrix: Operand_kind.Payload.Idref.t ;
          rightmatrix: Operand_kind.Payload.Idref.t } 
          | Opmatrixtimesscalar of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          scalar: Operand_kind.Payload.Idref.t } 
          | Opmatrixtimesvector of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          vector: Operand_kind.Payload.Idref.t } 
          | Opouterproduct of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t } 
          | Opsdiv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsdot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opsdotaccsat of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          accumulator: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opsmod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsmulextended of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsnegate of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opsrem of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsudot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opsudotaccsat of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          accumulator: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opudiv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opudot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opudotaccsat of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          accumulator: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opumod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opumulextended of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opvectortimesmatrix of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t ;
          matrix: Operand_kind.Payload.Idref.t } 
          | Opvectortimesscalar of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t ;
          scalar: Operand_kind.Payload.Idref.t } [@@deriving
                                                   compare, sexp_of]
        let provisional =
          function
          | Opcooperativematrixmuladdkhr _ -> false
          | Opcooperativematrixreducenv _ -> false
          | Opdot _ -> false
          | Opfadd _ -> false
          | Opfdiv _ -> false
          | Opfmakhr _ -> false
          | Opfmod _ -> false
          | Opfmul _ -> false
          | Opfnegate _ -> false
          | Opfrem _ -> false
          | Opfsub _ -> false
          | Opiadd _ -> false
          | Opiaddcarry _ -> false
          | Opimul _ -> false
          | Opisub _ -> false
          | Opisubborrow _ -> false
          | Opmatrixtimesmatrix _ -> false
          | Opmatrixtimesscalar _ -> false
          | Opmatrixtimesvector _ -> false
          | Opouterproduct _ -> false
          | Opsdiv _ -> false
          | Opsdot _ -> false
          | Opsdotaccsat _ -> false
          | Opsmod _ -> false
          | Opsmulextended _ -> false
          | Opsnegate _ -> false
          | Opsrem _ -> false
          | Opsudot _ -> false
          | Opsudotaccsat _ -> false
          | Opudiv _ -> false
          | Opudot _ -> false
          | Opudotaccsat _ -> false
          | Opumod _ -> false
          | Opumulextended _ -> false
          | Opvectortimesmatrix _ -> false
          | Opvectortimesscalar _ -> false
        let value =
          function
          | Opcooperativematrixmuladdkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Idref.value t.c];
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4459l in
              heading :: payload
          | Opcooperativematrixreducenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.matrix];
                 [Operand_kind.Payload.Cooperativematrixreduce.value t.reduce];
                 [Operand_kind.Payload.Idref.value t.combinefunc]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5366l in
              heading :: payload
          | Opdot t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 148l in
              heading :: payload
          | Opfadd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 129l in
              heading :: payload
          | Opfdiv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 136l in
              heading :: payload
          | Opfmakhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2];
                 [Operand_kind.Payload.Idref.value t.operand3]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4427l in
              heading :: payload
          | Opfmod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 141l in
              heading :: payload
          | Opfmul t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 133l in
              heading :: payload
          | Opfnegate t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 127l in
              heading :: payload
          | Opfrem t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 140l in
              heading :: payload
          | Opfsub t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 131l in
              heading :: payload
          | Opiadd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 128l in
              heading :: payload
          | Opiaddcarry t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 149l in
              heading :: payload
          | Opimul t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 132l in
              heading :: payload
          | Opisub t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 130l in
              heading :: payload
          | Opisubborrow t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 150l in
              heading :: payload
          | Opmatrixtimesmatrix t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.leftmatrix];
                 [Operand_kind.Payload.Idref.value t.rightmatrix]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 146l in
              heading :: payload
          | Opmatrixtimesscalar t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.matrix];
                 [Operand_kind.Payload.Idref.value t.scalar]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 143l in
              heading :: payload
          | Opmatrixtimesvector t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.matrix];
                 [Operand_kind.Payload.Idref.value t.vector]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 145l in
              heading :: payload
          | Opouterproduct t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 147l in
              heading :: payload
          | Opsdiv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 135l in
              heading :: payload
          | Opsdot t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4450l in
              heading :: payload
          | Opsdotaccsat t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2];
                 [Operand_kind.Payload.Idref.value t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4453l in
              heading :: payload
          | Opsmod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 139l in
              heading :: payload
          | Opsmulextended t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 152l in
              heading :: payload
          | Opsnegate t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 126l in
              heading :: payload
          | Opsrem t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 138l in
              heading :: payload
          | Opsudot t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4452l in
              heading :: payload
          | Opsudotaccsat t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2];
                 [Operand_kind.Payload.Idref.value t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4455l in
              heading :: payload
          | Opudiv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 134l in
              heading :: payload
          | Opudot t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4451l in
              heading :: payload
          | Opudotaccsat t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2];
                 [Operand_kind.Payload.Idref.value t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4454l in
              heading :: payload
          | Opumod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 137l in
              heading :: payload
          | Opumulextended t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 151l in
              heading :: payload
          | Opvectortimesmatrix t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector];
                 [Operand_kind.Payload.Idref.value t.matrix]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 144l in
              heading :: payload
          | Opvectortimesscalar t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector];
                 [Operand_kind.Payload.Idref.value t.scalar]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 142l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opdot _ -> true
          | Opfadd _ -> true
          | Opfdiv _ -> true
          | Opfmod _ -> true
          | Opfmul _ -> true
          | Opfnegate _ -> true
          | Opfrem _ -> true
          | Opfsub _ -> true
          | Opiadd _ -> true
          | Opiaddcarry _ -> true
          | Opimul _ -> true
          | Opisub _ -> true
          | Opisubborrow _ -> true
          | Opsdiv _ -> true
          | Opsmod _ -> true
          | Opsmulextended _ -> true
          | Opsnegate _ -> true
          | Opsrem _ -> true
          | Opudiv _ -> true
          | Opumod _ -> true
          | Opumulextended _ -> true
          | Opvectortimesscalar _ -> true
          | Opcooperativematrixmuladdkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixkhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.c];
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixreducenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixreductionsnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix];
                 [Operand_kind.Payload.Cooperativematrixreduce.satisfies_capabilities
                    t.reduce];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.combinefunc]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfmakhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Fmakhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand3]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opmatrixtimesmatrix t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Matrix] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.leftmatrix];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rightmatrix]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opmatrixtimesscalar t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Matrix] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.scalar]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opmatrixtimesvector t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Matrix] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opouterproduct t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Matrix] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsdot t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Dotproduct] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opsdotaccsat t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Dotproduct] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opsudot t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Dotproduct] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opsudotaccsat t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Dotproduct] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opudot t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Dotproduct] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opudotaccsat t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Dotproduct] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opvectortimesmatrix t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Matrix] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.vector];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Opcooperativematrixmuladdkhr _ -> true
          | Opcooperativematrixreducenv _ -> true
          | Opdot _ -> true
          | Opfadd _ -> true
          | Opfdiv _ -> true
          | Opfmakhr _ -> true
          | Opfmod _ -> true
          | Opfmul _ -> true
          | Opfnegate _ -> true
          | Opfrem _ -> true
          | Opfsub _ -> true
          | Opiadd _ -> true
          | Opiaddcarry _ -> true
          | Opimul _ -> true
          | Opisub _ -> true
          | Opisubborrow _ -> true
          | Opmatrixtimesmatrix _ -> true
          | Opmatrixtimesscalar _ -> true
          | Opmatrixtimesvector _ -> true
          | Opouterproduct _ -> true
          | Opsdiv _ -> true
          | Opsmod _ -> true
          | Opsmulextended _ -> true
          | Opsnegate _ -> true
          | Opsrem _ -> true
          | Opudiv _ -> true
          | Opumod _ -> true
          | Opumulextended _ -> true
          | Opvectortimesmatrix _ -> true
          | Opvectortimesscalar _ -> true
          | Opsdot t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_integer_dot_product]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opsdotaccsat t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_integer_dot_product]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opsudot t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_integer_dot_product]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opsudotaccsat t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_integer_dot_product]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opudot t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_integer_dot_product]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opudotaccsat t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_integer_dot_product]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opcooperativematrixmuladdkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Idref.satisfies_version t.c];
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativematrixreducenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix];
                 [Operand_kind.Payload.Cooperativematrixreduce.satisfies_version
                    t.reduce];
                 [Operand_kind.Payload.Idref.satisfies_version t.combinefunc]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opdot t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfadd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfdiv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfmakhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand3]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfmod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfmul t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfnegate t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfrem t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfsub t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opiadd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opiaddcarry t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimul t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opisub t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opisubborrow t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmatrixtimesmatrix t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.leftmatrix];
                 [Operand_kind.Payload.Idref.satisfies_version t.rightmatrix]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmatrixtimesscalar t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_version t.scalar]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opmatrixtimesvector t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opouterproduct t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsdiv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsdot t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_6) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opsdotaccsat t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_6) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_version t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opsmod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsmulextended t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsnegate t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsrem t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsudot t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_6) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opsudotaccsat t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_6) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_version t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opudiv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opudot t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_6) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opudotaccsat t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_6) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2];
                 [Operand_kind.Payload.Idref.satisfies_version t.accumulator];
                 (t.packedvectorformat |>
                    (Option.map
                       ~f:Operand_kind.Payload.Packedvectorformat.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opumod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opumulextended t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opvectortimesmatrix t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opvectortimesscalar t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector];
                 [Operand_kind.Payload.Idref.satisfies_version t.scalar]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Atomic =
      struct
        type t =
          | Opatomicand of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomiccompareexchange of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          equal: Operand_kind.Payload.Idmemorysemantics.t ;
          unequal: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t ;
          comparator: Operand_kind.Payload.Idref.t } 
          | Opatomiccompareexchangeweak of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          equal: Operand_kind.Payload.Idmemorysemantics.t ;
          unequal: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t ;
          comparator: Operand_kind.Payload.Idref.t } 
          | Opatomicexchange of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicfaddext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicflagclear of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomicflagtestandset of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomicfmaxext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicfminext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomiciadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicidecrement of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomiciincrement of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomicisub of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicload of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomicor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicsmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicsmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicstore of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicumax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicumin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicxor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opatomicand _ -> false
          | Opatomiccompareexchange _ -> false
          | Opatomiccompareexchangeweak _ -> false
          | Opatomicexchange _ -> false
          | Opatomicfaddext _ -> false
          | Opatomicflagclear _ -> false
          | Opatomicflagtestandset _ -> false
          | Opatomicfmaxext _ -> false
          | Opatomicfminext _ -> false
          | Opatomiciadd _ -> false
          | Opatomicidecrement _ -> false
          | Opatomiciincrement _ -> false
          | Opatomicisub _ -> false
          | Opatomicload _ -> false
          | Opatomicor _ -> false
          | Opatomicsmax _ -> false
          | Opatomicsmin _ -> false
          | Opatomicstore _ -> false
          | Opatomicumax _ -> false
          | Opatomicumin _ -> false
          | Opatomicxor _ -> false
        let value =
          function
          | Opatomicand t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 240l in
              heading :: payload
          | Opatomiccompareexchange t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.equal];
                 [Operand_kind.Payload.Idmemorysemantics.value t.unequal];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.comparator]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 230l in
              heading :: payload
          | Opatomiccompareexchangeweak t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.equal];
                 [Operand_kind.Payload.Idmemorysemantics.value t.unequal];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.comparator]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 231l in
              heading :: payload
          | Opatomicexchange t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 229l in
              heading :: payload
          | Opatomicfaddext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6035l in
              heading :: payload
          | Opatomicflagclear t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 319l in
              heading :: payload
          | Opatomicflagtestandset t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 318l in
              heading :: payload
          | Opatomicfmaxext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5615l in
              heading :: payload
          | Opatomicfminext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5614l in
              heading :: payload
          | Opatomiciadd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 234l in
              heading :: payload
          | Opatomicidecrement t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 233l in
              heading :: payload
          | Opatomiciincrement t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 232l in
              heading :: payload
          | Opatomicisub t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 235l in
              heading :: payload
          | Opatomicload t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 227l in
              heading :: payload
          | Opatomicor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 241l in
              heading :: payload
          | Opatomicsmax t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 238l in
              heading :: payload
          | Opatomicsmin t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 236l in
              heading :: payload
          | Opatomicstore t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 228l in
              heading :: payload
          | Opatomicumax t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 239l in
              heading :: payload
          | Opatomicumin t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 237l in
              heading :: payload
          | Opatomicxor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 242l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opatomicand _ -> true
          | Opatomiccompareexchange _ -> true
          | Opatomicexchange _ -> true
          | Opatomiciadd _ -> true
          | Opatomicidecrement _ -> true
          | Opatomiciincrement _ -> true
          | Opatomicisub _ -> true
          | Opatomicload _ -> true
          | Opatomicor _ -> true
          | Opatomicsmax _ -> true
          | Opatomicsmin _ -> true
          | Opatomicstore _ -> true
          | Opatomicumax _ -> true
          | Opatomicumin _ -> true
          | Opatomicxor _ -> true
          | Opatomiccompareexchangeweak t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.equal];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.unequal];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.comparator]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opatomicfaddext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Atomicfloat16addext;
                       Operand_kind.Payload.Capability.Atomicfloat32addext;
                       Operand_kind.Payload.Capability.Atomicfloat64addext;
                       Operand_kind.Payload.Capability.Atomicfloat16vectornv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opatomicflagclear t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opatomicflagtestandset t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opatomicfmaxext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Atomicfloat16minmaxext;
                       Operand_kind.Payload.Capability.Atomicfloat32minmaxext;
                       Operand_kind.Payload.Capability.Atomicfloat64minmaxext;
                       Operand_kind.Payload.Capability.Atomicfloat16vectornv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opatomicfminext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Atomicfloat16minmaxext;
                       Operand_kind.Payload.Capability.Atomicfloat32minmaxext;
                       Operand_kind.Payload.Capability.Atomicfloat64minmaxext;
                       Operand_kind.Payload.Capability.Atomicfloat16vectornv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Opatomicand _ -> true
          | Opatomiccompareexchange _ -> true
          | Opatomiccompareexchangeweak _ -> true
          | Opatomicexchange _ -> true
          | Opatomicflagclear _ -> true
          | Opatomicflagtestandset _ -> true
          | Opatomicfmaxext _ -> true
          | Opatomicfminext _ -> true
          | Opatomiciadd _ -> true
          | Opatomicidecrement _ -> true
          | Opatomiciincrement _ -> true
          | Opatomicisub _ -> true
          | Opatomicload _ -> true
          | Opatomicor _ -> true
          | Opatomicsmax _ -> true
          | Opatomicsmin _ -> true
          | Opatomicstore _ -> true
          | Opatomicumax _ -> true
          | Opatomicumin _ -> true
          | Opatomicxor _ -> true
          | Opatomicfaddext t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_ext_shader_atomic_float_add]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_extensions t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_extensions
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opatomicand t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomiccompareexchange t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.equal];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.unequal];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.comparator]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomiccompareexchangeweak t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:(Some V1_3))
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.equal];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.unequal];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.comparator]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicexchange t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicfaddext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicflagclear t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicflagtestandset t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicfmaxext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicfminext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomiciadd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicidecrement t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomiciincrement t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicisub t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicload t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicsmax t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicsmin t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicstore t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicumax t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicumin t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opatomicxor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Barrier =
      struct
        type t =
          | Opcontrolbarrier of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opcontrolbarrierarriveintel of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opcontrolbarrierwaitintel of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opmemorybarrier of
          {
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opmemorynamedbarrier of
          {
          namedbarrier: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opnamedbarrierinitialize of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          subgroupcount: Operand_kind.Payload.Idref.t } [@@deriving
                                                          compare, sexp_of]
        let provisional =
          function
          | Opcontrolbarrier _ -> false
          | Opcontrolbarrierarriveintel _ -> false
          | Opcontrolbarrierwaitintel _ -> false
          | Opmemorybarrier _ -> false
          | Opmemorynamedbarrier _ -> false
          | Opnamedbarrierinitialize _ -> false
        let value =
          function
          | Opcontrolbarrier t ->
              let payload =
                ([[Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 224l in
              heading :: payload
          | Opcontrolbarrierarriveintel t ->
              let payload =
                ([[Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6142l in
              heading :: payload
          | Opcontrolbarrierwaitintel t ->
              let payload =
                ([[Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6143l in
              heading :: payload
          | Opmemorybarrier t ->
              let payload =
                ([[Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 225l in
              heading :: payload
          | Opmemorynamedbarrier t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.namedbarrier];
                 [Operand_kind.Payload.Idscope.value t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.value t.semantics]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 329l in
              heading :: payload
          | Opnamedbarrierinitialize t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.subgroupcount]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 328l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opcontrolbarrier _ -> true
          | Opmemorybarrier _ -> true
          | Opcontrolbarrierarriveintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Splitbarrierintel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idscope.satisfies_capabilities
                     t.execution];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcontrolbarrierwaitintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Splitbarrierintel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idscope.satisfies_capabilities
                     t.execution];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opmemorynamedbarrier t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Namedbarrier] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.namedbarrier];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_capabilities
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opnamedbarrierinitialize t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Namedbarrier] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.subgroupcount]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opcontrolbarrier _ -> true
          | Opcontrolbarrierarriveintel _ -> true
          | Opcontrolbarrierwaitintel _ -> true
          | Opmemorybarrier _ -> true
          | Opmemorynamedbarrier _ -> true
          | Opnamedbarrierinitialize _ -> true
        let satisfies_version t ~version =
          match t with
          | Opcontrolbarrier t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcontrolbarrierarriveintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcontrolbarrierwaitintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmemorybarrier t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmemorynamedbarrier t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version
                     t.namedbarrier];
                 [Operand_kind.Payload.Idscope.satisfies_version t.memory];
                 [Operand_kind.Payload.Idmemorysemantics.satisfies_version
                    t.semantics]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opnamedbarrierinitialize t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.subgroupcount]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Bit =
      struct
        type t =
          | Opbitcount of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t } 
          | Opbitfieldinsert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          insert: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          count: Operand_kind.Payload.Idref.t } 
          | Opbitfieldsextract of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          count: Operand_kind.Payload.Idref.t } 
          | Opbitfielduextract of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          count: Operand_kind.Payload.Idref.t } 
          | Opbitreverse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t } 
          | Opbitwiseand of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opbitwisefunctionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          b: Operand_kind.Payload.Idref.t ;
          c: Operand_kind.Payload.Idref.t ;
          lutindex: Operand_kind.Payload.Idref.t } 
          | Opbitwiseor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opbitwisexor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opnot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opshiftleftlogical of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          shift: Operand_kind.Payload.Idref.t } 
          | Opshiftrightarithmetic of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          shift: Operand_kind.Payload.Idref.t } 
          | Opshiftrightlogical of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          shift: Operand_kind.Payload.Idref.t } [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opbitcount _ -> false
          | Opbitfieldinsert _ -> false
          | Opbitfieldsextract _ -> false
          | Opbitfielduextract _ -> false
          | Opbitreverse _ -> false
          | Opbitwiseand _ -> false
          | Opbitwisefunctionintel _ -> false
          | Opbitwiseor _ -> false
          | Opbitwisexor _ -> false
          | Opnot _ -> false
          | Opshiftleftlogical _ -> false
          | Opshiftrightarithmetic _ -> false
          | Opshiftrightlogical _ -> false
        let value =
          function
          | Opbitcount t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 205l in
              heading :: payload
          | Opbitfieldinsert t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.insert];
                 [Operand_kind.Payload.Idref.value t.offset];
                 [Operand_kind.Payload.Idref.value t.count]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 201l in
              heading :: payload
          | Opbitfieldsextract t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.offset];
                 [Operand_kind.Payload.Idref.value t.count]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 202l in
              heading :: payload
          | Opbitfielduextract t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.offset];
                 [Operand_kind.Payload.Idref.value t.count]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 203l in
              heading :: payload
          | Opbitreverse t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 204l in
              heading :: payload
          | Opbitwiseand t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 199l in
              heading :: payload
          | Opbitwisefunctionintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Idref.value t.c];
                 [Operand_kind.Payload.Idref.value t.lutindex]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6242l in
              heading :: payload
          | Opbitwiseor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 197l in
              heading :: payload
          | Opbitwisexor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 198l in
              heading :: payload
          | Opnot t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 200l in
              heading :: payload
          | Opshiftleftlogical t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.shift]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 196l in
              heading :: payload
          | Opshiftrightarithmetic t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.shift]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 195l in
              heading :: payload
          | Opshiftrightlogical t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.shift]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 194l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opbitcount _ -> true
          | Opbitwiseand _ -> true
          | Opbitwiseor _ -> true
          | Opbitwisexor _ -> true
          | Opnot _ -> true
          | Opshiftleftlogical _ -> true
          | Opshiftrightarithmetic _ -> true
          | Opshiftrightlogical _ -> true
          | Opbitfieldinsert t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader;
                       Operand_kind.Payload.Capability.Bitinstructions] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.insert];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.offset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.count]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opbitfieldsextract t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader;
                       Operand_kind.Payload.Capability.Bitinstructions] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.offset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.count]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opbitfielduextract t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader;
                       Operand_kind.Payload.Capability.Bitinstructions] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.offset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.count]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opbitreverse t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader;
                       Operand_kind.Payload.Capability.Bitinstructions] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opbitwisefunctionintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Ternarybitwisefunctionintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.c];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.lutindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opbitcount _ -> true
          | Opbitfieldinsert _ -> true
          | Opbitfieldsextract _ -> true
          | Opbitfielduextract _ -> true
          | Opbitreverse _ -> true
          | Opbitwiseand _ -> true
          | Opbitwisefunctionintel _ -> true
          | Opbitwiseor _ -> true
          | Opbitwisexor _ -> true
          | Opnot _ -> true
          | Opshiftleftlogical _ -> true
          | Opshiftrightarithmetic _ -> true
          | Opshiftrightlogical _ -> true
        let satisfies_version t ~version =
          match t with
          | Opbitcount t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitfieldinsert t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.insert];
                 [Operand_kind.Payload.Idref.satisfies_version t.offset];
                 [Operand_kind.Payload.Idref.satisfies_version t.count]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitfieldsextract t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.offset];
                 [Operand_kind.Payload.Idref.satisfies_version t.count]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitfielduextract t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.offset];
                 [Operand_kind.Payload.Idref.satisfies_version t.count]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitreverse t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitwiseand t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitwisefunctionintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Idref.satisfies_version t.c];
                 [Operand_kind.Payload.Idref.satisfies_version t.lutindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitwiseor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitwisexor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opnot t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opshiftleftlogical t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.shift]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opshiftrightarithmetic t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.shift]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opshiftrightlogical t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.shift]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Composite =
      struct
        type t =
          | Opcompositeconstruct of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opcompositeconstructcontinuedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opcompositeconstructcoopmatqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcearray: Operand_kind.Payload.Idref.t } 
          | Opcompositeconstructreplicateext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opcompositeextract of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          composite: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Literalinteger.t list } 
          | Opcompositeextractcoopmatqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcecooperativematrix: Operand_kind.Payload.Idref.t } 
          | Opcompositeinsert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          object_: Operand_kind.Payload.Idref.t ;
          composite: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Literalinteger.t list } 
          | Opconditionalcopyobjectintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          condition0operand0condition1operand1___:
            Operand_kind.Payload.Idref.t list }
          
          | Opcopylogical of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opcopyobject of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opextractsubarrayqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcearray: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Optranspose of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t } 
          | Opvectorextractdynamic of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opvectorinsertdynamic of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t ;
          component: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opvectorshuffle of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          components: Operand_kind.Payload.Literalinteger.t list } [@@deriving
                                                                    compare, sexp_of]
        let provisional =
          function
          | Opcompositeconstruct _ -> false
          | Opcompositeconstructcontinuedintel _ -> false
          | Opcompositeconstructcoopmatqcom _ -> false
          | Opcompositeconstructreplicateext _ -> false
          | Opcompositeextract _ -> false
          | Opcompositeextractcoopmatqcom _ -> false
          | Opcompositeinsert _ -> false
          | Opconditionalcopyobjectintel _ -> true
          | Opcopylogical _ -> false
          | Opcopyobject _ -> false
          | Opextractsubarrayqcom _ -> false
          | Optranspose _ -> false
          | Opvectorextractdynamic _ -> false
          | Opvectorinsertdynamic _ -> false
          | Opvectorshuffle _ -> false
        let value =
          function
          | Opcompositeconstruct t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.constituents ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 80l in
              heading :: payload
          | Opcompositeconstructcontinuedintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.constituents ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6096l in
              heading :: payload
          | Opcompositeconstructcoopmatqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sourcearray]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4540l in
              heading :: payload
          | Opcompositeconstructreplicateext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4463l in
              heading :: payload
          | Opcompositeextract t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.composite];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Literalinteger.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 81l in
              heading :: payload
          | Opcompositeextractcoopmatqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sourcecooperativematrix]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4541l in
              heading :: payload
          | Opcompositeinsert t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.object_];
                 [Operand_kind.Payload.Idref.value t.composite];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Literalinteger.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 82l in
              heading :: payload
          | Opconditionalcopyobjectintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.condition0operand0condition1operand1___
                   ~f:Operand_kind.Payload.Idref.value] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6254l in
              heading :: payload
          | Opcopylogical t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 400l in
              heading :: payload
          | Opcopyobject t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 83l in
              heading :: payload
          | Opextractsubarrayqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sourcearray];
                 [Operand_kind.Payload.Idref.value t.index]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4542l in
              heading :: payload
          | Optranspose t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.matrix]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 84l in
              heading :: payload
          | Opvectorextractdynamic t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector];
                 [Operand_kind.Payload.Idref.value t.index]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 77l in
              heading :: payload
          | Opvectorinsertdynamic t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector];
                 [Operand_kind.Payload.Idref.value t.component];
                 [Operand_kind.Payload.Idref.value t.index]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 78l in
              heading :: payload
          | Opvectorshuffle t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector1];
                 [Operand_kind.Payload.Idref.value t.vector2];
                 List.map t.components
                   ~f:Operand_kind.Payload.Literalinteger.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 79l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opcompositeconstruct _ -> true
          | Opcompositeextract _ -> true
          | Opcompositeinsert _ -> true
          | Opcopylogical _ -> true
          | Opcopyobject _ -> true
          | Opvectorextractdynamic _ -> true
          | Opvectorinsertdynamic _ -> true
          | Opvectorshuffle _ -> true
          | Opcompositeconstructcontinuedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Longcompositesintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 List.map t.constituents
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcompositeconstructcoopmatqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixconversionqcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sourcearray]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcompositeconstructreplicateext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Replicatedcompositesext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcompositeextractcoopmatqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixconversionqcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sourcecooperativematrix]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconditionalcopyobjectintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Specconditionalintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 List.map t.condition0operand0condition1operand1___
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opextractsubarrayqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixconversionqcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sourcearray];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.index]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optranspose t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Matrix] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opcompositeconstruct _ -> true
          | Opcompositeconstructcontinuedintel _ -> true
          | Opcompositeconstructcoopmatqcom _ -> true
          | Opcompositeconstructreplicateext _ -> true
          | Opcompositeextract _ -> true
          | Opcompositeextractcoopmatqcom _ -> true
          | Opcompositeinsert _ -> true
          | Opconditionalcopyobjectintel _ -> true
          | Opcopylogical _ -> true
          | Opcopyobject _ -> true
          | Opextractsubarrayqcom _ -> true
          | Optranspose _ -> true
          | Opvectorextractdynamic _ -> true
          | Opvectorinsertdynamic _ -> true
          | Opvectorshuffle _ -> true
        let satisfies_version t ~version =
          match t with
          | Opcompositeconstruct t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.constituents
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcompositeconstructcontinuedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.constituents
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcompositeconstructcoopmatqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sourcearray]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcompositeconstructreplicateext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcompositeextract t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.composite];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Literalinteger.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcompositeextractcoopmatqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sourcecooperativematrix]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcompositeinsert t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.object_];
                 [Operand_kind.Payload.Idref.satisfies_version t.composite];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Literalinteger.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconditionalcopyobjectintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.condition0operand0condition1operand1___
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcopylogical t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_4) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcopyobject t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opextractsubarrayqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sourcearray];
                 [Operand_kind.Payload.Idref.satisfies_version t.index]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optranspose t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opvectorextractdynamic t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector];
                 [Operand_kind.Payload.Idref.satisfies_version t.index]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opvectorinsertdynamic t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector];
                 [Operand_kind.Payload.Idref.satisfies_version t.component];
                 [Operand_kind.Payload.Idref.satisfies_version t.index]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opvectorshuffle t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector1];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector2];
                 List.map t.components
                   ~f:Operand_kind.Payload.Literalinteger.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Constant_creation =
      struct
        type t =
          | Opconstant of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Literalcontextdependentnumber.t } 
          | Opconstantcomposite of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opconstantcompositecontinuedintel of
          {
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opconstantcompositereplicateext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opconstantfalse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opconstantnull of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opconstantsampler of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampleraddressingmode: Operand_kind.Payload.Sampleraddressingmode.t ;
          param: Operand_kind.Payload.Literalinteger.t ;
          samplerfiltermode: Operand_kind.Payload.Samplerfiltermode.t } 
          | Opconstanttrue of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opspecconstant of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Literalcontextdependentnumber.t } 
          | Opspecconstantarchitectureintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          category: Operand_kind.Payload.Literalinteger.t ;
          family: Operand_kind.Payload.Literalinteger.t ;
          opcode: Operand_kind.Payload.Literalinteger.t ;
          architecture: Operand_kind.Payload.Literalinteger.t } 
          | Opspecconstantcapabilitiesintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          capabilities: Operand_kind.Payload.Capability.t list } 
          | Opspecconstantcomposite of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opspecconstantcompositecontinuedintel of
          {
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opspecconstantcompositereplicateext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opspecconstantfalse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opspecconstantop of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          opcode: Operand_kind.Payload.Literalspecconstantopinteger.t } 
          | Opspecconstanttargetintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          target: Operand_kind.Payload.Literalinteger.t ;
          features: Operand_kind.Payload.Literalinteger.t list } 
          | Opspecconstanttrue of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } [@@deriving
                                                        compare, sexp_of]
        let provisional =
          function
          | Opconstant _ -> false
          | Opconstantcomposite _ -> false
          | Opconstantcompositecontinuedintel _ -> false
          | Opconstantcompositereplicateext _ -> false
          | Opconstantfalse _ -> false
          | Opconstantnull _ -> false
          | Opconstantsampler _ -> false
          | Opconstanttrue _ -> false
          | Opspecconstant _ -> false
          | Opspecconstantarchitectureintel _ -> true
          | Opspecconstantcapabilitiesintel _ -> true
          | Opspecconstantcomposite _ -> false
          | Opspecconstantcompositecontinuedintel _ -> false
          | Opspecconstantcompositereplicateext _ -> false
          | Opspecconstantfalse _ -> false
          | Opspecconstantop _ -> false
          | Opspecconstanttargetintel _ -> true
          | Opspecconstanttrue _ -> false
        let value =
          function
          | Opconstant t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalcontextdependentnumber.value
                    t.value]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 43l in
              heading :: payload
          | Opconstantcomposite t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.constituents ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 44l in
              heading :: payload
          | Opconstantcompositecontinuedintel t ->
              let payload =
                ([List.map t.constituents ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6091l in
              heading :: payload
          | Opconstantcompositereplicateext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4461l in
              heading :: payload
          | Opconstantfalse t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 42l in
              heading :: payload
          | Opconstantnull t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 46l in
              heading :: payload
          | Opconstantsampler t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Sampleraddressingmode.value
                    t.sampleraddressingmode];
                 [Operand_kind.Payload.Literalinteger.value t.param];
                 [Operand_kind.Payload.Samplerfiltermode.value
                    t.samplerfiltermode]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 45l in
              heading :: payload
          | Opconstanttrue t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 41l in
              heading :: payload
          | Opspecconstant t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalcontextdependentnumber.value
                    t.value]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 50l in
              heading :: payload
          | Opspecconstantarchitectureintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalinteger.value t.category];
                 [Operand_kind.Payload.Literalinteger.value t.family];
                 [Operand_kind.Payload.Literalinteger.value t.opcode];
                 [Operand_kind.Payload.Literalinteger.value t.architecture]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6252l in
              heading :: payload
          | Opspecconstantcapabilitiesintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.capabilities
                   ~f:Operand_kind.Payload.Capability.value] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6253l in
              heading :: payload
          | Opspecconstantcomposite t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.constituents ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 51l in
              heading :: payload
          | Opspecconstantcompositecontinuedintel t ->
              let payload =
                ([List.map t.constituents ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6092l in
              heading :: payload
          | Opspecconstantcompositereplicateext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4462l in
              heading :: payload
          | Opspecconstantfalse t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 49l in
              heading :: payload
          | Opspecconstantop t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalspecconstantopinteger.value
                    t.opcode]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 52l in
              heading :: payload
          | Opspecconstanttargetintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalinteger.value t.target];
                 List.map t.features
                   ~f:Operand_kind.Payload.Literalinteger.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6251l in
              heading :: payload
          | Opspecconstanttrue t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 48l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opconstant _ -> true
          | Opconstantcomposite _ -> true
          | Opconstantfalse _ -> true
          | Opconstantnull _ -> true
          | Opconstanttrue _ -> true
          | Opspecconstant _ -> true
          | Opspecconstantcomposite _ -> true
          | Opspecconstantfalse _ -> true
          | Opspecconstantop _ -> true
          | Opspecconstanttrue _ -> true
          | Opconstantcompositecontinuedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Longcompositesintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([List.map t.constituents
                    ~f:Operand_kind.Payload.Idref.satisfies_capabilities]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconstantcompositereplicateext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Replicatedcompositesext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconstantsampler t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Literalsampler] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Sampleraddressingmode.satisfies_capabilities
                    t.sampleraddressingmode];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.param];
                 [Operand_kind.Payload.Samplerfiltermode.satisfies_capabilities
                    t.samplerfiltermode]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opspecconstantarchitectureintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Functionvariantsintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.category];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.family];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.opcode];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.architecture]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opspecconstantcapabilitiesintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Functionvariantsintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 List.map t.capabilities
                   ~f:Operand_kind.Payload.Capability.satisfies_capabilities]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opspecconstantcompositecontinuedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Longcompositesintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([List.map t.constituents
                    ~f:Operand_kind.Payload.Idref.satisfies_capabilities]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opspecconstantcompositereplicateext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Replicatedcompositesext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opspecconstanttargetintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Functionvariantsintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.target];
                 List.map t.features
                   ~f:Operand_kind.Payload.Literalinteger.satisfies_capabilities]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opconstant _ -> true
          | Opconstantcomposite _ -> true
          | Opconstantcompositecontinuedintel _ -> true
          | Opconstantcompositereplicateext _ -> true
          | Opconstantfalse _ -> true
          | Opconstantnull _ -> true
          | Opconstantsampler _ -> true
          | Opconstanttrue _ -> true
          | Opspecconstant _ -> true
          | Opspecconstantarchitectureintel _ -> true
          | Opspecconstantcapabilitiesintel _ -> true
          | Opspecconstantcomposite _ -> true
          | Opspecconstantcompositecontinuedintel _ -> true
          | Opspecconstantcompositereplicateext _ -> true
          | Opspecconstantfalse _ -> true
          | Opspecconstantop _ -> true
          | Opspecconstanttargetintel _ -> true
          | Opspecconstanttrue _ -> true
        let satisfies_version t ~version =
          match t with
          | Opconstant t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalcontextdependentnumber.satisfies_version
                    t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstantcomposite t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.constituents
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstantcompositecontinuedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([List.map t.constituents
                    ~f:Operand_kind.Payload.Idref.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstantcompositereplicateext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstantfalse t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstantnull t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstantsampler t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Sampleraddressingmode.satisfies_version
                    t.sampleraddressingmode];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.param];
                 [Operand_kind.Payload.Samplerfiltermode.satisfies_version
                    t.samplerfiltermode]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstanttrue t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstant t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalcontextdependentnumber.satisfies_version
                    t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstantarchitectureintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.category];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.family];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.opcode];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.architecture]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstantcapabilitiesintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.capabilities
                   ~f:Operand_kind.Payload.Capability.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstantcomposite t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.constituents
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstantcompositecontinuedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([List.map t.constituents
                    ~f:Operand_kind.Payload.Idref.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstantcompositereplicateext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstantfalse t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstantop t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalspecconstantopinteger.satisfies_version
                    t.opcode]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstanttargetintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.target];
                 List.map t.features
                   ~f:Operand_kind.Payload.Literalinteger.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstanttrue t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Control_flow =
      struct
        type t =
          | Opbranch of {
          targetlabel: Operand_kind.Payload.Idref.t } 
          | Opbranchconditional of
          {
          condition: Operand_kind.Payload.Idref.t ;
          truelabel: Operand_kind.Payload.Idref.t ;
          falselabel: Operand_kind.Payload.Idref.t ;
          branchweights: Operand_kind.Payload.Literalinteger.t list } 
          | Opdemotetohelperinvocation 
          | Opkill 
          | Oplabel of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Oplifetimestart of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          size: Operand_kind.Payload.Literalinteger.t } 
          | Oplifetimestop of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          size: Operand_kind.Payload.Literalinteger.t } 
          | Oploopmerge of
          {
          mergeblock: Operand_kind.Payload.Idref.t ;
          continuetarget: Operand_kind.Payload.Idref.t ;
          loopcontrol: Operand_kind.Payload.Loopcontrol.t } 
          | Opphi of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          variableparent___: Operand_kind.Payload.Pairidrefidref.t list } 
          | Opreturn 
          | Opreturnvalue of {
          value: Operand_kind.Payload.Idref.t } 
          | Opselectionmerge of
          {
          mergeblock: Operand_kind.Payload.Idref.t ;
          selectioncontrol: Operand_kind.Payload.Selectioncontrol.t } 
          | Opswitch of
          {
          selector: Operand_kind.Payload.Idref.t ;
          default: Operand_kind.Payload.Idref.t ;
          target: Operand_kind.Payload.Pairliteralintegeridref.t list } 
          | Opterminateinvocation 
          | Opunreachable [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opbranch _ -> false
          | Opbranchconditional _ -> false
          | Opdemotetohelperinvocation -> false
          | Opkill -> false
          | Oplabel _ -> false
          | Oplifetimestart _ -> false
          | Oplifetimestop _ -> false
          | Oploopmerge _ -> false
          | Opphi _ -> false
          | Opreturn -> false
          | Opreturnvalue _ -> false
          | Opselectionmerge _ -> false
          | Opswitch _ -> false
          | Opterminateinvocation -> false
          | Opunreachable -> false
        let value =
          function
          | Opbranch t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.targetlabel]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 249l in
              heading :: payload
          | Opbranchconditional t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.condition];
                 [Operand_kind.Payload.Idref.value t.truelabel];
                 [Operand_kind.Payload.Idref.value t.falselabel];
                 List.map t.branchweights
                   ~f:Operand_kind.Payload.Literalinteger.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 250l in
              heading :: payload
          | Opdemotetohelperinvocation ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5380l in
              [heading]
          | Opkill ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 252l in
              [heading]
          | Oplabel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 248l in
              heading :: payload
          | Oplifetimestart t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Literalinteger.value t.size]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 256l in
              heading :: payload
          | Oplifetimestop t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Literalinteger.value t.size]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 257l in
              heading :: payload
          | Oploopmerge t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.mergeblock];
                 [Operand_kind.Payload.Idref.value t.continuetarget];
                 [Operand_kind.Payload.Loopcontrol.value t.loopcontrol]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 246l in
              heading :: payload
          | Opphi t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.variableparent___
                   ~f:Operand_kind.Payload.Pairidrefidref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 245l in
              heading :: payload
          | Opreturn ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 253l in
              [heading]
          | Opreturnvalue t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 254l in
              heading :: payload
          | Opselectionmerge t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.mergeblock];
                 [Operand_kind.Payload.Selectioncontrol.value
                    t.selectioncontrol]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 247l in
              heading :: payload
          | Opswitch t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.selector];
                 [Operand_kind.Payload.Idref.value t.default];
                 List.map t.target
                   ~f:Operand_kind.Payload.Pairliteralintegeridref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 251l in
              heading :: payload
          | Opterminateinvocation ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 4416l in
              [heading]
          | Opunreachable ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 255l in
              [heading]
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opbranch _ -> true
          | Opbranchconditional _ -> true
          | Oplabel _ -> true
          | Oploopmerge _ -> true
          | Opphi _ -> true
          | Opreturn -> true
          | Opreturnvalue _ -> true
          | Opselectionmerge _ -> true
          | Opswitch _ -> true
          | Opunreachable -> true
          | Opdemotetohelperinvocation ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Demotetohelperinvocation]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Opkill ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Oplifetimestart t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.size]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oplifetimestop t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.size]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opterminateinvocation ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Opbranch _ -> true
          | Opbranchconditional _ -> true
          | Opdemotetohelperinvocation -> true
          | Opkill -> true
          | Oplabel _ -> true
          | Oplifetimestart _ -> true
          | Oplifetimestop _ -> true
          | Oploopmerge _ -> true
          | Opphi _ -> true
          | Opreturn -> true
          | Opreturnvalue _ -> true
          | Opselectionmerge _ -> true
          | Opswitch _ -> true
          | Opunreachable -> true
          | Opterminateinvocation ->
              List.for_all
                [(fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_terminate_invocation]
                         |> Requirements.Extension.Set.of_list) extensions)]
                ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opbranch t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.targetlabel]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opbranchconditional t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.condition];
                 [Operand_kind.Payload.Idref.satisfies_version t.truelabel];
                 [Operand_kind.Payload.Idref.satisfies_version t.falselabel];
                 List.map t.branchweights
                   ~f:Operand_kind.Payload.Literalinteger.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opdemotetohelperinvocation ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_6) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opkill ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Oplabel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oplifetimestart t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.size]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oplifetimestop t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.size]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oploopmerge t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.mergeblock];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.continuetarget];
                 [Operand_kind.Payload.Loopcontrol.satisfies_version
                    t.loopcontrol]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opphi t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.variableparent___
                   ~f:Operand_kind.Payload.Pairidrefidref.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opreturn ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opreturnvalue t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opselectionmerge t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.mergeblock];
                 [Operand_kind.Payload.Selectioncontrol.satisfies_version
                    t.selectioncontrol]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opswitch t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.selector];
                 [Operand_kind.Payload.Idref.satisfies_version t.default];
                 List.map t.target
                   ~f:Operand_kind.Payload.Pairliteralintegeridref.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opterminateinvocation ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_6) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opunreachable ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
      end
    module Conversion =
      struct
        type t =
          | Opbitcast of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opbitcastarrayqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcearray: Operand_kind.Payload.Idref.t } 
          | Opconvertbf16tofintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          bfloat16value: Operand_kind.Payload.Idref.t } 
          | Opconvertftobf16intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertftos of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertftou of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertptrtou of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opconvertstof of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          signedvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertutof of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          unsignedvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertutoptr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          integervalue: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixconvertnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixtransposenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t } 
          | Opfconvert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opgenericcasttoptr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opgenericcasttoptrexplicit of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          storage: Operand_kind.Payload.Storageclass.t } 
          | Opptrcasttogeneric of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opquantizetof16 of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Oproundftotf32intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opsatconvertstou of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          signedvalue: Operand_kind.Payload.Idref.t } 
          | Opsatconvertutos of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          unsignedvalue: Operand_kind.Payload.Idref.t } 
          | Opsconvert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          signedvalue: Operand_kind.Payload.Idref.t } 
          | Opuconvert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          unsignedvalue: Operand_kind.Payload.Idref.t } [@@deriving
                                                          compare, sexp_of]
        let provisional =
          function
          | Opbitcast _ -> false
          | Opbitcastarrayqcom _ -> false
          | Opconvertbf16tofintel _ -> false
          | Opconvertftobf16intel _ -> false
          | Opconvertftos _ -> false
          | Opconvertftou _ -> false
          | Opconvertptrtou _ -> false
          | Opconvertstof _ -> false
          | Opconvertutof _ -> false
          | Opconvertutoptr _ -> false
          | Opcooperativematrixconvertnv _ -> false
          | Opcooperativematrixtransposenv _ -> false
          | Opfconvert _ -> false
          | Opgenericcasttoptr _ -> false
          | Opgenericcasttoptrexplicit _ -> false
          | Opptrcasttogeneric _ -> false
          | Opquantizetof16 _ -> false
          | Oproundftotf32intel _ -> false
          | Opsatconvertstou _ -> false
          | Opsatconvertutos _ -> false
          | Opsconvert _ -> false
          | Opuconvert _ -> false
        let value =
          function
          | Opbitcast t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 124l in
              heading :: payload
          | Opbitcastarrayqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sourcearray]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4497l in
              heading :: payload
          | Opconvertbf16tofintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.bfloat16value]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6117l in
              heading :: payload
          | Opconvertftobf16intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.floatvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6116l in
              heading :: payload
          | Opconvertftos t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.floatvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 110l in
              heading :: payload
          | Opconvertftou t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.floatvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 109l in
              heading :: payload
          | Opconvertptrtou t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 117l in
              heading :: payload
          | Opconvertstof t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.signedvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 111l in
              heading :: payload
          | Opconvertutof t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.unsignedvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 112l in
              heading :: payload
          | Opconvertutoptr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.integervalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 120l in
              heading :: payload
          | Opcooperativematrixconvertnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.matrix]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5293l in
              heading :: payload
          | Opcooperativematrixtransposenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.matrix]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5390l in
              heading :: payload
          | Opfconvert t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.floatvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 115l in
              heading :: payload
          | Opgenericcasttoptr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 122l in
              heading :: payload
          | Opgenericcasttoptrexplicit t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Storageclass.value t.storage]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 123l in
              heading :: payload
          | Opptrcasttogeneric t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 121l in
              heading :: payload
          | Opquantizetof16 t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 116l in
              heading :: payload
          | Oproundftotf32intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.floatvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6426l in
              heading :: payload
          | Opsatconvertstou t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.signedvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 118l in
              heading :: payload
          | Opsatconvertutos t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.unsignedvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 119l in
              heading :: payload
          | Opsconvert t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.signedvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 114l in
              heading :: payload
          | Opuconvert t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.unsignedvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 113l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opbitcast _ -> true
          | Opconvertftos _ -> true
          | Opconvertftou _ -> true
          | Opconvertstof _ -> true
          | Opconvertutof _ -> true
          | Opfconvert _ -> true
          | Opsconvert _ -> true
          | Opuconvert _ -> true
          | Opbitcastarrayqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixconversionqcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sourcearray]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertbf16tofintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bfloat16conversionintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bfloat16value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertftobf16intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bfloat16conversionintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.floatvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertptrtou t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Addresses;
                       Operand_kind.Payload.Capability.Physicalstoragebufferaddresses]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertutoptr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Addresses;
                       Operand_kind.Payload.Capability.Physicalstoragebufferaddresses]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.integervalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixconvertnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixconversionsnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixtransposenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixconversionsnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgenericcasttoptr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgenericcasttoptrexplicit t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Storageclass.satisfies_capabilities
                    t.storage]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opptrcasttogeneric t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opquantizetof16 t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oproundftotf32intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensorfloat32roundingintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.floatvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsatconvertstou t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.signedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsatconvertutos t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.unsignedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opbitcast _ -> true
          | Opbitcastarrayqcom _ -> true
          | Opconvertbf16tofintel _ -> true
          | Opconvertftobf16intel _ -> true
          | Opconvertftos _ -> true
          | Opconvertftou _ -> true
          | Opconvertptrtou _ -> true
          | Opconvertstof _ -> true
          | Opconvertutof _ -> true
          | Opconvertutoptr _ -> true
          | Opcooperativematrixconvertnv _ -> true
          | Opcooperativematrixtransposenv _ -> true
          | Opfconvert _ -> true
          | Opgenericcasttoptr _ -> true
          | Opgenericcasttoptrexplicit _ -> true
          | Opptrcasttogeneric _ -> true
          | Opquantizetof16 _ -> true
          | Oproundftotf32intel _ -> true
          | Opsatconvertstou _ -> true
          | Opsatconvertutos _ -> true
          | Opsconvert _ -> true
          | Opuconvert _ -> true
        let satisfies_version t ~version =
          match t with
          | Opbitcast t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opbitcastarrayqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sourcearray]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertbf16tofintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.bfloat16value]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertftobf16intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.floatvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertftos t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.floatvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertftou t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.floatvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertptrtou t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertstof t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.signedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertutof t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.unsignedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertutoptr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.integervalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativematrixconvertnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativematrixtransposenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfconvert t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.floatvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgenericcasttoptr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgenericcasttoptrexplicit t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Storageclass.satisfies_version
                    t.storage]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opptrcasttogeneric t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opquantizetof16 t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Oproundftotf32intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.floatvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsatconvertstou t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.signedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsatconvertutos t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.unsignedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsconvert t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.signedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opuconvert t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.unsignedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Debug =
      struct
        type t =
          | Opline of
          {
          file: Operand_kind.Payload.Idref.t ;
          line: Operand_kind.Payload.Literalinteger.t ;
          column: Operand_kind.Payload.Literalinteger.t } 
          | Opmembername of
          {
          type_: Operand_kind.Payload.Idref.t ;
          member: Operand_kind.Payload.Literalinteger.t ;
          name: Operand_kind.Payload.Literalstring.t } 
          | Opmoduleprocessed of
          {
          process: Operand_kind.Payload.Literalstring.t } 
          | Opname of
          {
          target: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t } 
          | Opnoline 
          | Opsource of
          {
          sourcelanguage: Operand_kind.Payload.Sourcelanguage.t ;
          version: Operand_kind.Payload.Literalinteger.t ;
          file: Operand_kind.Payload.Idref.t option ;
          source: Operand_kind.Payload.Literalstring.t option } 
          | Opsourcecontinued of
          {
          continuedsource: Operand_kind.Payload.Literalstring.t } 
          | Opsourceextension of
          {
          extension: Operand_kind.Payload.Literalstring.t } 
          | Opstring of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          string: Operand_kind.Payload.Literalstring.t } [@@deriving
                                                           compare, sexp_of]
        let provisional =
          function
          | Opline _ -> false
          | Opmembername _ -> false
          | Opmoduleprocessed _ -> false
          | Opname _ -> false
          | Opnoline -> false
          | Opsource _ -> false
          | Opsourcecontinued _ -> false
          | Opsourceextension _ -> false
          | Opstring _ -> false
        let value =
          function
          | Opline t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.file];
                 [Operand_kind.Payload.Literalinteger.value t.line];
                 [Operand_kind.Payload.Literalinteger.value t.column]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 8l in
              heading :: payload
          | Opmembername t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.type_];
                 [Operand_kind.Payload.Literalinteger.value t.member];
                 [Operand_kind.Payload.Literalstring.value t.name]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6l in
              heading :: payload
          | Opmoduleprocessed t ->
              let payload =
                ([[Operand_kind.Payload.Literalstring.value t.process]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 330l in
              heading :: payload
          | Opname t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Literalstring.value t.name]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5l in
              heading :: payload
          | Opnoline ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 317l in
              [heading]
          | Opsource t ->
              let payload =
                ([[Operand_kind.Payload.Sourcelanguage.value t.sourcelanguage];
                 [Operand_kind.Payload.Literalinteger.value t.version];
                 (t.file |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.source |>
                    (Option.map ~f:Operand_kind.Payload.Literalstring.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 3l in
              heading :: payload
          | Opsourcecontinued t ->
              let payload =
                ([[Operand_kind.Payload.Literalstring.value t.continuedsource]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 2l in
              heading :: payload
          | Opsourceextension t ->
              let payload =
                ([[Operand_kind.Payload.Literalstring.value t.extension]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4l in
              heading :: payload
          | Opstring t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalstring.value t.string]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 7l in
              heading :: payload
        let satisfies_capabilities t ~capabilities:_ =
          match t with
          | Opline _ -> true
          | Opmembername _ -> true
          | Opmoduleprocessed _ -> true
          | Opname _ -> true
          | Opnoline -> true
          | Opsource _ -> true
          | Opsourcecontinued _ -> true
          | Opsourceextension _ -> true
          | Opstring _ -> true
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opline _ -> true
          | Opmembername _ -> true
          | Opmoduleprocessed _ -> true
          | Opname _ -> true
          | Opnoline -> true
          | Opsource _ -> true
          | Opsourcecontinued _ -> true
          | Opsourceextension _ -> true
          | Opstring _ -> true
        let satisfies_version t ~version =
          match t with
          | Opline t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.file];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.line];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.column]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmembername t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.type_];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.member];
                 [Operand_kind.Payload.Literalstring.satisfies_version t.name]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmoduleprocessed t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Literalstring.satisfies_version
                     t.process]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opname t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Literalstring.satisfies_version t.name]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opnoline ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opsource t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Sourcelanguage.satisfies_version
                     t.sourcelanguage];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.version];
                 (t.file |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.source |>
                    (Option.map
                       ~f:Operand_kind.Payload.Literalstring.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opsourcecontinued t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Literalstring.satisfies_version
                     t.continuedsource]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsourceextension t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Literalstring.satisfies_version
                     t.extension]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opstring t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_version
                    t.string]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Derivative =
      struct
        type t =
          | Opdpdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdxcoarse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdxfine of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdy of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdycoarse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdyfine of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opfwidth of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opfwidthcoarse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opfwidthfine of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opdpdx _ -> false
          | Opdpdxcoarse _ -> false
          | Opdpdxfine _ -> false
          | Opdpdy _ -> false
          | Opdpdycoarse _ -> false
          | Opdpdyfine _ -> false
          | Opfwidth _ -> false
          | Opfwidthcoarse _ -> false
          | Opfwidthfine _ -> false
        let value =
          function
          | Opdpdx t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 207l in
              heading :: payload
          | Opdpdxcoarse t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 213l in
              heading :: payload
          | Opdpdxfine t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 210l in
              heading :: payload
          | Opdpdy t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 208l in
              heading :: payload
          | Opdpdycoarse t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 214l in
              heading :: payload
          | Opdpdyfine t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 211l in
              heading :: payload
          | Opfwidth t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 209l in
              heading :: payload
          | Opfwidthcoarse t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 215l in
              heading :: payload
          | Opfwidthfine t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.p]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 212l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opdpdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opdpdxcoarse t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Derivativecontrol] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opdpdxfine t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Derivativecontrol] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opdpdy t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opdpdycoarse t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Derivativecontrol] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opdpdyfine t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Derivativecontrol] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfwidth t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfwidthcoarse t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Derivativecontrol] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfwidthfine t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Derivativecontrol] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opdpdx _ -> true
          | Opdpdxcoarse _ -> true
          | Opdpdxfine _ -> true
          | Opdpdy _ -> true
          | Opdpdycoarse _ -> true
          | Opdpdyfine _ -> true
          | Opfwidth _ -> true
          | Opfwidthcoarse _ -> true
          | Opfwidthfine _ -> true
        let satisfies_version t ~version =
          match t with
          | Opdpdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opdpdxcoarse t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opdpdxfine t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opdpdy t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opdpdycoarse t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opdpdyfine t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfwidth t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfwidthcoarse t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfwidthfine t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.p]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Device_side_enqueue =
      struct
        type t =
          | Opbuildndrange of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          globalworksize: Operand_kind.Payload.Idref.t ;
          localworksize: Operand_kind.Payload.Idref.t ;
          globalworkoffset: Operand_kind.Payload.Idref.t } 
          | Opcaptureeventprofilinginfo of
          {
          event: Operand_kind.Payload.Idref.t ;
          profilinginfo: Operand_kind.Payload.Idref.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opcreateuserevent of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Openqueuekernel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          queue: Operand_kind.Payload.Idref.t ;
          flags: Operand_kind.Payload.Idref.t ;
          ndrange: Operand_kind.Payload.Idref.t ;
          numevents: Operand_kind.Payload.Idref.t ;
          waitevents: Operand_kind.Payload.Idref.t ;
          retevent: Operand_kind.Payload.Idref.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t ;
          localsize: Operand_kind.Payload.Idref.t list } 
          | Openqueuemarker of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          queue: Operand_kind.Payload.Idref.t ;
          numevents: Operand_kind.Payload.Idref.t ;
          waitevents: Operand_kind.Payload.Idref.t ;
          retevent: Operand_kind.Payload.Idref.t } 
          | Opgetdefaultqueue of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opgetkernellocalsizeforsubgroupcount of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          subgroupcount: Operand_kind.Payload.Idref.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelmaxnumsubgroups of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelndrangemaxsubgroupsize of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          ndrange: Operand_kind.Payload.Idref.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelndrangesubgroupcount of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          ndrange: Operand_kind.Payload.Idref.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelpreferredworkgroupsizemultiple of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelworkgroupsize of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opisvalidevent of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          event: Operand_kind.Payload.Idref.t } 
          | Opreleaseevent of {
          event: Operand_kind.Payload.Idref.t } 
          | Opretainevent of {
          event: Operand_kind.Payload.Idref.t } 
          | Opsetusereventstatus of
          {
          event: Operand_kind.Payload.Idref.t ;
          status: Operand_kind.Payload.Idref.t } [@@deriving
                                                   compare, sexp_of]
        let provisional =
          function
          | Opbuildndrange _ -> false
          | Opcaptureeventprofilinginfo _ -> false
          | Opcreateuserevent _ -> false
          | Openqueuekernel _ -> false
          | Openqueuemarker _ -> false
          | Opgetdefaultqueue _ -> false
          | Opgetkernellocalsizeforsubgroupcount _ -> false
          | Opgetkernelmaxnumsubgroups _ -> false
          | Opgetkernelndrangemaxsubgroupsize _ -> false
          | Opgetkernelndrangesubgroupcount _ -> false
          | Opgetkernelpreferredworkgroupsizemultiple _ -> false
          | Opgetkernelworkgroupsize _ -> false
          | Opisvalidevent _ -> false
          | Opreleaseevent _ -> false
          | Opretainevent _ -> false
          | Opsetusereventstatus _ -> false
        let value =
          function
          | Opbuildndrange t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.globalworksize];
                 [Operand_kind.Payload.Idref.value t.localworksize];
                 [Operand_kind.Payload.Idref.value t.globalworkoffset]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 304l in
              heading :: payload
          | Opcaptureeventprofilinginfo t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.event];
                 [Operand_kind.Payload.Idref.value t.profilinginfo];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 302l in
              heading :: payload
          | Opcreateuserevent t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 299l in
              heading :: payload
          | Openqueuekernel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.queue];
                 [Operand_kind.Payload.Idref.value t.flags];
                 [Operand_kind.Payload.Idref.value t.ndrange];
                 [Operand_kind.Payload.Idref.value t.numevents];
                 [Operand_kind.Payload.Idref.value t.waitevents];
                 [Operand_kind.Payload.Idref.value t.retevent];
                 [Operand_kind.Payload.Idref.value t.invoke];
                 [Operand_kind.Payload.Idref.value t.param];
                 [Operand_kind.Payload.Idref.value t.paramsize];
                 [Operand_kind.Payload.Idref.value t.paramalign];
                 List.map t.localsize ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 292l in
              heading :: payload
          | Openqueuemarker t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.queue];
                 [Operand_kind.Payload.Idref.value t.numevents];
                 [Operand_kind.Payload.Idref.value t.waitevents];
                 [Operand_kind.Payload.Idref.value t.retevent]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 291l in
              heading :: payload
          | Opgetdefaultqueue t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 303l in
              heading :: payload
          | Opgetkernellocalsizeforsubgroupcount t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.subgroupcount];
                 [Operand_kind.Payload.Idref.value t.invoke];
                 [Operand_kind.Payload.Idref.value t.param];
                 [Operand_kind.Payload.Idref.value t.paramsize];
                 [Operand_kind.Payload.Idref.value t.paramalign]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 325l in
              heading :: payload
          | Opgetkernelmaxnumsubgroups t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.invoke];
                 [Operand_kind.Payload.Idref.value t.param];
                 [Operand_kind.Payload.Idref.value t.paramsize];
                 [Operand_kind.Payload.Idref.value t.paramalign]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 326l in
              heading :: payload
          | Opgetkernelndrangemaxsubgroupsize t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.ndrange];
                 [Operand_kind.Payload.Idref.value t.invoke];
                 [Operand_kind.Payload.Idref.value t.param];
                 [Operand_kind.Payload.Idref.value t.paramsize];
                 [Operand_kind.Payload.Idref.value t.paramalign]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 294l in
              heading :: payload
          | Opgetkernelndrangesubgroupcount t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.ndrange];
                 [Operand_kind.Payload.Idref.value t.invoke];
                 [Operand_kind.Payload.Idref.value t.param];
                 [Operand_kind.Payload.Idref.value t.paramsize];
                 [Operand_kind.Payload.Idref.value t.paramalign]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 293l in
              heading :: payload
          | Opgetkernelpreferredworkgroupsizemultiple t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.invoke];
                 [Operand_kind.Payload.Idref.value t.param];
                 [Operand_kind.Payload.Idref.value t.paramsize];
                 [Operand_kind.Payload.Idref.value t.paramalign]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 296l in
              heading :: payload
          | Opgetkernelworkgroupsize t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.invoke];
                 [Operand_kind.Payload.Idref.value t.param];
                 [Operand_kind.Payload.Idref.value t.paramsize];
                 [Operand_kind.Payload.Idref.value t.paramalign]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 295l in
              heading :: payload
          | Opisvalidevent t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.event]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 300l in
              heading :: payload
          | Opreleaseevent t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.event]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 298l in
              heading :: payload
          | Opretainevent t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.event]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 297l in
              heading :: payload
          | Opsetusereventstatus t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.event];
                 [Operand_kind.Payload.Idref.value t.status]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 301l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opbuildndrange t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.globalworksize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.localworksize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.globalworkoffset]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcaptureeventprofilinginfo t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.event];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.profilinginfo];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcreateuserevent t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Openqueuekernel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.queue];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.flags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.ndrange];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numevents];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.waitevents];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.retevent];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.param];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramalign];
                 List.map t.localsize
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Openqueuemarker t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.queue];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numevents];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.waitevents];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.retevent]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetdefaultqueue t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetkernellocalsizeforsubgroupcount t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupdispatch] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.subgroupcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.param];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetkernelmaxnumsubgroups t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupdispatch] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.param];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetkernelndrangemaxsubgroupsize t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.ndrange];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.param];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetkernelndrangesubgroupcount t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.ndrange];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.param];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetkernelpreferredworkgroupsizemultiple t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.param];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetkernelworkgroupsize t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.param];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opisvalidevent t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.event]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreleaseevent t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.event]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opretainevent t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.event]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsetusereventstatus t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.event];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.status]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opbuildndrange _ -> true
          | Opcaptureeventprofilinginfo _ -> true
          | Opcreateuserevent _ -> true
          | Openqueuekernel _ -> true
          | Openqueuemarker _ -> true
          | Opgetdefaultqueue _ -> true
          | Opgetkernellocalsizeforsubgroupcount _ -> true
          | Opgetkernelmaxnumsubgroups _ -> true
          | Opgetkernelndrangemaxsubgroupsize _ -> true
          | Opgetkernelndrangesubgroupcount _ -> true
          | Opgetkernelpreferredworkgroupsizemultiple _ -> true
          | Opgetkernelworkgroupsize _ -> true
          | Opisvalidevent _ -> true
          | Opreleaseevent _ -> true
          | Opretainevent _ -> true
          | Opsetusereventstatus _ -> true
        let satisfies_version t ~version =
          match t with
          | Opbuildndrange t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.globalworksize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.localworksize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.globalworkoffset]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcaptureeventprofilinginfo t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.event];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.profilinginfo];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcreateuserevent t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Openqueuekernel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.queue];
                 [Operand_kind.Payload.Idref.satisfies_version t.flags];
                 [Operand_kind.Payload.Idref.satisfies_version t.ndrange];
                 [Operand_kind.Payload.Idref.satisfies_version t.numevents];
                 [Operand_kind.Payload.Idref.satisfies_version t.waitevents];
                 [Operand_kind.Payload.Idref.satisfies_version t.retevent];
                 [Operand_kind.Payload.Idref.satisfies_version t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_version t.param];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramalign];
                 List.map t.localsize
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Openqueuemarker t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.queue];
                 [Operand_kind.Payload.Idref.satisfies_version t.numevents];
                 [Operand_kind.Payload.Idref.satisfies_version t.waitevents];
                 [Operand_kind.Payload.Idref.satisfies_version t.retevent]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetdefaultqueue t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetkernellocalsizeforsubgroupcount t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.subgroupcount];
                 [Operand_kind.Payload.Idref.satisfies_version t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_version t.param];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetkernelmaxnumsubgroups t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_version t.param];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetkernelndrangemaxsubgroupsize t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.ndrange];
                 [Operand_kind.Payload.Idref.satisfies_version t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_version t.param];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetkernelndrangesubgroupcount t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.ndrange];
                 [Operand_kind.Payload.Idref.satisfies_version t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_version t.param];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetkernelpreferredworkgroupsizemultiple t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_version t.param];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetkernelworkgroupsize t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.invoke];
                 [Operand_kind.Payload.Idref.satisfies_version t.param];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.paramalign]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opisvalidevent t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.event]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opreleaseevent t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.event]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opretainevent t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.event]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsetusereventstatus t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.event];
                 [Operand_kind.Payload.Idref.satisfies_version t.status]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Exclude =
      struct
        type t =
          | Opaliasdomaindeclintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          name: Operand_kind.Payload.Idref.t option } 
          | Opaliasscopedeclintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          aliasdomain: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Idref.t option } 
          | Opaliasscopelistdeclintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          aliasscope1aliasscope2___: Operand_kind.Payload.Idref.t list } 
          | Oparbitraryfloatacosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          m1: Operand_kind.Payload.Literalinteger.t ;
          mout: Operand_kind.Payload.Literalinteger.t ;
          enablesubnormals: Operand_kind.Payload.Literalinteger.t ;
          roundingmode: Operand_kind.Payload.Literalinteger.t ;
          roundingaccuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatacospiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloataddaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatasinintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatasinpiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatatan2intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatatanintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatatanpiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcastaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcastfromintaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          fromsign: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcasttointaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          tosign: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcbrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcospiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatdivaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloateqaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatexp10intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatexp2intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatexpintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatexpm1intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatgealtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatgtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloathypotaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlealtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlog10intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlog1pintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlog2intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlogintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatltaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatmulaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatpowintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatpownintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          signofb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatpowrintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatrecipaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatrsqrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsincosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsincospialtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          roundingaccuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsinintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsinpiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsqrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsubaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Opasmcallintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          asm: Operand_kind.Payload.Idref.t ;
          argument: Operand_kind.Payload.Idref.t list } 
          | Opasmintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          asmtype: Operand_kind.Payload.Idref.t ;
          target: Operand_kind.Payload.Idref.t ;
          asminstructions: Operand_kind.Payload.Literalstring.t ;
          constraints: Operand_kind.Payload.Literalstring.t } 
          | Opasmtargetintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          asmtarget: Operand_kind.Payload.Literalstring.t } 
          | Opconstantfunctionpointerintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          function_: Operand_kind.Payload.Idref.t } 
          | Opcrossworkgroupcasttoptraltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opfixedcosaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedcospialtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedexpaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedlogaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedrecipaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedrsqrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsinaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsincosaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsincospialtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsinpialtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsqrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfpgaregaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t } 
          | Opfunctionpointercallintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t list } 
          | Opptrcasttocrossworkgroupaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opreadpipeblockingaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcbmeinitializeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srccoord: Operand_kind.Payload.Idref.t ;
          motionvectors: Operand_kind.Payload.Idref.t ;
          majorshapes: Operand_kind.Payload.Idref.t ;
          minorshapes: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          pixelresolution: Operand_kind.Payload.Idref.t ;
          bidirectionalweight: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcfmeinitializeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srccoord: Operand_kind.Payload.Idref.t ;
          motionvectors: Operand_kind.Payload.Idref.t ;
          majorshapes: Operand_kind.Payload.Idref.t ;
          minorshapes: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          pixelresolution: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeadjustrefoffsetintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          refoffset: Operand_kind.Payload.Idref.t ;
          srccoord: Operand_kind.Payload.Idref.t ;
          refwindowsize: Operand_kind.Payload.Idref.t ;
          imagesize: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeconverttomcepayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeconverttomceresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithdualreferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          streamincomponents: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          streamincomponents: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithsinglereferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          streamincomponents: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          streamincomponents: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetborderreachedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          imageselect: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetdualreferencestreaminintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetsinglereferencestreaminintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegettruncatedsearchindicationintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeinitializeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srccoord: Operand_kind.Payload.Idref.t ;
          partitionmask: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimerefwindowsizeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          searchwindowconfig: Operand_kind.Payload.Idref.t ;
          dualref: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetdualreferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          fwdrefoffset: Operand_kind.Payload.Idref.t ;
          bwdrefoffset: Operand_kind.Payload.Idref.t ;
          searchwindowconfig: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetearlysearchterminationthresholdintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          threshold: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetmaxmotionvectorcountintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          maxmotionvectorcount: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetsinglereferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          refoffset: Operand_kind.Payload.Idref.t ;
          searchwindowconfig: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetunidirectionalmixdisableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetweightedsadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedsadweights: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimestripdualreferencestreamoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimestripsinglereferencestreamoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttoimepayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttoimeresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttorefpayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttorefresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttosicpayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttosicresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetbestinterdistortionsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetinterdirectionsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetinterdistortionsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetintermajorshapeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetinterminorshapeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetintermotionvectorcountintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetinterreferenceidsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          packedreferenceparameterfieldpolarities:
            Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetmotionvectorsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetaconlyhaarintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          forwardreferencefieldpolarity: Operand_kind.Payload.Idref.t ;
          backwardreferencefieldpolarity: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          referencebasepenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetinterdirectionpenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          directioncost: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetintershapepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedshapepenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedcostcenterdelta: Operand_kind.Payload.Idref.t ;
          packedcosttable: Operand_kind.Payload.Idref.t ;
          costprecision: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          referencefieldpolarity: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcefieldpolarity: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefconverttomcepayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefconverttomceresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefevaluatewithdualreferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefevaluatewithmultireferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          packedreferencefieldpolarities: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefevaluatewithsinglereferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefsetbidirectionalmixdisableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefsetbilinearfilterenableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconfigureipelumachromaintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          lumaintrapartitionmask: Operand_kind.Payload.Idref.t ;
          intraneighbouravailabilty: Operand_kind.Payload.Idref.t ;
          leftedgelumapixels: Operand_kind.Payload.Idref.t ;
          upperleftcornerlumapixel: Operand_kind.Payload.Idref.t ;
          upperedgelumapixels: Operand_kind.Payload.Idref.t ;
          upperrightedgelumapixels: Operand_kind.Payload.Idref.t ;
          leftedgechromapixels: Operand_kind.Payload.Idref.t ;
          upperleftcornerchromapixel: Operand_kind.Payload.Idref.t ;
          upperedgechromapixels: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconfigureipelumaintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          lumaintrapartitionmask: Operand_kind.Payload.Idref.t ;
          intraneighbouravailabilty: Operand_kind.Payload.Idref.t ;
          leftedgelumapixels: Operand_kind.Payload.Idref.t ;
          upperleftcornerlumapixel: Operand_kind.Payload.Idref.t ;
          upperedgelumapixels: Operand_kind.Payload.Idref.t ;
          upperrightedgelumapixels: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconfigureskcintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          skipblockpartitiontype: Operand_kind.Payload.Idref.t ;
          skipmotionvectormask: Operand_kind.Payload.Idref.t ;
          motionvectors: Operand_kind.Payload.Idref.t ;
          bidirectionalweight: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconverttomcepayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconverttomceresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluateipeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluatewithdualreferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluatewithmultireferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          packedreferencefieldpolarities: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluatewithsinglereferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetbestipechromadistortionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetbestipelumadistortionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetinterrawsadsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetipechromamodeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetipelumashapeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetmotionvectormaskintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          skipblockpartitiontype: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetpackedipelumamodesintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicinitializeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srccoord: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetbilinearfilterenableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetblockbasedrawskipsadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          blockbasedskiptype: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          chromamodebasepenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetintralumamodecostfunctionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          lumamodepenalty: Operand_kind.Payload.Idref.t ;
          lumapackedneighbormodes: Operand_kind.Payload.Idref.t ;
          lumapackednondcpenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetintralumashapepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedshapepenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetskcforwardtransformenableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedsadcoefficients: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Optasksequenceasyncaltera of
          {
          sequence: Operand_kind.Payload.Idref.t ;
          arguments: Operand_kind.Payload.Idref.t list } 
          | Optasksequencecreatealtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          function_: Operand_kind.Payload.Idref.t ;
          pipelined: Operand_kind.Payload.Literalinteger.t ;
          usestallenableclusters: Operand_kind.Payload.Literalinteger.t ;
          getcapacity: Operand_kind.Payload.Literalinteger.t ;
          asynccapacity: Operand_kind.Payload.Literalinteger.t } 
          | Optasksequencegetaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sequence: Operand_kind.Payload.Idref.t } 
          | Optasksequencereleasealtera of
          {
          sequence: Operand_kind.Payload.Idref.t } 
          | Optypeavcimedualreferencestreaminintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimepayloadintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimeresultdualreferencestreamoutintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimeresultintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimeresultsinglereferencestreamoutintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimesinglereferencestreaminintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcmcepayloadintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcmceresultintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcrefpayloadintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcrefresultintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcsicpayloadintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcsicresultintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypetasksequencealtera of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypevmeimageintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          imagetype: Operand_kind.Payload.Idref.t } 
          | Opvmeimageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          imagetype: Operand_kind.Payload.Idref.t ;
          sampler: Operand_kind.Payload.Idref.t } 
          | Opwritepipeblockingaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } [@@deriving
                                                            compare, sexp_of]
        let provisional =
          function
          | Opaliasdomaindeclintel _ -> false
          | Opaliasscopedeclintel _ -> false
          | Opaliasscopelistdeclintel _ -> false
          | Oparbitraryfloatacosintel _ -> false
          | Oparbitraryfloatacospiintel _ -> false
          | Oparbitraryfloataddaltera _ -> false
          | Oparbitraryfloatasinintel _ -> false
          | Oparbitraryfloatasinpiintel _ -> false
          | Oparbitraryfloatatan2intel _ -> false
          | Oparbitraryfloatatanintel _ -> false
          | Oparbitraryfloatatanpiintel _ -> false
          | Oparbitraryfloatcastaltera _ -> false
          | Oparbitraryfloatcastfromintaltera _ -> false
          | Oparbitraryfloatcasttointaltera _ -> false
          | Oparbitraryfloatcbrtaltera _ -> false
          | Oparbitraryfloatcosintel _ -> false
          | Oparbitraryfloatcospiintel _ -> false
          | Oparbitraryfloatdivaltera _ -> false
          | Oparbitraryfloateqaltera _ -> false
          | Oparbitraryfloatexp10intel _ -> false
          | Oparbitraryfloatexp2intel _ -> false
          | Oparbitraryfloatexpintel _ -> false
          | Oparbitraryfloatexpm1intel _ -> false
          | Oparbitraryfloatgealtera _ -> false
          | Oparbitraryfloatgtaltera _ -> false
          | Oparbitraryfloathypotaltera _ -> false
          | Oparbitraryfloatlealtera _ -> false
          | Oparbitraryfloatlog10intel _ -> false
          | Oparbitraryfloatlog1pintel _ -> false
          | Oparbitraryfloatlog2intel _ -> false
          | Oparbitraryfloatlogintel _ -> false
          | Oparbitraryfloatltaltera _ -> false
          | Oparbitraryfloatmulaltera _ -> false
          | Oparbitraryfloatpowintel _ -> false
          | Oparbitraryfloatpownintel _ -> false
          | Oparbitraryfloatpowrintel _ -> false
          | Oparbitraryfloatrecipaltera _ -> false
          | Oparbitraryfloatrsqrtaltera _ -> false
          | Oparbitraryfloatsincosintel _ -> false
          | Oparbitraryfloatsincospialtera _ -> false
          | Oparbitraryfloatsinintel _ -> false
          | Oparbitraryfloatsinpiintel _ -> false
          | Oparbitraryfloatsqrtaltera _ -> false
          | Oparbitraryfloatsubaltera _ -> false
          | Opasmcallintel _ -> false
          | Opasmintel _ -> false
          | Opasmtargetintel _ -> false
          | Opconstantfunctionpointerintel _ -> false
          | Opcrossworkgroupcasttoptraltera _ -> false
          | Opfixedcosaltera _ -> false
          | Opfixedcospialtera _ -> false
          | Opfixedexpaltera _ -> false
          | Opfixedlogaltera _ -> false
          | Opfixedrecipaltera _ -> false
          | Opfixedrsqrtaltera _ -> false
          | Opfixedsinaltera _ -> false
          | Opfixedsincosaltera _ -> false
          | Opfixedsincospialtera _ -> false
          | Opfixedsinpialtera _ -> false
          | Opfixedsqrtaltera _ -> false
          | Opfpgaregaltera _ -> false
          | Opfunctionpointercallintel _ -> false
          | Opptrcasttocrossworkgroupaltera _ -> false
          | Opreadpipeblockingaltera _ -> false
          | Opsubgroupavcbmeinitializeintel _ -> false
          | Opsubgroupavcfmeinitializeintel _ -> false
          | Opsubgroupavcimeadjustrefoffsetintel _ -> false
          | Opsubgroupavcimeconverttomcepayloadintel _ -> false
          | Opsubgroupavcimeconverttomceresultintel _ -> false
          | Opsubgroupavcimeevaluatewithdualreferenceintel _ -> false
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel _ -> false
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel _ ->
              false
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel _ ->
              false
          | Opsubgroupavcimeevaluatewithsinglereferenceintel _ -> false
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel _ ->
              false
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel _ ->
              false
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel _ ->
              false
          | Opsubgroupavcimegetborderreachedintel _ -> false
          | Opsubgroupavcimegetdualreferencestreaminintel _ -> false
          | Opsubgroupavcimegetsinglereferencestreaminintel _ -> false
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              _ -> false
          | Opsubgroupavcimegettruncatedsearchindicationintel _ -> false
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel _ ->
              false
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel _ ->
              false
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel _ ->
              false
          | Opsubgroupavcimeinitializeintel _ -> false
          | Opsubgroupavcimerefwindowsizeintel _ -> false
          | Opsubgroupavcimesetdualreferenceintel _ -> false
          | Opsubgroupavcimesetearlysearchterminationthresholdintel _ ->
              false
          | Opsubgroupavcimesetmaxmotionvectorcountintel _ -> false
          | Opsubgroupavcimesetsinglereferenceintel _ -> false
          | Opsubgroupavcimesetunidirectionalmixdisableintel _ -> false
          | Opsubgroupavcimesetweightedsadintel _ -> false
          | Opsubgroupavcimestripdualreferencestreamoutintel _ -> false
          | Opsubgroupavcimestripsinglereferencestreamoutintel _ -> false
          | Opsubgroupavcmceconverttoimepayloadintel _ -> false
          | Opsubgroupavcmceconverttoimeresultintel _ -> false
          | Opsubgroupavcmceconverttorefpayloadintel _ -> false
          | Opsubgroupavcmceconverttorefresultintel _ -> false
          | Opsubgroupavcmceconverttosicpayloadintel _ -> false
          | Opsubgroupavcmceconverttosicresultintel _ -> false
          | Opsubgroupavcmcegetbestinterdistortionsintel _ -> false
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel _ -> false
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel _
              -> false
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel _ -> false
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel _ ->
              false
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel _ -> false
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel _ ->
              false
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel _ -> false
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel _ -> false
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel _ -> false
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel _ -> false
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel _ -> false
          | Opsubgroupavcmcegetinterdirectionsintel _ -> false
          | Opsubgroupavcmcegetinterdistortionsintel _ -> false
          | Opsubgroupavcmcegetintermajorshapeintel _ -> false
          | Opsubgroupavcmcegetinterminorshapeintel _ -> false
          | Opsubgroupavcmcegetintermotionvectorcountintel _ -> false
          | Opsubgroupavcmcegetinterreferenceidsintel _ -> false
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel _
              -> false
          | Opsubgroupavcmcegetmotionvectorsintel _ -> false
          | Opsubgroupavcmcesetaconlyhaarintel _ -> false
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel _
              -> false
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel _ -> false
          | Opsubgroupavcmcesetinterdirectionpenaltyintel _ -> false
          | Opsubgroupavcmcesetintershapepenaltyintel _ -> false
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel _ -> false
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel _
              -> false
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel _ -> false
          | Opsubgroupavcrefconverttomcepayloadintel _ -> false
          | Opsubgroupavcrefconverttomceresultintel _ -> false
          | Opsubgroupavcrefevaluatewithdualreferenceintel _ -> false
          | Opsubgroupavcrefevaluatewithmultireferenceintel _ -> false
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel _ ->
              false
          | Opsubgroupavcrefevaluatewithsinglereferenceintel _ -> false
          | Opsubgroupavcrefsetbidirectionalmixdisableintel _ -> false
          | Opsubgroupavcrefsetbilinearfilterenableintel _ -> false
          | Opsubgroupavcsicconfigureipelumachromaintel _ -> false
          | Opsubgroupavcsicconfigureipelumaintel _ -> false
          | Opsubgroupavcsicconfigureskcintel _ -> false
          | Opsubgroupavcsicconverttomcepayloadintel _ -> false
          | Opsubgroupavcsicconverttomceresultintel _ -> false
          | Opsubgroupavcsicevaluateipeintel _ -> false
          | Opsubgroupavcsicevaluatewithdualreferenceintel _ -> false
          | Opsubgroupavcsicevaluatewithmultireferenceintel _ -> false
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel _ ->
              false
          | Opsubgroupavcsicevaluatewithsinglereferenceintel _ -> false
          | Opsubgroupavcsicgetbestipechromadistortionintel _ -> false
          | Opsubgroupavcsicgetbestipelumadistortionintel _ -> false
          | Opsubgroupavcsicgetinterrawsadsintel _ -> false
          | Opsubgroupavcsicgetipechromamodeintel _ -> false
          | Opsubgroupavcsicgetipelumashapeintel _ -> false
          | Opsubgroupavcsicgetmotionvectormaskintel _ -> false
          | Opsubgroupavcsicgetpackedipelumamodesintel _ -> false
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel _ -> false
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel _ -> false
          | Opsubgroupavcsicinitializeintel _ -> false
          | Opsubgroupavcsicsetbilinearfilterenableintel _ -> false
          | Opsubgroupavcsicsetblockbasedrawskipsadintel _ -> false
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel _ -> false
          | Opsubgroupavcsicsetintralumamodecostfunctionintel _ -> false
          | Opsubgroupavcsicsetintralumashapepenaltyintel _ -> false
          | Opsubgroupavcsicsetskcforwardtransformenableintel _ -> false
          | Optasksequenceasyncaltera _ -> false
          | Optasksequencecreatealtera _ -> false
          | Optasksequencegetaltera _ -> false
          | Optasksequencereleasealtera _ -> false
          | Optypeavcimedualreferencestreaminintel _ -> false
          | Optypeavcimepayloadintel _ -> false
          | Optypeavcimeresultdualreferencestreamoutintel _ -> false
          | Optypeavcimeresultintel _ -> false
          | Optypeavcimeresultsinglereferencestreamoutintel _ -> false
          | Optypeavcimesinglereferencestreaminintel _ -> false
          | Optypeavcmcepayloadintel _ -> false
          | Optypeavcmceresultintel _ -> false
          | Optypeavcrefpayloadintel _ -> false
          | Optypeavcrefresultintel _ -> false
          | Optypeavcsicpayloadintel _ -> false
          | Optypeavcsicresultintel _ -> false
          | Optypetasksequencealtera _ -> false
          | Optypevmeimageintel _ -> false
          | Opvmeimageintel _ -> false
          | Opwritepipeblockingaltera _ -> false
        let value =
          function
          | Opaliasdomaindeclintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 (t.name |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5911l in
              heading :: payload
          | Opaliasscopedeclintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.aliasdomain];
                 (t.name |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5912l in
              heading :: payload
          | Opaliasscopelistdeclintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.aliasscope1aliasscope2___
                   ~f:Operand_kind.Payload.Idref.value] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5913l in
              heading :: payload
          | Oparbitraryfloatacosintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.m1];
                 [Operand_kind.Payload.Literalinteger.value t.mout];
                 [Operand_kind.Payload.Literalinteger.value
                    t.enablesubnormals];
                 [Operand_kind.Payload.Literalinteger.value t.roundingmode];
                 [Operand_kind.Payload.Literalinteger.value
                    t.roundingaccuracy]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5875l in
              heading :: payload
          | Oparbitraryfloatacospiintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5876l in
              heading :: payload
          | Oparbitraryfloataddaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5846l in
              heading :: payload
          | Oparbitraryfloatasinintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5873l in
              heading :: payload
          | Oparbitraryfloatasinpiintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5874l in
              heading :: payload
          | Oparbitraryfloatatan2intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5879l in
              heading :: payload
          | Oparbitraryfloatatanintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5877l in
              heading :: payload
          | Oparbitraryfloatatanpiintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5878l in
              heading :: payload
          | Oparbitraryfloatcastaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5841l in
              heading :: payload
          | Oparbitraryfloatcastfromintaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.fromsign];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5842l in
              heading :: payload
          | Oparbitraryfloatcasttointaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.tosign];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5843l in
              heading :: payload
          | Oparbitraryfloatcbrtaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5857l in
              heading :: payload
          | Oparbitraryfloatcosintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5869l in
              heading :: payload
          | Oparbitraryfloatcospiintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5872l in
              heading :: payload
          | Oparbitraryfloatdivaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5849l in
              heading :: payload
          | Oparbitraryfloateqaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5854l in
              heading :: payload
          | Oparbitraryfloatexp10intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5866l in
              heading :: payload
          | Oparbitraryfloatexp2intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5865l in
              heading :: payload
          | Oparbitraryfloatexpintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5864l in
              heading :: payload
          | Oparbitraryfloatexpm1intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5867l in
              heading :: payload
          | Oparbitraryfloatgealtera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5851l in
              heading :: payload
          | Oparbitraryfloatgtaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5850l in
              heading :: payload
          | Oparbitraryfloathypotaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5858l in
              heading :: payload
          | Oparbitraryfloatlealtera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5853l in
              heading :: payload
          | Oparbitraryfloatlog10intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5862l in
              heading :: payload
          | Oparbitraryfloatlog1pintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5863l in
              heading :: payload
          | Oparbitraryfloatlog2intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5861l in
              heading :: payload
          | Oparbitraryfloatlogintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5860l in
              heading :: payload
          | Oparbitraryfloatltaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5852l in
              heading :: payload
          | Oparbitraryfloatmulaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5848l in
              heading :: payload
          | Oparbitraryfloatpowintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5880l in
              heading :: payload
          | Oparbitraryfloatpownintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.signofb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5882l in
              heading :: payload
          | Oparbitraryfloatpowrintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5881l in
              heading :: payload
          | Oparbitraryfloatrecipaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5855l in
              heading :: payload
          | Oparbitraryfloatrsqrtaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5856l in
              heading :: payload
          | Oparbitraryfloatsincosintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5870l in
              heading :: payload
          | Oparbitraryfloatsincospialtera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value
                    t.roundingaccuracy]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5840l in
              heading :: payload
          | Oparbitraryfloatsinintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5868l in
              heading :: payload
          | Oparbitraryfloatsinpiintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5871l in
              heading :: payload
          | Oparbitraryfloatsqrtaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5859l in
              heading :: payload
          | Oparbitraryfloatsubaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Literalinteger.value t.ma];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Literalinteger.value t.mb];
                 [Operand_kind.Payload.Literalinteger.value t.mresult];
                 [Operand_kind.Payload.Literalinteger.value t.subnormal];
                 [Operand_kind.Payload.Literalinteger.value t.rounding];
                 [Operand_kind.Payload.Literalinteger.value t.accuracy]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5847l in
              heading :: payload
          | Opasmcallintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.asm];
                 List.map t.argument ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5611l in
              heading :: payload
          | Opasmintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.asmtype];
                 [Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Literalstring.value t.asminstructions];
                 [Operand_kind.Payload.Literalstring.value t.constraints]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5610l in
              heading :: payload
          | Opasmtargetintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalstring.value t.asmtarget]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5609l in
              heading :: payload
          | Opconstantfunctionpointerintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.function_]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5600l in
              heading :: payload
          | Opcrossworkgroupcasttoptraltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5938l in
              heading :: payload
          | Opfixedcosaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5927l in
              heading :: payload
          | Opfixedcospialtera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5930l in
              heading :: payload
          | Opfixedexpaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5933l in
              heading :: payload
          | Opfixedlogaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5932l in
              heading :: payload
          | Opfixedrecipaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5924l in
              heading :: payload
          | Opfixedrsqrtaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5925l in
              heading :: payload
          | Opfixedsinaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5926l in
              heading :: payload
          | Opfixedsincosaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5928l in
              heading :: payload
          | Opfixedsincospialtera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5931l in
              heading :: payload
          | Opfixedsinpialtera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5929l in
              heading :: payload
          | Opfixedsqrtaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Literalinteger.value t.s];
                 [Operand_kind.Payload.Literalinteger.value t.i];
                 [Operand_kind.Payload.Literalinteger.value t.ri];
                 [Operand_kind.Payload.Literalinteger.value t.q];
                 [Operand_kind.Payload.Literalinteger.value t.o]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5923l in
              heading :: payload
          | Opfpgaregaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5949l in
              heading :: payload
          | Opfunctionpointercallintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.operand1 ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5601l in
              heading :: payload
          | Opptrcasttocrossworkgroupaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5934l in
              heading :: payload
          | Opreadpipeblockingaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5946l in
              heading :: payload
          | Opsubgroupavcbmeinitializeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srccoord];
                 [Operand_kind.Payload.Idref.value t.motionvectors];
                 [Operand_kind.Payload.Idref.value t.majorshapes];
                 [Operand_kind.Payload.Idref.value t.minorshapes];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.pixelresolution];
                 [Operand_kind.Payload.Idref.value t.bidirectionalweight];
                 [Operand_kind.Payload.Idref.value t.sadadjustment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5782l in
              heading :: payload
          | Opsubgroupavcfmeinitializeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srccoord];
                 [Operand_kind.Payload.Idref.value t.motionvectors];
                 [Operand_kind.Payload.Idref.value t.majorshapes];
                 [Operand_kind.Payload.Idref.value t.minorshapes];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.pixelresolution];
                 [Operand_kind.Payload.Idref.value t.sadadjustment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5781l in
              heading :: payload
          | Opsubgroupavcimeadjustrefoffsetintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.refoffset];
                 [Operand_kind.Payload.Idref.value t.srccoord];
                 [Operand_kind.Payload.Idref.value t.refwindowsize];
                 [Operand_kind.Payload.Idref.value t.imagesize]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5751l in
              heading :: payload
          | Opsubgroupavcimeconverttomcepayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5752l in
              heading :: payload
          | Opsubgroupavcimeconverttomceresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5765l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithdualreferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.fwdrefimage];
                 [Operand_kind.Payload.Idref.value t.bwdrefimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5758l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.fwdrefimage];
                 [Operand_kind.Payload.Idref.value t.bwdrefimage];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.streamincomponents]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5760l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.fwdrefimage];
                 [Operand_kind.Payload.Idref.value t.bwdrefimage];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.streamincomponents]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5764l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.fwdrefimage];
                 [Operand_kind.Payload.Idref.value t.bwdrefimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5762l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithsinglereferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.refimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5757l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.refimage];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.streamincomponents]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5759l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.refimage];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.streamincomponents]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5763l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.refimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5761l in
              heading :: payload
          | Opsubgroupavcimegetborderreachedintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.imageselect];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5776l in
              heading :: payload
          | Opsubgroupavcimegetdualreferencestreaminintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5767l in
              heading :: payload
          | Opsubgroupavcimegetsinglereferencestreaminintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5766l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.majorshape];
                 [Operand_kind.Payload.Idref.value t.direction]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5774l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.majorshape];
                 [Operand_kind.Payload.Idref.value t.direction]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5773l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.majorshape];
                 [Operand_kind.Payload.Idref.value t.direction]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5775l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.majorshape]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5771l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.majorshape]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5770l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload];
                 [Operand_kind.Payload.Idref.value t.majorshape]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5772l in
              heading :: payload
          | Opsubgroupavcimegettruncatedsearchindicationintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5777l in
              heading :: payload
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5778l in
              heading :: payload
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5780l in
              heading :: payload
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5779l in
              heading :: payload
          | Opsubgroupavcimeinitializeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srccoord];
                 [Operand_kind.Payload.Idref.value t.partitionmask];
                 [Operand_kind.Payload.Idref.value t.sadadjustment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5747l in
              heading :: payload
          | Opsubgroupavcimerefwindowsizeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.value t.dualref]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5750l in
              heading :: payload
          | Opsubgroupavcimesetdualreferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.fwdrefoffset];
                 [Operand_kind.Payload.Idref.value t.bwdrefoffset];
                 [Operand_kind.Payload.Idref.value t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5749l in
              heading :: payload
          | Opsubgroupavcimesetearlysearchterminationthresholdintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.threshold];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5755l in
              heading :: payload
          | Opsubgroupavcimesetmaxmotionvectorcountintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.maxmotionvectorcount];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5753l in
              heading :: payload
          | Opsubgroupavcimesetsinglereferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.refoffset];
                 [Operand_kind.Payload.Idref.value t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5748l in
              heading :: payload
          | Opsubgroupavcimesetunidirectionalmixdisableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5754l in
              heading :: payload
          | Opsubgroupavcimesetweightedsadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.packedsadweights];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5756l in
              heading :: payload
          | Opsubgroupavcimestripdualreferencestreamoutintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5769l in
              heading :: payload
          | Opsubgroupavcimestripsinglereferencestreamoutintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5768l in
              heading :: payload
          | Opsubgroupavcmceconverttoimepayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5732l in
              heading :: payload
          | Opsubgroupavcmceconverttoimeresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5733l in
              heading :: payload
          | Opsubgroupavcmceconverttorefpayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5734l in
              heading :: payload
          | Opsubgroupavcmceconverttorefresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5735l in
              heading :: payload
          | Opsubgroupavcmceconverttosicpayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5736l in
              heading :: payload
          | Opsubgroupavcmceconverttosicresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5737l in
              heading :: payload
          | Opsubgroupavcmcegetbestinterdistortionsintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5740l in
              heading :: payload
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5721l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel t
              ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.slicetype];
                 [Operand_kind.Payload.Idref.value t.qp]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5713l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.slicetype];
                 [Operand_kind.Payload.Idref.value t.qp]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5717l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.slicetype];
                 [Operand_kind.Payload.Idref.value t.qp]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5720l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.slicetype];
                 [Operand_kind.Payload.Idref.value t.qp]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5715l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5727l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.slicetype];
                 [Operand_kind.Payload.Idref.value t.qp]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5725l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.slicetype];
                 [Operand_kind.Payload.Idref.value t.qp]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5719l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5723l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5722l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5726l in
              heading :: payload
          | Opsubgroupavcmcegetinterdirectionsintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5743l in
              heading :: payload
          | Opsubgroupavcmcegetinterdistortionsintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5739l in
              heading :: payload
          | Opsubgroupavcmcegetintermajorshapeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5741l in
              heading :: payload
          | Opsubgroupavcmcegetinterminorshapeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5742l in
              heading :: payload
          | Opsubgroupavcmcegetintermotionvectorcountintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5744l in
              heading :: payload
          | Opsubgroupavcmcegetinterreferenceidsintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5745l in
              heading :: payload
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel t
              ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.packedreferenceids];
                 [Operand_kind.Payload.Idref.value
                    t.packedreferenceparameterfieldpolarities];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5746l in
              heading :: payload
          | Opsubgroupavcmcegetmotionvectorsintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5738l in
              heading :: payload
          | Opsubgroupavcmcesetaconlyhaarintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5728l in
              heading :: payload
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel t
              ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value
                    t.forwardreferencefieldpolarity];
                 [Operand_kind.Payload.Idref.value
                    t.backwardreferencefieldpolarity];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5731l in
              heading :: payload
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.referencebasepenalty];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5714l in
              heading :: payload
          | Opsubgroupavcmcesetinterdirectionpenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.directioncost];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5718l in
              heading :: payload
          | Opsubgroupavcmcesetintershapepenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.packedshapepenalty];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5716l in
              heading :: payload
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.packedcostcenterdelta];
                 [Operand_kind.Payload.Idref.value t.packedcosttable];
                 [Operand_kind.Payload.Idref.value t.costprecision];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5724l in
              heading :: payload
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel t
              ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.referencefieldpolarity];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5730l in
              heading :: payload
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sourcefieldpolarity];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5729l in
              heading :: payload
          | Opsubgroupavcrefconverttomcepayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5783l in
              heading :: payload
          | Opsubgroupavcrefconverttomceresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5790l in
              heading :: payload
          | Opsubgroupavcrefevaluatewithdualreferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.fwdrefimage];
                 [Operand_kind.Payload.Idref.value t.bwdrefimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5787l in
              heading :: payload
          | Opsubgroupavcrefevaluatewithmultireferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.packedreferenceids];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5788l in
              heading :: payload
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.packedreferenceids];
                 [Operand_kind.Payload.Idref.value
                    t.packedreferencefieldpolarities];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5789l in
              heading :: payload
          | Opsubgroupavcrefevaluatewithsinglereferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.refimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5786l in
              heading :: payload
          | Opsubgroupavcrefsetbidirectionalmixdisableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5784l in
              heading :: payload
          | Opsubgroupavcrefsetbilinearfilterenableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5785l in
              heading :: payload
          | Opsubgroupavcsicconfigureipelumachromaintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.lumaintrapartitionmask];
                 [Operand_kind.Payload.Idref.value
                    t.intraneighbouravailabilty];
                 [Operand_kind.Payload.Idref.value t.leftedgelumapixels];
                 [Operand_kind.Payload.Idref.value t.upperleftcornerlumapixel];
                 [Operand_kind.Payload.Idref.value t.upperedgelumapixels];
                 [Operand_kind.Payload.Idref.value t.upperrightedgelumapixels];
                 [Operand_kind.Payload.Idref.value t.leftedgechromapixels];
                 [Operand_kind.Payload.Idref.value
                    t.upperleftcornerchromapixel];
                 [Operand_kind.Payload.Idref.value t.upperedgechromapixels];
                 [Operand_kind.Payload.Idref.value t.sadadjustment];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5794l in
              heading :: payload
          | Opsubgroupavcsicconfigureipelumaintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.lumaintrapartitionmask];
                 [Operand_kind.Payload.Idref.value
                    t.intraneighbouravailabilty];
                 [Operand_kind.Payload.Idref.value t.leftedgelumapixels];
                 [Operand_kind.Payload.Idref.value t.upperleftcornerlumapixel];
                 [Operand_kind.Payload.Idref.value t.upperedgelumapixels];
                 [Operand_kind.Payload.Idref.value t.upperrightedgelumapixels];
                 [Operand_kind.Payload.Idref.value t.sadadjustment];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5793l in
              heading :: payload
          | Opsubgroupavcsicconfigureskcintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.skipblockpartitiontype];
                 [Operand_kind.Payload.Idref.value t.skipmotionvectormask];
                 [Operand_kind.Payload.Idref.value t.motionvectors];
                 [Operand_kind.Payload.Idref.value t.bidirectionalweight];
                 [Operand_kind.Payload.Idref.value t.sadadjustment];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5792l in
              heading :: payload
          | Opsubgroupavcsicconverttomcepayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5796l in
              heading :: payload
          | Opsubgroupavcsicconverttomceresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5808l in
              heading :: payload
          | Opsubgroupavcsicevaluateipeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5803l in
              heading :: payload
          | Opsubgroupavcsicevaluatewithdualreferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.fwdrefimage];
                 [Operand_kind.Payload.Idref.value t.bwdrefimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5805l in
              heading :: payload
          | Opsubgroupavcsicevaluatewithmultireferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.packedreferenceids];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5806l in
              heading :: payload
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.packedreferenceids];
                 [Operand_kind.Payload.Idref.value
                    t.packedreferencefieldpolarities];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5807l in
              heading :: payload
          | Opsubgroupavcsicevaluatewithsinglereferenceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srcimage];
                 [Operand_kind.Payload.Idref.value t.refimage];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5804l in
              heading :: payload
          | Opsubgroupavcsicgetbestipechromadistortionintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5811l in
              heading :: payload
          | Opsubgroupavcsicgetbestipelumadistortionintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5810l in
              heading :: payload
          | Opsubgroupavcsicgetinterrawsadsintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5816l in
              heading :: payload
          | Opsubgroupavcsicgetipechromamodeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5813l in
              heading :: payload
          | Opsubgroupavcsicgetipelumashapeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5809l in
              heading :: payload
          | Opsubgroupavcsicgetmotionvectormaskintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.skipblockpartitiontype];
                 [Operand_kind.Payload.Idref.value t.direction]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5795l in
              heading :: payload
          | Opsubgroupavcsicgetpackedipelumamodesintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5812l in
              heading :: payload
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5814l in
              heading :: payload
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5815l in
              heading :: payload
          | Opsubgroupavcsicinitializeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.srccoord]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5791l in
              heading :: payload
          | Opsubgroupavcsicsetbilinearfilterenableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5800l in
              heading :: payload
          | Opsubgroupavcsicsetblockbasedrawskipsadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.blockbasedskiptype];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5802l in
              heading :: payload
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.chromamodebasepenalty];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5799l in
              heading :: payload
          | Opsubgroupavcsicsetintralumamodecostfunctionintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.lumamodepenalty];
                 [Operand_kind.Payload.Idref.value t.lumapackedneighbormodes];
                 [Operand_kind.Payload.Idref.value t.lumapackednondcpenalty];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5798l in
              heading :: payload
          | Opsubgroupavcsicsetintralumashapepenaltyintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.packedshapepenalty];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5797l in
              heading :: payload
          | Opsubgroupavcsicsetskcforwardtransformenableintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.packedsadcoefficients];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5801l in
              heading :: payload
          | Optasksequenceasyncaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.sequence];
                 List.map t.arguments ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6164l in
              heading :: payload
          | Optasksequencecreatealtera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.function_];
                 [Operand_kind.Payload.Literalinteger.value t.pipelined];
                 [Operand_kind.Payload.Literalinteger.value
                    t.usestallenableclusters];
                 [Operand_kind.Payload.Literalinteger.value t.getcapacity];
                 [Operand_kind.Payload.Literalinteger.value t.asynccapacity]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6163l in
              heading :: payload
          | Optasksequencegetaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sequence]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6165l in
              heading :: payload
          | Optasksequencereleasealtera t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.sequence]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6166l in
              heading :: payload
          | Optypeavcimedualreferencestreaminintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5710l in
              heading :: payload
          | Optypeavcimepayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5701l in
              heading :: payload
          | Optypeavcimeresultdualreferencestreamoutintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5708l in
              heading :: payload
          | Optypeavcimeresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5706l in
              heading :: payload
          | Optypeavcimeresultsinglereferencestreamoutintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5707l in
              heading :: payload
          | Optypeavcimesinglereferencestreaminintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5709l in
              heading :: payload
          | Optypeavcmcepayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5704l in
              heading :: payload
          | Optypeavcmceresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5705l in
              heading :: payload
          | Optypeavcrefpayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5702l in
              heading :: payload
          | Optypeavcrefresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5711l in
              heading :: payload
          | Optypeavcsicpayloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5703l in
              heading :: payload
          | Optypeavcsicresultintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5712l in
              heading :: payload
          | Optypetasksequencealtera t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6199l in
              heading :: payload
          | Optypevmeimageintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.imagetype]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5700l in
              heading :: payload
          | Opvmeimageintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.imagetype];
                 [Operand_kind.Payload.Idref.value t.sampler]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5699l in
              heading :: payload
          | Opwritepipeblockingaltera t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5947l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opaliasdomaindeclintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Memoryaccessaliasingintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 (t.name |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opaliasscopedeclintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Memoryaccessaliasingintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.aliasdomain];
                 (t.name |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opaliasscopelistdeclintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Memoryaccessaliasingintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 List.map t.aliasscope1aliasscope2___
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatacosintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.m1];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mout];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.enablesubnormals];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.roundingmode];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.roundingaccuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatacospiintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloataddaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatasinintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatasinpiintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatatan2intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatatanintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatatanpiintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatcastaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatcastfromintaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.fromsign];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatcasttointaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.tosign];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatcbrtaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatcosintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatcospiintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatdivaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloateqaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatexp10intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatexp2intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatexpintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatexpm1intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatgealtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatgtaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloathypotaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatlealtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatlog10intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatlog1pintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatlog2intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatlogintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatltaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatmulaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatpowintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatpownintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.signofb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatpowrintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatrecipaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatrsqrtaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatsincosintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatsincospialtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.roundingaccuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatsinintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatsinpiintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatsqrtaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oparbitraryfloatsubaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ma];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opasmcallintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Asmintel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.asm];
                 List.map t.argument
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opasmintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Asmintel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.asmtype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.target];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.asminstructions];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.constraints]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opasmtargetintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Asmintel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.asmtarget]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconstantfunctionpointerintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Functionpointersintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.function_]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcrossworkgroupcasttoptraltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Usmstorageclassesaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedcosaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedcospialtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedexpaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedlogaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedrecipaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedrsqrtaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedsinaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedsincosaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedsincospialtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedsinpialtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfixedsqrtaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfpgaregaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Fpgaregaltera] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfunctionpointercallintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Functionpointersintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 List.map t.operand1
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opptrcasttocrossworkgroupaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Usmstorageclassesaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreadpipeblockingaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Blockingpipesaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcbmeinitializeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srccoord];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.motionvectors];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.majorshapes];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.minorshapes];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.pixelresolution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bidirectionalweight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sadadjustment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcfmeinitializeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srccoord];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.motionvectors];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.majorshapes];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.minorshapes];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.pixelresolution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sadadjustment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeadjustrefoffsetintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srccoord];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refwindowsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.imagesize]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeconverttomcepayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeconverttomceresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeevaluatewithdualreferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.streamincomponents]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.streamincomponents]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeevaluatewithsinglereferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.streamincomponents]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.streamincomponents]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetborderreachedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.imageselect];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetdualreferencestreaminintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetsinglereferencestreaminintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.majorshape];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.majorshape];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.majorshape];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.majorshape]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.majorshape]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.majorshape]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegettruncatedsearchindicationintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimeinitializeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srccoord];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.partitionmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sadadjustment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimerefwindowsizeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dualref]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimesetdualreferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fwdrefoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bwdrefoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimesetearlysearchterminationthresholdintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.threshold];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimesetmaxmotionvectorcountintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.maxmotionvectorcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimesetsinglereferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimesetunidirectionalmixdisableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimesetweightedsadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedsadweights];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimestripdualreferencestreamoutintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcimestripsinglereferencestreamoutintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmceconverttoimepayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmceconverttoimeresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmceconverttorefpayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmceconverttorefresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmceconverttosicpayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmceconverttosicresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetbestinterdistortionsintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel t
              ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationchromaintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetinterdirectionsintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetinterdistortionsintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetintermajorshapeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetinterminorshapeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetintermotionvectorcountintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetinterreferenceidsintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel t
              ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedreferenceparameterfieldpolarities];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcegetmotionvectorsintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcesetaconlyhaarintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel t
              ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.forwardreferencefieldpolarity];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.backwardreferencefieldpolarity];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencebasepenalty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcesetinterdirectionpenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.directioncost];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcesetintershapepenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedshapepenalty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedcostcenterdelta];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedcosttable];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.costprecision];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel t
              ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencefieldpolarity];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sourcefieldpolarity];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcrefconverttomcepayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcrefconverttomceresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcrefevaluatewithdualreferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcrefevaluatewithmultireferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedreferencefieldpolarities];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcrefevaluatewithsinglereferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcrefsetbidirectionalmixdisableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcrefsetbilinearfilterenableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicconfigureipelumachromaintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationchromaintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.lumaintrapartitionmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intraneighbouravailabilty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.leftedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.upperleftcornerlumapixel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.upperedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.upperrightedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.leftedgechromapixels];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.upperleftcornerchromapixel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.upperedgechromapixels];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sadadjustment];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicconfigureipelumaintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.lumaintrapartitionmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intraneighbouravailabilty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.leftedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.upperleftcornerlumapixel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.upperedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.upperrightedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sadadjustment];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicconfigureskcintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.skipblockpartitiontype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.skipmotionvectormask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.motionvectors];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bidirectionalweight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sadadjustment];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicconverttomcepayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicconverttomceresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicevaluateipeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicevaluatewithdualreferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicevaluatewithmultireferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedreferencefieldpolarities];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicevaluatewithsinglereferenceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetbestipechromadistortionintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetbestipelumadistortionintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetinterrawsadsintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetipechromamodeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationchromaintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetipelumashapeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetmotionvectormaskintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.skipblockpartitiontype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetpackedipelumamodesintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicinitializeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srccoord]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicsetbilinearfilterenableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicsetblockbasedrawskipsadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockbasedskiptype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationchromaintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.chromamodebasepenalty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicsetintralumamodecostfunctionintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
                       Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.lumamodepenalty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.lumapackedneighbormodes];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.lumapackednondcpenalty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicsetintralumashapepenaltyintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedshapepenalty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupavcsicsetskcforwardtransformenableintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedsadcoefficients];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optasksequenceasyncaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tasksequencealtera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.sequence];
                 List.map t.arguments
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optasksequencecreatealtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tasksequencealtera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.function_];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.pipelined];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.usestallenableclusters];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.getcapacity];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.asynccapacity]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optasksequencegetaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tasksequencealtera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sequence]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optasksequencereleasealtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tasksequencealtera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.sequence]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcimedualreferencestreaminintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcimepayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcimeresultdualreferencestreamoutintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcimeresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcimeresultsinglereferencestreamoutintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcimesinglereferencestreaminintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcmcepayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcmceresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcrefpayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcrefresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcsicpayloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeavcsicresultintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypetasksequencealtera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tasksequencealtera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypevmeimageintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.imagetype]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opvmeimageintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.imagetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.sampler]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opwritepipeblockingaltera t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Blockingpipesaltera]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Oparbitraryfloatacosintel _ -> true
          | Oparbitraryfloatacospiintel _ -> true
          | Oparbitraryfloataddaltera _ -> true
          | Oparbitraryfloatasinintel _ -> true
          | Oparbitraryfloatasinpiintel _ -> true
          | Oparbitraryfloatatan2intel _ -> true
          | Oparbitraryfloatatanintel _ -> true
          | Oparbitraryfloatatanpiintel _ -> true
          | Oparbitraryfloatcastaltera _ -> true
          | Oparbitraryfloatcastfromintaltera _ -> true
          | Oparbitraryfloatcasttointaltera _ -> true
          | Oparbitraryfloatcbrtaltera _ -> true
          | Oparbitraryfloatcosintel _ -> true
          | Oparbitraryfloatcospiintel _ -> true
          | Oparbitraryfloatdivaltera _ -> true
          | Oparbitraryfloateqaltera _ -> true
          | Oparbitraryfloatexp10intel _ -> true
          | Oparbitraryfloatexp2intel _ -> true
          | Oparbitraryfloatexpintel _ -> true
          | Oparbitraryfloatexpm1intel _ -> true
          | Oparbitraryfloatgealtera _ -> true
          | Oparbitraryfloatgtaltera _ -> true
          | Oparbitraryfloathypotaltera _ -> true
          | Oparbitraryfloatlealtera _ -> true
          | Oparbitraryfloatlog10intel _ -> true
          | Oparbitraryfloatlog1pintel _ -> true
          | Oparbitraryfloatlog2intel _ -> true
          | Oparbitraryfloatlogintel _ -> true
          | Oparbitraryfloatltaltera _ -> true
          | Oparbitraryfloatmulaltera _ -> true
          | Oparbitraryfloatpowintel _ -> true
          | Oparbitraryfloatpownintel _ -> true
          | Oparbitraryfloatpowrintel _ -> true
          | Oparbitraryfloatrecipaltera _ -> true
          | Oparbitraryfloatrsqrtaltera _ -> true
          | Oparbitraryfloatsincosintel _ -> true
          | Oparbitraryfloatsincospialtera _ -> true
          | Oparbitraryfloatsinintel _ -> true
          | Oparbitraryfloatsinpiintel _ -> true
          | Oparbitraryfloatsqrtaltera _ -> true
          | Oparbitraryfloatsubaltera _ -> true
          | Opasmcallintel _ -> true
          | Opasmintel _ -> true
          | Opasmtargetintel _ -> true
          | Opcrossworkgroupcasttoptraltera _ -> true
          | Opfixedcosaltera _ -> true
          | Opfixedcospialtera _ -> true
          | Opfixedexpaltera _ -> true
          | Opfixedlogaltera _ -> true
          | Opfixedrecipaltera _ -> true
          | Opfixedrsqrtaltera _ -> true
          | Opfixedsinaltera _ -> true
          | Opfixedsincosaltera _ -> true
          | Opfixedsincospialtera _ -> true
          | Opfixedsinpialtera _ -> true
          | Opfixedsqrtaltera _ -> true
          | Opfpgaregaltera _ -> true
          | Opptrcasttocrossworkgroupaltera _ -> true
          | Opreadpipeblockingaltera _ -> true
          | Opsubgroupavcbmeinitializeintel _ -> true
          | Opsubgroupavcfmeinitializeintel _ -> true
          | Opsubgroupavcimeadjustrefoffsetintel _ -> true
          | Opsubgroupavcimeconverttomcepayloadintel _ -> true
          | Opsubgroupavcimeconverttomceresultintel _ -> true
          | Opsubgroupavcimeevaluatewithdualreferenceintel _ -> true
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel _ -> true
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel _ ->
              true
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel _ -> true
          | Opsubgroupavcimeevaluatewithsinglereferenceintel _ -> true
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel _ ->
              true
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel _ ->
              true
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel _ ->
              true
          | Opsubgroupavcimegetborderreachedintel _ -> true
          | Opsubgroupavcimegetdualreferencestreaminintel _ -> true
          | Opsubgroupavcimegetsinglereferencestreaminintel _ -> true
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              _ -> true
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              _ -> true
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              _ -> true
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              _ -> true
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              _ -> true
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              _ -> true
          | Opsubgroupavcimegettruncatedsearchindicationintel _ -> true
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel _ ->
              true
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel _ ->
              true
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel _ ->
              true
          | Opsubgroupavcimeinitializeintel _ -> true
          | Opsubgroupavcimerefwindowsizeintel _ -> true
          | Opsubgroupavcimesetdualreferenceintel _ -> true
          | Opsubgroupavcimesetearlysearchterminationthresholdintel _ -> true
          | Opsubgroupavcimesetmaxmotionvectorcountintel _ -> true
          | Opsubgroupavcimesetsinglereferenceintel _ -> true
          | Opsubgroupavcimesetunidirectionalmixdisableintel _ -> true
          | Opsubgroupavcimesetweightedsadintel _ -> true
          | Opsubgroupavcimestripdualreferencestreamoutintel _ -> true
          | Opsubgroupavcimestripsinglereferencestreamoutintel _ -> true
          | Opsubgroupavcmceconverttoimepayloadintel _ -> true
          | Opsubgroupavcmceconverttoimeresultintel _ -> true
          | Opsubgroupavcmceconverttorefpayloadintel _ -> true
          | Opsubgroupavcmceconverttorefresultintel _ -> true
          | Opsubgroupavcmceconverttosicpayloadintel _ -> true
          | Opsubgroupavcmceconverttosicresultintel _ -> true
          | Opsubgroupavcmcegetbestinterdistortionsintel _ -> true
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel _ -> true
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel _
              -> true
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel _ -> true
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel _ ->
              true
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel _ -> true
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel _ ->
              true
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel _ -> true
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel _ -> true
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel _ -> true
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel _ -> true
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel _ -> true
          | Opsubgroupavcmcegetinterdirectionsintel _ -> true
          | Opsubgroupavcmcegetinterdistortionsintel _ -> true
          | Opsubgroupavcmcegetintermajorshapeintel _ -> true
          | Opsubgroupavcmcegetinterminorshapeintel _ -> true
          | Opsubgroupavcmcegetintermotionvectorcountintel _ -> true
          | Opsubgroupavcmcegetinterreferenceidsintel _ -> true
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel _
              -> true
          | Opsubgroupavcmcegetmotionvectorsintel _ -> true
          | Opsubgroupavcmcesetaconlyhaarintel _ -> true
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel _
              -> true
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel _ -> true
          | Opsubgroupavcmcesetinterdirectionpenaltyintel _ -> true
          | Opsubgroupavcmcesetintershapepenaltyintel _ -> true
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel _ -> true
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel _
              -> true
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel _ -> true
          | Opsubgroupavcrefconverttomcepayloadintel _ -> true
          | Opsubgroupavcrefconverttomceresultintel _ -> true
          | Opsubgroupavcrefevaluatewithdualreferenceintel _ -> true
          | Opsubgroupavcrefevaluatewithmultireferenceintel _ -> true
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel _ ->
              true
          | Opsubgroupavcrefevaluatewithsinglereferenceintel _ -> true
          | Opsubgroupavcrefsetbidirectionalmixdisableintel _ -> true
          | Opsubgroupavcrefsetbilinearfilterenableintel _ -> true
          | Opsubgroupavcsicconfigureipelumachromaintel _ -> true
          | Opsubgroupavcsicconfigureipelumaintel _ -> true
          | Opsubgroupavcsicconfigureskcintel _ -> true
          | Opsubgroupavcsicconverttomcepayloadintel _ -> true
          | Opsubgroupavcsicconverttomceresultintel _ -> true
          | Opsubgroupavcsicevaluateipeintel _ -> true
          | Opsubgroupavcsicevaluatewithdualreferenceintel _ -> true
          | Opsubgroupavcsicevaluatewithmultireferenceintel _ -> true
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel _ ->
              true
          | Opsubgroupavcsicevaluatewithsinglereferenceintel _ -> true
          | Opsubgroupavcsicgetbestipechromadistortionintel _ -> true
          | Opsubgroupavcsicgetbestipelumadistortionintel _ -> true
          | Opsubgroupavcsicgetinterrawsadsintel _ -> true
          | Opsubgroupavcsicgetipechromamodeintel _ -> true
          | Opsubgroupavcsicgetipelumashapeintel _ -> true
          | Opsubgroupavcsicgetmotionvectormaskintel _ -> true
          | Opsubgroupavcsicgetpackedipelumamodesintel _ -> true
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel _ -> true
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel _ -> true
          | Opsubgroupavcsicinitializeintel _ -> true
          | Opsubgroupavcsicsetbilinearfilterenableintel _ -> true
          | Opsubgroupavcsicsetblockbasedrawskipsadintel _ -> true
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel _ -> true
          | Opsubgroupavcsicsetintralumamodecostfunctionintel _ -> true
          | Opsubgroupavcsicsetintralumashapepenaltyintel _ -> true
          | Opsubgroupavcsicsetskcforwardtransformenableintel _ -> true
          | Optasksequenceasyncaltera _ -> true
          | Optasksequencecreatealtera _ -> true
          | Optasksequencegetaltera _ -> true
          | Optasksequencereleasealtera _ -> true
          | Optypeavcimedualreferencestreaminintel _ -> true
          | Optypeavcimepayloadintel _ -> true
          | Optypeavcimeresultdualreferencestreamoutintel _ -> true
          | Optypeavcimeresultintel _ -> true
          | Optypeavcimeresultsinglereferencestreamoutintel _ -> true
          | Optypeavcimesinglereferencestreaminintel _ -> true
          | Optypeavcmcepayloadintel _ -> true
          | Optypeavcmceresultintel _ -> true
          | Optypeavcrefpayloadintel _ -> true
          | Optypeavcrefresultintel _ -> true
          | Optypeavcsicpayloadintel _ -> true
          | Optypeavcsicresultintel _ -> true
          | Optypetasksequencealtera _ -> true
          | Optypevmeimageintel _ -> true
          | Opvmeimageintel _ -> true
          | Opwritepipeblockingaltera _ -> true
          | Opaliasdomaindeclintel t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_intel_memory_access_aliasing]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresult.satisfies_extensions
                     t.idresult];
                 (t.name |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opaliasscopedeclintel t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_intel_memory_access_aliasing]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresult.satisfies_extensions
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.aliasdomain];
                 (t.name |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opaliasscopelistdeclintel t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_intel_memory_access_aliasing]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresult.satisfies_extensions
                     t.idresult];
                 List.map t.aliasscope1aliasscope2___
                   ~f:Operand_kind.Payload.Idref.satisfies_extensions] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opconstantfunctionpointerintel t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_intel_function_pointers]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.function_]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opfunctionpointercallintel t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_intel_function_pointers]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 List.map t.operand1
                   ~f:Operand_kind.Payload.Idref.satisfies_extensions] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opaliasdomaindeclintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 (t.name |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opaliasscopedeclintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.aliasdomain];
                 (t.name |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opaliasscopelistdeclintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.aliasscope1aliasscope2___
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatacosintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.m1];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mout];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.enablesubnormals];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.roundingmode];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.roundingaccuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatacospiintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloataddaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatasinintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatasinpiintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatatan2intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatatanintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatatanpiintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatcastaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatcastfromintaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.fromsign];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatcasttointaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.tosign];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatcbrtaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatcosintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatcospiintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatdivaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloateqaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatexp10intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatexp2intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatexpintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatexpm1intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatgealtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatgtaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloathypotaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatlealtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatlog10intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatlog1pintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatlog2intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatlogintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatltaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatmulaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatpowintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatpownintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.signofb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatpowrintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatrecipaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatrsqrtaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatsincosintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatsincospialtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.roundingaccuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatsinintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatsinpiintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatsqrtaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oparbitraryfloatsubaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ma];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.mb];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.mresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.subnormal];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.rounding];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.accuracy]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opasmcallintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.asm];
                 List.map t.argument
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opasmintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.asmtype];
                 [Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Literalstring.satisfies_version
                    t.asminstructions];
                 [Operand_kind.Payload.Literalstring.satisfies_version
                    t.constraints]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opasmtargetintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_version
                    t.asmtarget]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstantfunctionpointerintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.function_]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcrossworkgroupcasttoptraltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedcosaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedcospialtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedexpaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedlogaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedrecipaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedrsqrtaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedsinaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedsincosaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedsincospialtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedsinpialtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfixedsqrtaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.s];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.i];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ri];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.q];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.o]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfpgaregaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunctionpointercallintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.operand1
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opptrcasttocrossworkgroupaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opreadpipeblockingaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcbmeinitializeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srccoord];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.motionvectors];
                 [Operand_kind.Payload.Idref.satisfies_version t.majorshapes];
                 [Operand_kind.Payload.Idref.satisfies_version t.minorshapes];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.pixelresolution];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.bidirectionalweight];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sadadjustment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcfmeinitializeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srccoord];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.motionvectors];
                 [Operand_kind.Payload.Idref.satisfies_version t.majorshapes];
                 [Operand_kind.Payload.Idref.satisfies_version t.minorshapes];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.pixelresolution];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sadadjustment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeadjustrefoffsetintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.refoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.srccoord];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.refwindowsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.imagesize]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeconverttomcepayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeconverttomceresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeevaluatewithdualreferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.streamincomponents]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.streamincomponents]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeevaluatewithsinglereferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.streamincomponents]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.streamincomponents]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetborderreachedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.imageselect];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetdualreferencestreaminintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetsinglereferencestreaminintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version t.majorshape];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version t.majorshape];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version t.majorshape];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version t.majorshape]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version t.majorshape]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 [Operand_kind.Payload.Idref.satisfies_version t.majorshape]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegettruncatedsearchindicationintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimeinitializeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srccoord];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.partitionmask];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sadadjustment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimerefwindowsizeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.satisfies_version t.dualref]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimesetdualreferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.fwdrefoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.bwdrefoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimesetearlysearchterminationthresholdintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.threshold];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimesetmaxmotionvectorcountintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.maxmotionvectorcount];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimesetsinglereferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.refoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.searchwindowconfig];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimesetunidirectionalmixdisableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimesetweightedsadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedsadweights];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimestripdualreferencestreamoutintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcimestripsinglereferencestreamoutintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmceconverttoimepayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmceconverttoimeresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmceconverttorefpayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmceconverttorefresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmceconverttosicpayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmceconverttosicresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetbestinterdistortionsintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel t
              ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.slicetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.qp]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetinterdirectionsintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetinterdistortionsintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetintermajorshapeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetinterminorshapeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetintermotionvectorcountintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetinterreferenceidsintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel t
              ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedreferenceparameterfieldpolarities];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcegetmotionvectorsintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcesetaconlyhaarintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel t
              ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.forwardreferencefieldpolarity];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.backwardreferencefieldpolarity];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencebasepenalty];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcesetinterdirectionpenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.directioncost];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcesetintershapepenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedshapepenalty];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedcostcenterdelta];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedcosttable];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.costprecision];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel t
              ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencefieldpolarity];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sourcefieldpolarity];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcrefconverttomcepayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcrefconverttomceresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcrefevaluatewithdualreferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcrefevaluatewithmultireferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedreferencefieldpolarities];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcrefevaluatewithsinglereferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcrefsetbidirectionalmixdisableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcrefsetbilinearfilterenableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicconfigureipelumachromaintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.lumaintrapartitionmask];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.intraneighbouravailabilty];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.leftedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.upperleftcornerlumapixel];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.upperedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.upperrightedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.leftedgechromapixels];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.upperleftcornerchromapixel];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.upperedgechromapixels];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sadadjustment];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicconfigureipelumaintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.lumaintrapartitionmask];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.intraneighbouravailabilty];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.leftedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.upperleftcornerlumapixel];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.upperedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.upperrightedgelumapixels];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sadadjustment];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicconfigureskcintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.skipblockpartitiontype];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.skipmotionvectormask];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.motionvectors];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.bidirectionalweight];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sadadjustment];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicconverttomcepayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicconverttomceresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicevaluateipeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicevaluatewithdualreferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.fwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.bwdrefimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicevaluatewithmultireferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedreferenceids];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedreferencefieldpolarities];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicevaluatewithsinglereferenceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.refimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetbestipechromadistortionintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetbestipelumadistortionintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetinterrawsadsintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetipechromamodeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetipelumashapeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetmotionvectormaskintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.skipblockpartitiontype];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetpackedipelumamodesintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicinitializeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.srccoord]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicsetbilinearfilterenableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicsetblockbasedrawskipsadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.blockbasedskiptype];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.chromamodebasepenalty];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicsetintralumamodecostfunctionintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.lumamodepenalty];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.lumapackedneighbormodes];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.lumapackednondcpenalty];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicsetintralumashapepenaltyintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedshapepenalty];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupavcsicsetskcforwardtransformenableintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedsadcoefficients];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optasksequenceasyncaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.sequence];
                 List.map t.arguments
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optasksequencecreatealtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.function_];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.pipelined];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.usestallenableclusters];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.getcapacity];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.asynccapacity]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optasksequencegetaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sequence]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optasksequencereleasealtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.sequence]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcimedualreferencestreaminintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcimepayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcimeresultdualreferencestreamoutintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcimeresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcimeresultsinglereferencestreamoutintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcimesinglereferencestreaminintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcmcepayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcmceresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcrefpayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcrefresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcsicpayloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeavcsicresultintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypetasksequencealtera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypevmeimageintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.imagetype]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opvmeimageintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.imagetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampler]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opwritepipeblockingaltera t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Extension =
      struct
        type t =
          | Opconditionalextensionintel of
          {
          condition: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t } 
          | Opextension of {
          name: Operand_kind.Payload.Literalstring.t } 
          | Opextinst of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          set: Operand_kind.Payload.Idref.t ;
          instruction: Operand_kind.Payload.Literalextinstinteger.t ;
          operand1operand2___: Operand_kind.Payload.Idref.t list } 
          | Opextinstimport of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          name: Operand_kind.Payload.Literalstring.t } 
          | Opextinstwithforwardrefskhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          set: Operand_kind.Payload.Idref.t ;
          instruction: Operand_kind.Payload.Literalextinstinteger.t ;
          operand1operand2___: Operand_kind.Payload.Idref.t list } [@@deriving
                                                                    compare, sexp_of]
        let provisional =
          function
          | Opconditionalextensionintel _ -> true
          | Opextension _ -> false
          | Opextinst _ -> false
          | Opextinstimport _ -> false
          | Opextinstwithforwardrefskhr _ -> false
        let value =
          function
          | Opconditionalextensionintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.condition];
                 [Operand_kind.Payload.Literalstring.value t.name]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6248l in
              heading :: payload
          | Opextension t ->
              let payload =
                ([[Operand_kind.Payload.Literalstring.value t.name]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 10l in
              heading :: payload
          | Opextinst t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.set];
                 [Operand_kind.Payload.Literalextinstinteger.value
                    t.instruction];
                 List.map t.operand1operand2___
                   ~f:Operand_kind.Payload.Idref.value] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 12l in
              heading :: payload
          | Opextinstimport t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalstring.value t.name]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 11l in
              heading :: payload
          | Opextinstwithforwardrefskhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.set];
                 [Operand_kind.Payload.Literalextinstinteger.value
                    t.instruction];
                 List.map t.operand1operand2___
                   ~f:Operand_kind.Payload.Idref.value] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4433l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opextension _ -> true
          | Opextinst _ -> true
          | Opextinstimport _ -> true
          | Opextinstwithforwardrefskhr _ -> true
          | Opconditionalextensionintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Specconditionalintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.condition];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.name]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Opconditionalextensionintel _ -> true
          | Opextension _ -> true
          | Opextinst _ -> true
          | Opextinstimport _ -> true
          | Opextinstwithforwardrefskhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_relaxed_extended_instruction]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.set];
                 [Operand_kind.Payload.Literalextinstinteger.satisfies_extensions
                    t.instruction];
                 List.map t.operand1operand2___
                   ~f:Operand_kind.Payload.Idref.satisfies_extensions] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opconditionalextensionintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.condition];
                 [Operand_kind.Payload.Literalstring.satisfies_version t.name]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opextension t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Literalstring.satisfies_version
                     t.name]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opextinst t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.set];
                 [Operand_kind.Payload.Literalextinstinteger.satisfies_version
                    t.instruction];
                 List.map t.operand1operand2___
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opextinstimport t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_version t.name]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opextinstwithforwardrefskhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.set];
                 [Operand_kind.Payload.Literalextinstinteger.satisfies_version
                    t.instruction];
                 List.map t.operand1operand2___
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Function =
      struct
        type t =
          | Opcooperativematrixperelementopnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          func: Operand_kind.Payload.Idref.t ;
          operands: Operand_kind.Payload.Idref.t list } 
          | Opfunction of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          functioncontrol: Operand_kind.Payload.Functioncontrol.t ;
          functiontype: Operand_kind.Payload.Idref.t } 
          | Opfunctioncall of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          function_: Operand_kind.Payload.Idref.t ;
          argument0argument1___: Operand_kind.Payload.Idref.t list } 
          | Opfunctionend 
          | Opfunctionparameter of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } [@@deriving
                                                        compare, sexp_of]
        let provisional =
          function
          | Opcooperativematrixperelementopnv _ -> false
          | Opfunction _ -> false
          | Opfunctioncall _ -> false
          | Opfunctionend -> false
          | Opfunctionparameter _ -> false
        let value =
          function
          | Opcooperativematrixperelementopnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.matrix];
                 [Operand_kind.Payload.Idref.value t.func];
                 List.map t.operands ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5369l in
              heading :: payload
          | Opfunction t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Functioncontrol.value
                    t.functioncontrol];
                 [Operand_kind.Payload.Idref.value t.functiontype]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 54l in
              heading :: payload
          | Opfunctioncall t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.function_];
                 List.map t.argument0argument1___
                   ~f:Operand_kind.Payload.Idref.value] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 57l in
              heading :: payload
          | Opfunctionend ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 56l in
              [heading]
          | Opfunctionparameter t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 55l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opfunction _ -> true
          | Opfunctioncall _ -> true
          | Opfunctionend -> true
          | Opfunctionparameter _ -> true
          | Opcooperativematrixperelementopnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixperelementoperationsnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.func];
                 List.map t.operands
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opcooperativematrixperelementopnv _ -> true
          | Opfunction _ -> true
          | Opfunctioncall _ -> true
          | Opfunctionend -> true
          | Opfunctionparameter _ -> true
        let satisfies_version t ~version =
          match t with
          | Opcooperativematrixperelementopnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_version t.func];
                 List.map t.operands
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunction t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Functioncontrol.satisfies_version
                    t.functioncontrol];
                 [Operand_kind.Payload.Idref.satisfies_version t.functiontype]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunctioncall t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.function_];
                 List.map t.argument0argument1___
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunctionend ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opfunctionparameter t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Graph =
      struct
        type t =
          | Opgrapharm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opgraphconstantarm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          graphconstantid: Operand_kind.Payload.Literalinteger.t } 
          | Opgraphendarm 
          | Opgraphentrypointarm of
          {
          graph: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t ;
          interface: Operand_kind.Payload.Idref.t list } 
          | Opgraphinputarm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          inputindex: Operand_kind.Payload.Idref.t ;
          elementindex: Operand_kind.Payload.Idref.t list } 
          | Opgraphsetoutputarm of
          {
          value: Operand_kind.Payload.Idref.t ;
          outputindex: Operand_kind.Payload.Idref.t ;
          elementindex: Operand_kind.Payload.Idref.t list } [@@deriving
                                                              compare, sexp_of]
        let provisional =
          function
          | Opgrapharm _ -> false
          | Opgraphconstantarm _ -> false
          | Opgraphendarm -> false
          | Opgraphentrypointarm _ -> false
          | Opgraphinputarm _ -> false
          | Opgraphsetoutputarm _ -> false
        let value =
          function
          | Opgrapharm t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4183l in
              heading :: payload
          | Opgraphconstantarm t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalinteger.value t.graphconstantid]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4181l in
              heading :: payload
          | Opgraphendarm ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 4186l in
              [heading]
          | Opgraphentrypointarm t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.graph];
                 [Operand_kind.Payload.Literalstring.value t.name];
                 List.map t.interface ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4182l in
              heading :: payload
          | Opgraphinputarm t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.inputindex];
                 List.map t.elementindex ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4184l in
              heading :: payload
          | Opgraphsetoutputarm t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.outputindex];
                 List.map t.elementindex ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4185l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opgrapharm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Grapharm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgraphconstantarm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Grapharm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.graphconstantid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgraphendarm ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Grapharm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Opgraphentrypointarm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Grapharm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.graph];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.name];
                 List.map t.interface
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgraphinputarm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Grapharm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.inputindex];
                 List.map t.elementindex
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgraphsetoutputarm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Grapharm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.outputindex];
                 List.map t.elementindex
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opgrapharm _ -> true
          | Opgraphconstantarm _ -> true
          | Opgraphendarm -> true
          | Opgraphentrypointarm _ -> true
          | Opgraphinputarm _ -> true
          | Opgraphsetoutputarm _ -> true
        let satisfies_version t ~version =
          match t with
          | Opgrapharm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgraphconstantarm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.graphconstantid]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgraphendarm ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opgraphentrypointarm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.graph];
                 [Operand_kind.Payload.Literalstring.satisfies_version t.name];
                 List.map t.interface
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgraphinputarm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.inputindex];
                 List.map t.elementindex
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgraphsetoutputarm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.outputindex];
                 List.map t.elementindex
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Group =
      struct
        type t =
          | Opgroupall of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupany of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupasynccopy of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          destination: Operand_kind.Payload.Idref.t ;
          source: Operand_kind.Payload.Idref.t ;
          numelements: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t ;
          event: Operand_kind.Payload.Idref.t } 
          | Opgroupbitwiseandkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupbitwiseorkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupbitwisexorkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupbroadcast of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          localid: Operand_kind.Payload.Idref.t } 
          | Opgroupfadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfaddnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfmaxnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfminnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfmulkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupiadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupiaddnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupimulkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgrouplogicalandkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgrouplogicalorkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgrouplogicalxorkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformrotatekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupsmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupsmaxnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupsmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupsminnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupumax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupumaxnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupumin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupuminnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupwaitevents of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          numevents: Operand_kind.Payload.Idref.t ;
          eventslist: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockloadintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dstpointer: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockloadtransformintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dstpointer: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockloadtransposeintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dstpointer: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockprefetchintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockstoreintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcpointer: Operand_kind.Payload.Idref.t ;
          dstbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupallequalkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupallkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupanykhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupballotkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupblockprefetchintel of
          {
          ptr: Operand_kind.Payload.Idref.t ;
          numbytes: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opsubgroupblockreadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          ptr: Operand_kind.Payload.Idref.t } 
          | Opsubgroupblockwriteintel of
          {
          ptr: Operand_kind.Payload.Idref.t ;
          data: Operand_kind.Payload.Idref.t } 
          | Opsubgroupfirstinvocationkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opsubgroupimageblockreadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupimageblockwriteintel of
          {
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          data: Operand_kind.Payload.Idref.t } 
          | Opsubgroupimagemediablockreadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          width: Operand_kind.Payload.Idref.t ;
          height: Operand_kind.Payload.Idref.t } 
          | Opsubgroupimagemediablockwriteintel of
          {
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          width: Operand_kind.Payload.Idref.t ;
          height: Operand_kind.Payload.Idref.t ;
          data: Operand_kind.Payload.Idref.t } 
          | Opsubgroupmatrixmultiplyaccumulateintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          kdim: Operand_kind.Payload.Idref.t ;
          matrixa: Operand_kind.Payload.Idref.t ;
          matrixb: Operand_kind.Payload.Idref.t ;
          matrixc: Operand_kind.Payload.Idref.t ;
          matrixmultiplyaccumulateoperands:
            Operand_kind.Payload.Matrixmultiplyaccumulateoperands.t option }
          
          | Opsubgroupreadinvocationkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opsubgroupshuffledownintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          current: Operand_kind.Payload.Idref.t ;
          next: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t } 
          | Opsubgroupshuffleintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          data: Operand_kind.Payload.Idref.t ;
          invocationid: Operand_kind.Payload.Idref.t } 
          | Opsubgroupshuffleupintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          previous: Operand_kind.Payload.Idref.t ;
          current: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t } 
          | Opsubgroupshufflexorintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          data: Operand_kind.Payload.Idref.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opuntypedgroupasynccopykhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idref.t ;
          destination: Operand_kind.Payload.Idref.t ;
          source: Operand_kind.Payload.Idref.t ;
          elementnumbytes: Operand_kind.Payload.Idref.t ;
          numelements: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t ;
          event: Operand_kind.Payload.Idref.t ;
          destinationmemoryoperands:
            Operand_kind.Payload.Memoryaccess.t option ;
          sourcememoryoperands: Operand_kind.Payload.Memoryaccess.t option } 
        [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opgroupall _ -> false
          | Opgroupany _ -> false
          | Opgroupasynccopy _ -> false
          | Opgroupbitwiseandkhr _ -> false
          | Opgroupbitwiseorkhr _ -> false
          | Opgroupbitwisexorkhr _ -> false
          | Opgroupbroadcast _ -> false
          | Opgroupfadd _ -> false
          | Opgroupfaddnonuniformamd _ -> false
          | Opgroupfmax _ -> false
          | Opgroupfmaxnonuniformamd _ -> false
          | Opgroupfmin _ -> false
          | Opgroupfminnonuniformamd _ -> false
          | Opgroupfmulkhr _ -> false
          | Opgroupiadd _ -> false
          | Opgroupiaddnonuniformamd _ -> false
          | Opgroupimulkhr _ -> false
          | Opgrouplogicalandkhr _ -> false
          | Opgrouplogicalorkhr _ -> false
          | Opgrouplogicalxorkhr _ -> false
          | Opgroupnonuniformrotatekhr _ -> false
          | Opgroupsmax _ -> false
          | Opgroupsmaxnonuniformamd _ -> false
          | Opgroupsmin _ -> false
          | Opgroupsminnonuniformamd _ -> false
          | Opgroupumax _ -> false
          | Opgroupumaxnonuniformamd _ -> false
          | Opgroupumin _ -> false
          | Opgroupuminnonuniformamd _ -> false
          | Opgroupwaitevents _ -> false
          | Opsubgroup2dblockloadintel _ -> false
          | Opsubgroup2dblockloadtransformintel _ -> false
          | Opsubgroup2dblockloadtransposeintel _ -> false
          | Opsubgroup2dblockprefetchintel _ -> false
          | Opsubgroup2dblockstoreintel _ -> false
          | Opsubgroupallequalkhr _ -> false
          | Opsubgroupallkhr _ -> false
          | Opsubgroupanykhr _ -> false
          | Opsubgroupballotkhr _ -> false
          | Opsubgroupblockprefetchintel _ -> false
          | Opsubgroupblockreadintel _ -> false
          | Opsubgroupblockwriteintel _ -> false
          | Opsubgroupfirstinvocationkhr _ -> false
          | Opsubgroupimageblockreadintel _ -> false
          | Opsubgroupimageblockwriteintel _ -> false
          | Opsubgroupimagemediablockreadintel _ -> false
          | Opsubgroupimagemediablockwriteintel _ -> false
          | Opsubgroupmatrixmultiplyaccumulateintel _ -> false
          | Opsubgroupreadinvocationkhr _ -> false
          | Opsubgroupshuffledownintel _ -> false
          | Opsubgroupshuffleintel _ -> false
          | Opsubgroupshuffleupintel _ -> false
          | Opsubgroupshufflexorintel _ -> false
          | Opuntypedgroupasynccopykhr _ -> false
        let value =
          function
          | Opgroupall t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 261l in
              heading :: payload
          | Opgroupany t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 262l in
              heading :: payload
          | Opgroupasynccopy t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.destination];
                 [Operand_kind.Payload.Idref.value t.source];
                 [Operand_kind.Payload.Idref.value t.numelements];
                 [Operand_kind.Payload.Idref.value t.stride];
                 [Operand_kind.Payload.Idref.value t.event]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 259l in
              heading :: payload
          | Opgroupbitwiseandkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6403l in
              heading :: payload
          | Opgroupbitwiseorkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6404l in
              heading :: payload
          | Opgroupbitwisexorkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6405l in
              heading :: payload
          | Opgroupbroadcast t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.localid]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 263l in
              heading :: payload
          | Opgroupfadd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 265l in
              heading :: payload
          | Opgroupfaddnonuniformamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5001l in
              heading :: payload
          | Opgroupfmax t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 269l in
              heading :: payload
          | Opgroupfmaxnonuniformamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5005l in
              heading :: payload
          | Opgroupfmin t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 266l in
              heading :: payload
          | Opgroupfminnonuniformamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5002l in
              heading :: payload
          | Opgroupfmulkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6402l in
              heading :: payload
          | Opgroupiadd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 264l in
              heading :: payload
          | Opgroupiaddnonuniformamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5000l in
              heading :: payload
          | Opgroupimulkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6401l in
              heading :: payload
          | Opgrouplogicalandkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6406l in
              heading :: payload
          | Opgrouplogicalorkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6407l in
              heading :: payload
          | Opgrouplogicalxorkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6408l in
              heading :: payload
          | Opgroupnonuniformrotatekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.delta];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4431l in
              heading :: payload
          | Opgroupsmax t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 271l in
              heading :: payload
          | Opgroupsmaxnonuniformamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5007l in
              heading :: payload
          | Opgroupsmin t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 268l in
              heading :: payload
          | Opgroupsminnonuniformamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5004l in
              heading :: payload
          | Opgroupumax t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 270l in
              heading :: payload
          | Opgroupumaxnonuniformamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5006l in
              heading :: payload
          | Opgroupumin t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 267l in
              heading :: payload
          | Opgroupuminnonuniformamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5003l in
              heading :: payload
          | Opgroupwaitevents t ->
              let payload =
                ([[Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.numevents];
                 [Operand_kind.Payload.Idref.value t.eventslist]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 260l in
              heading :: payload
          | Opsubgroup2dblockloadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.elementsize];
                 [Operand_kind.Payload.Idref.value t.blockwidth];
                 [Operand_kind.Payload.Idref.value t.blockheight];
                 [Operand_kind.Payload.Idref.value t.blockcount];
                 [Operand_kind.Payload.Idref.value t.srcbasepointer];
                 [Operand_kind.Payload.Idref.value t.memorywidth];
                 [Operand_kind.Payload.Idref.value t.memoryheight];
                 [Operand_kind.Payload.Idref.value t.memorypitch];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dstpointer]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6231l in
              heading :: payload
          | Opsubgroup2dblockloadtransformintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.elementsize];
                 [Operand_kind.Payload.Idref.value t.blockwidth];
                 [Operand_kind.Payload.Idref.value t.blockheight];
                 [Operand_kind.Payload.Idref.value t.blockcount];
                 [Operand_kind.Payload.Idref.value t.srcbasepointer];
                 [Operand_kind.Payload.Idref.value t.memorywidth];
                 [Operand_kind.Payload.Idref.value t.memoryheight];
                 [Operand_kind.Payload.Idref.value t.memorypitch];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dstpointer]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6232l in
              heading :: payload
          | Opsubgroup2dblockloadtransposeintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.elementsize];
                 [Operand_kind.Payload.Idref.value t.blockwidth];
                 [Operand_kind.Payload.Idref.value t.blockheight];
                 [Operand_kind.Payload.Idref.value t.blockcount];
                 [Operand_kind.Payload.Idref.value t.srcbasepointer];
                 [Operand_kind.Payload.Idref.value t.memorywidth];
                 [Operand_kind.Payload.Idref.value t.memoryheight];
                 [Operand_kind.Payload.Idref.value t.memorypitch];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dstpointer]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6233l in
              heading :: payload
          | Opsubgroup2dblockprefetchintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.elementsize];
                 [Operand_kind.Payload.Idref.value t.blockwidth];
                 [Operand_kind.Payload.Idref.value t.blockheight];
                 [Operand_kind.Payload.Idref.value t.blockcount];
                 [Operand_kind.Payload.Idref.value t.srcbasepointer];
                 [Operand_kind.Payload.Idref.value t.memorywidth];
                 [Operand_kind.Payload.Idref.value t.memoryheight];
                 [Operand_kind.Payload.Idref.value t.memorypitch];
                 [Operand_kind.Payload.Idref.value t.coordinate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6234l in
              heading :: payload
          | Opsubgroup2dblockstoreintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.elementsize];
                 [Operand_kind.Payload.Idref.value t.blockwidth];
                 [Operand_kind.Payload.Idref.value t.blockheight];
                 [Operand_kind.Payload.Idref.value t.blockcount];
                 [Operand_kind.Payload.Idref.value t.srcpointer];
                 [Operand_kind.Payload.Idref.value t.dstbasepointer];
                 [Operand_kind.Payload.Idref.value t.memorywidth];
                 [Operand_kind.Payload.Idref.value t.memoryheight];
                 [Operand_kind.Payload.Idref.value t.memorypitch];
                 [Operand_kind.Payload.Idref.value t.coordinate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6235l in
              heading :: payload
          | Opsubgroupallequalkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4430l in
              heading :: payload
          | Opsubgroupallkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4428l in
              heading :: payload
          | Opsubgroupanykhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4429l in
              heading :: payload
          | Opsubgroupballotkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4421l in
              heading :: payload
          | Opsubgroupblockprefetchintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.ptr];
                 [Operand_kind.Payload.Idref.value t.numbytes];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6221l in
              heading :: payload
          | Opsubgroupblockreadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.ptr]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5575l in
              heading :: payload
          | Opsubgroupblockwriteintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.ptr];
                 [Operand_kind.Payload.Idref.value t.data]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5576l in
              heading :: payload
          | Opsubgroupfirstinvocationkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4422l in
              heading :: payload
          | Opsubgroupimageblockreadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5577l in
              heading :: payload
          | Opsubgroupimageblockwriteintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.data]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5578l in
              heading :: payload
          | Opsubgroupimagemediablockreadintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.width];
                 [Operand_kind.Payload.Idref.value t.height]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5580l in
              heading :: payload
          | Opsubgroupimagemediablockwriteintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.width];
                 [Operand_kind.Payload.Idref.value t.height];
                 [Operand_kind.Payload.Idref.value t.data]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5581l in
              heading :: payload
          | Opsubgroupmatrixmultiplyaccumulateintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.kdim];
                 [Operand_kind.Payload.Idref.value t.matrixa];
                 [Operand_kind.Payload.Idref.value t.matrixb];
                 [Operand_kind.Payload.Idref.value t.matrixc];
                 (t.matrixmultiplyaccumulateoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Matrixmultiplyaccumulateoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6237l in
              heading :: payload
          | Opsubgroupreadinvocationkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.index]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4432l in
              heading :: payload
          | Opsubgroupshuffledownintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.current];
                 [Operand_kind.Payload.Idref.value t.next];
                 [Operand_kind.Payload.Idref.value t.delta]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5572l in
              heading :: payload
          | Opsubgroupshuffleintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.data];
                 [Operand_kind.Payload.Idref.value t.invocationid]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5571l in
              heading :: payload
          | Opsubgroupshuffleupintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.previous];
                 [Operand_kind.Payload.Idref.value t.current];
                 [Operand_kind.Payload.Idref.value t.delta]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5573l in
              heading :: payload
          | Opsubgroupshufflexorintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.data];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5574l in
              heading :: payload
          | Opuntypedgroupasynccopykhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.execution];
                 [Operand_kind.Payload.Idref.value t.destination];
                 [Operand_kind.Payload.Idref.value t.source];
                 [Operand_kind.Payload.Idref.value t.elementnumbytes];
                 [Operand_kind.Payload.Idref.value t.numelements];
                 [Operand_kind.Payload.Idref.value t.stride];
                 [Operand_kind.Payload.Idref.value t.event];
                 (t.destinationmemoryoperands |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list;
                 (t.sourcememoryoperands |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4434l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opgroupall t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupany t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupasynccopy t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.destination];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.source];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numelements];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.stride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.event]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupbitwiseandkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupuniformarithmetickhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupbitwiseorkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupuniformarithmetickhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupbitwisexorkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupuniformarithmetickhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupbroadcast t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.localid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupfadd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupfaddnonuniformamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupfmax t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupfmaxnonuniformamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupfmin t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupfminnonuniformamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupfmulkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupuniformarithmetickhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupiadd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupiaddnonuniformamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupimulkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupuniformarithmetickhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgrouplogicalandkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupuniformarithmetickhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgrouplogicalorkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupuniformarithmetickhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgrouplogicalxorkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupuniformarithmetickhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformrotatekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformrotatekhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.delta];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupsmax t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupsmaxnonuniformamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupsmin t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupsminnonuniformamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupumax t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupumaxnonuniformamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupumin t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupuminnonuniformamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groups] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupwaitevents t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idscope.satisfies_capabilities
                     t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numevents];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.eventslist]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroup2dblockloadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroup2dblockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.dstpointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroup2dblockloadtransformintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroup2dblocktransformintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.dstpointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroup2dblockloadtransposeintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroup2dblocktransposeintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.dstpointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroup2dblockprefetchintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroup2dblockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroup2dblockstoreintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroup2dblockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.srcpointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.dstbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupallequalkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupvotekhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupallkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupvotekhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupanykhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupvotekhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupballotkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupballotkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupblockprefetchintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupbufferprefetchintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.ptr];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numbytes];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupblockreadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupbufferblockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.ptr]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupblockwriteintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupbufferblockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.ptr];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.data]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupfirstinvocationkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupballotkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupimageblockreadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupimageblockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupimageblockwriteintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupimageblockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.data]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupimagemediablockreadintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupimagemediablockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.width];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.height]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupimagemediablockwriteintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupimagemediablockiointel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.width];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.height];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.data]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupmatrixmultiplyaccumulateintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupmatrixmultiplyaccumulateintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.kdim];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrixa];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrixb];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrixc];
                 (t.matrixmultiplyaccumulateoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Matrixmultiplyaccumulateoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupreadinvocationkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupballotkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.index]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupshuffledownintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupshuffleintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.current];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.next];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.delta]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupshuffleintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupshuffleintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.data];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.invocationid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupshuffleupintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupshuffleintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.previous];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.current];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.delta]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsubgroupshufflexorintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Subgroupshuffleintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.data];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuntypedgroupasynccopykhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.destination];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.source];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.elementnumbytes];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numelements];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.stride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.event];
                 (t.destinationmemoryoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list;
                 (t.sourcememoryoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Opgroupall _ -> true
          | Opgroupany _ -> true
          | Opgroupasynccopy _ -> true
          | Opgroupbitwiseandkhr _ -> true
          | Opgroupbitwiseorkhr _ -> true
          | Opgroupbitwisexorkhr _ -> true
          | Opgroupbroadcast _ -> true
          | Opgroupfadd _ -> true
          | Opgroupfmax _ -> true
          | Opgroupfmin _ -> true
          | Opgroupfmulkhr _ -> true
          | Opgroupiadd _ -> true
          | Opgroupimulkhr _ -> true
          | Opgrouplogicalandkhr _ -> true
          | Opgrouplogicalorkhr _ -> true
          | Opgrouplogicalxorkhr _ -> true
          | Opgroupnonuniformrotatekhr _ -> true
          | Opgroupsmax _ -> true
          | Opgroupsmin _ -> true
          | Opgroupumax _ -> true
          | Opgroupumin _ -> true
          | Opgroupwaitevents _ -> true
          | Opsubgroup2dblockloadintel _ -> true
          | Opsubgroup2dblockloadtransformintel _ -> true
          | Opsubgroup2dblockloadtransposeintel _ -> true
          | Opsubgroup2dblockprefetchintel _ -> true
          | Opsubgroup2dblockstoreintel _ -> true
          | Opsubgroupblockprefetchintel _ -> true
          | Opsubgroupblockreadintel _ -> true
          | Opsubgroupblockwriteintel _ -> true
          | Opsubgroupimageblockreadintel _ -> true
          | Opsubgroupimageblockwriteintel _ -> true
          | Opsubgroupimagemediablockreadintel _ -> true
          | Opsubgroupimagemediablockwriteintel _ -> true
          | Opsubgroupmatrixmultiplyaccumulateintel _ -> true
          | Opsubgroupshuffledownintel _ -> true
          | Opsubgroupshuffleintel _ -> true
          | Opsubgroupshuffleupintel _ -> true
          | Opsubgroupshufflexorintel _ -> true
          | Opuntypedgroupasynccopykhr _ -> true
          | Opgroupfaddnonuniformamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_extensions
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opgroupfmaxnonuniformamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_extensions
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opgroupfminnonuniformamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_extensions
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opgroupiaddnonuniformamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_extensions
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opgroupsmaxnonuniformamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_extensions
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opgroupsminnonuniformamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_extensions
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opgroupumaxnonuniformamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_extensions
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opgroupuminnonuniformamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_extensions
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opsubgroupallequalkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_subgroup_vote] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opsubgroupallkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_subgroup_vote] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opsubgroupanykhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_subgroup_vote] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opsubgroupballotkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opsubgroupfirstinvocationkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opsubgroupreadinvocationkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_shader_ballot] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.value];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.index]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opgroupall t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupany t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupasynccopy t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.destination];
                 [Operand_kind.Payload.Idref.satisfies_version t.source];
                 [Operand_kind.Payload.Idref.satisfies_version t.numelements];
                 [Operand_kind.Payload.Idref.satisfies_version t.stride];
                 [Operand_kind.Payload.Idref.satisfies_version t.event]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupbitwiseandkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupbitwiseorkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupbitwisexorkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupbroadcast t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.localid]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupfadd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupfaddnonuniformamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupfmax t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupfmaxnonuniformamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupfmin t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupfminnonuniformamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupfmulkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupiadd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupiaddnonuniformamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupimulkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgrouplogicalandkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgrouplogicalorkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgrouplogicalxorkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformrotatekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.delta];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupsmax t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupsmaxnonuniformamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupsmin t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupsminnonuniformamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupumax t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupumaxnonuniformamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupumin t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupuminnonuniformamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupwaitevents t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.numevents];
                 [Operand_kind.Payload.Idref.satisfies_version t.eventslist]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroup2dblockloadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.srcbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dstpointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroup2dblockloadtransformintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.srcbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dstpointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroup2dblockloadtransposeintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.srcbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dstpointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroup2dblockprefetchintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.srcbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroup2dblockstoreintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.elementsize];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockwidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.blockcount];
                 [Operand_kind.Payload.Idref.satisfies_version t.srcpointer];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.dstbasepointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorywidth];
                 [Operand_kind.Payload.Idref.satisfies_version t.memoryheight];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorypitch];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupallequalkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupallkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupanykhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupballotkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupblockprefetchintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.ptr];
                 [Operand_kind.Payload.Idref.satisfies_version t.numbytes];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opsubgroupblockreadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.ptr]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupblockwriteintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.ptr];
                 [Operand_kind.Payload.Idref.satisfies_version t.data]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupfirstinvocationkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupimageblockreadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupimageblockwriteintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.data]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupimagemediablockreadintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.width];
                 [Operand_kind.Payload.Idref.satisfies_version t.height]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupimagemediablockwriteintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.width];
                 [Operand_kind.Payload.Idref.satisfies_version t.height];
                 [Operand_kind.Payload.Idref.satisfies_version t.data]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupmatrixmultiplyaccumulateintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.kdim];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrixa];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrixb];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrixc];
                 (t.matrixmultiplyaccumulateoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Matrixmultiplyaccumulateoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opsubgroupreadinvocationkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.index]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupshuffledownintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.current];
                 [Operand_kind.Payload.Idref.satisfies_version t.next];
                 [Operand_kind.Payload.Idref.satisfies_version t.delta]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupshuffleintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.data];
                 [Operand_kind.Payload.Idref.satisfies_version t.invocationid]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupshuffleupintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.previous];
                 [Operand_kind.Payload.Idref.satisfies_version t.current];
                 [Operand_kind.Payload.Idref.satisfies_version t.delta]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsubgroupshufflexorintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.data];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opuntypedgroupasynccopykhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.destination];
                 [Operand_kind.Payload.Idref.satisfies_version t.source];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.elementnumbytes];
                 [Operand_kind.Payload.Idref.satisfies_version t.numelements];
                 [Operand_kind.Payload.Idref.satisfies_version t.stride];
                 [Operand_kind.Payload.Idref.satisfies_version t.event];
                 (t.destinationmemoryoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list;
                 (t.sourcememoryoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
      end
    module Image =
      struct
        type t =
          | Opcolorattachmentreadext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          attachment: Operand_kind.Payload.Idref.t ;
          sample: Operand_kind.Payload.Idref.t option } 
          | Opconverthandletoimageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconverthandletosampledimageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconverthandletosamplerintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opdepthattachmentreadext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sample: Operand_kind.Payload.Idref.t option } 
          | Opimage of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchgathersadqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          targetsampledimage: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          referencesampledimage: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchgatherssdqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          targetsampledimage: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          referencesampledimage: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchsadqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          target: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          reference: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchssdqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          target: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          reference: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchwindowsadqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          targetsampledimage: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          referencesampledimage: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchwindowssdqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          targetsampledimage: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          referencesampledimage: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageboxfilterqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          texture: Operand_kind.Payload.Idref.t ;
          coordinates: Operand_kind.Payload.Idref.t ;
          boxsize: Operand_kind.Payload.Idref.t } 
          | Opimagedrefgather of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagefetch of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagegather of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          component: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagequeryformat of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerylevels of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerylod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Opimagequeryorder of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerysamples of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerysize of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerysizelod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          levelofdetail: Operand_kind.Payload.Idref.t } 
          | Opimageread of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampledrefexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesampledrefimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesamplefootprintnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          granularity: Operand_kind.Payload.Idref.t ;
          coarse: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleprojdrefexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesampleprojdrefimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleprojexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesampleprojimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleweightedqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          texture: Operand_kind.Payload.Idref.t ;
          coordinates: Operand_kind.Payload.Idref.t ;
          weights: Operand_kind.Payload.Idref.t } 
          | Opimagesparsedrefgather of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsefetch of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsegather of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          component: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparseread of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsesampledrefexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesparsesampledrefimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsesampleexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesparsesampleimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsesampleprojdrefexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesparsesampleprojdrefimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsesampleprojexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesparsesampleprojimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsetexelsresident of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          residentcode: Operand_kind.Payload.Idref.t } 
          | Opimagewrite of
          {
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          texel: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opsampledimage of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          sampler: Operand_kind.Payload.Idref.t } 
          | Opstencilattachmentreadext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sample: Operand_kind.Payload.Idref.t option } [@@deriving
                                                          compare, sexp_of]
        let provisional =
          function
          | Opcolorattachmentreadext _ -> false
          | Opconverthandletoimageintel _ -> true
          | Opconverthandletosampledimageintel _ -> true
          | Opconverthandletosamplerintel _ -> true
          | Opdepthattachmentreadext _ -> false
          | Opimage _ -> false
          | Opimageblockmatchgathersadqcom _ -> false
          | Opimageblockmatchgatherssdqcom _ -> false
          | Opimageblockmatchsadqcom _ -> false
          | Opimageblockmatchssdqcom _ -> false
          | Opimageblockmatchwindowsadqcom _ -> false
          | Opimageblockmatchwindowssdqcom _ -> false
          | Opimageboxfilterqcom _ -> false
          | Opimagedrefgather _ -> false
          | Opimagefetch _ -> false
          | Opimagegather _ -> false
          | Opimagequeryformat _ -> false
          | Opimagequerylevels _ -> false
          | Opimagequerylod _ -> false
          | Opimagequeryorder _ -> false
          | Opimagequerysamples _ -> false
          | Opimagequerysize _ -> false
          | Opimagequerysizelod _ -> false
          | Opimageread _ -> false
          | Opimagesampledrefexplicitlod _ -> false
          | Opimagesampledrefimplicitlod _ -> false
          | Opimagesampleexplicitlod _ -> false
          | Opimagesamplefootprintnv _ -> false
          | Opimagesampleimplicitlod _ -> false
          | Opimagesampleprojdrefexplicitlod _ -> false
          | Opimagesampleprojdrefimplicitlod _ -> false
          | Opimagesampleprojexplicitlod _ -> false
          | Opimagesampleprojimplicitlod _ -> false
          | Opimagesampleweightedqcom _ -> false
          | Opimagesparsedrefgather _ -> false
          | Opimagesparsefetch _ -> false
          | Opimagesparsegather _ -> false
          | Opimagesparseread _ -> false
          | Opimagesparsesampledrefexplicitlod _ -> false
          | Opimagesparsesampledrefimplicitlod _ -> false
          | Opimagesparsesampleexplicitlod _ -> false
          | Opimagesparsesampleimplicitlod _ -> false
          | Opimagesparsesampleprojdrefexplicitlod _ -> false
          | Opimagesparsesampleprojdrefimplicitlod _ -> false
          | Opimagesparsesampleprojexplicitlod _ -> false
          | Opimagesparsesampleprojimplicitlod _ -> false
          | Opimagesparsetexelsresident _ -> false
          | Opimagewrite _ -> false
          | Opsampledimage _ -> false
          | Opstencilattachmentreadext _ -> false
        let value =
          function
          | Opcolorattachmentreadext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.attachment];
                 (t.sample |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4160l in
              heading :: payload
          | Opconverthandletoimageintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6529l in
              heading :: payload
          | Opconverthandletosampledimageintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6531l in
              heading :: payload
          | Opconverthandletosamplerintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6530l in
              heading :: payload
          | Opdepthattachmentreadext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 (t.sample |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4161l in
              heading :: payload
          | Opimage t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 100l in
              heading :: payload
          | Opimageblockmatchgathersadqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.targetsampledimage];
                 [Operand_kind.Payload.Idref.value t.targetcoordinates];
                 [Operand_kind.Payload.Idref.value t.referencesampledimage];
                 [Operand_kind.Payload.Idref.value t.referencecoordinates];
                 [Operand_kind.Payload.Idref.value t.blocksize]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4503l in
              heading :: payload
          | Opimageblockmatchgatherssdqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.targetsampledimage];
                 [Operand_kind.Payload.Idref.value t.targetcoordinates];
                 [Operand_kind.Payload.Idref.value t.referencesampledimage];
                 [Operand_kind.Payload.Idref.value t.referencecoordinates];
                 [Operand_kind.Payload.Idref.value t.blocksize]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4502l in
              heading :: payload
          | Opimageblockmatchsadqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Idref.value t.targetcoordinates];
                 [Operand_kind.Payload.Idref.value t.reference];
                 [Operand_kind.Payload.Idref.value t.referencecoordinates];
                 [Operand_kind.Payload.Idref.value t.blocksize]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4483l in
              heading :: payload
          | Opimageblockmatchssdqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Idref.value t.targetcoordinates];
                 [Operand_kind.Payload.Idref.value t.reference];
                 [Operand_kind.Payload.Idref.value t.referencecoordinates];
                 [Operand_kind.Payload.Idref.value t.blocksize]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4482l in
              heading :: payload
          | Opimageblockmatchwindowsadqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.targetsampledimage];
                 [Operand_kind.Payload.Idref.value t.targetcoordinates];
                 [Operand_kind.Payload.Idref.value t.referencesampledimage];
                 [Operand_kind.Payload.Idref.value t.referencecoordinates];
                 [Operand_kind.Payload.Idref.value t.blocksize]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4501l in
              heading :: payload
          | Opimageblockmatchwindowssdqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.targetsampledimage];
                 [Operand_kind.Payload.Idref.value t.targetcoordinates];
                 [Operand_kind.Payload.Idref.value t.referencesampledimage];
                 [Operand_kind.Payload.Idref.value t.referencecoordinates];
                 [Operand_kind.Payload.Idref.value t.blocksize]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4500l in
              heading :: payload
          | Opimageboxfilterqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.texture];
                 [Operand_kind.Payload.Idref.value t.coordinates];
                 [Operand_kind.Payload.Idref.value t.boxsize]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4481l in
              heading :: payload
          | Opimagedrefgather t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 97l in
              heading :: payload
          | Opimagefetch t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 95l in
              heading :: payload
          | Opimagegather t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.component];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 96l in
              heading :: payload
          | Opimagequeryformat t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 101l in
              heading :: payload
          | Opimagequerylevels t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 106l in
              heading :: payload
          | Opimagequerylod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 105l in
              heading :: payload
          | Opimagequeryorder t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 102l in
              heading :: payload
          | Opimagequerysamples t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 107l in
              heading :: payload
          | Opimagequerysize t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 104l in
              heading :: payload
          | Opimagequerysizelod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.levelofdetail]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 103l in
              heading :: payload
          | Opimageread t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 98l in
              heading :: payload
          | Opimagesampledrefexplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 [Operand_kind.Payload.Imageoperands.value t.imageoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 90l in
              heading :: payload
          | Opimagesampledrefimplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 89l in
              heading :: payload
          | Opimagesampleexplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Imageoperands.value t.imageoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 88l in
              heading :: payload
          | Opimagesamplefootprintnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.granularity];
                 [Operand_kind.Payload.Idref.value t.coarse];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5283l in
              heading :: payload
          | Opimagesampleimplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 87l in
              heading :: payload
          | Opimagesampleprojdrefexplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 [Operand_kind.Payload.Imageoperands.value t.imageoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 94l in
              heading :: payload
          | Opimagesampleprojdrefimplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 93l in
              heading :: payload
          | Opimagesampleprojexplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Imageoperands.value t.imageoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 92l in
              heading :: payload
          | Opimagesampleprojimplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 91l in
              heading :: payload
          | Opimagesampleweightedqcom t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.texture];
                 [Operand_kind.Payload.Idref.value t.coordinates];
                 [Operand_kind.Payload.Idref.value t.weights]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4480l in
              heading :: payload
          | Opimagesparsedrefgather t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 315l in
              heading :: payload
          | Opimagesparsefetch t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 313l in
              heading :: payload
          | Opimagesparsegather t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.component];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 314l in
              heading :: payload
          | Opimagesparseread t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 320l in
              heading :: payload
          | Opimagesparsesampledrefexplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 [Operand_kind.Payload.Imageoperands.value t.imageoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 308l in
              heading :: payload
          | Opimagesparsesampledrefimplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 307l in
              heading :: payload
          | Opimagesparsesampleexplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Imageoperands.value t.imageoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 306l in
              heading :: payload
          | Opimagesparsesampleimplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 305l in
              heading :: payload
          | Opimagesparsesampleprojdrefexplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 [Operand_kind.Payload.Imageoperands.value t.imageoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 312l in
              heading :: payload
          | Opimagesparsesampleprojdrefimplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.dref];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 311l in
              heading :: payload
          | Opimagesparsesampleprojexplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Imageoperands.value t.imageoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 310l in
              heading :: payload
          | Opimagesparsesampleprojimplicitlod t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledimage];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 309l in
              heading :: payload
          | Opimagesparsetexelsresident t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.residentcode]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 316l in
              heading :: payload
          | Opimagewrite t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.texel];
                 (t.imageoperands |>
                    (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 99l in
              heading :: payload
          | Opsampledimage t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.sampler]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 86l in
              heading :: payload
          | Opstencilattachmentreadext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 (t.sample |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4162l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opimage _ -> true
          | Opimagefetch _ -> true
          | Opimageread _ -> true
          | Opimagesampleexplicitlod _ -> true
          | Opimagewrite _ -> true
          | Opsampledimage _ -> true
          | Opcolorattachmentreadext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tileimagecolorreadaccessext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.attachment];
                 (t.sample |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opconverthandletoimageintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlessimagesintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconverthandletosampledimageintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlessimagesintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconverthandletosamplerintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlessimagesintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opdepthattachmentreadext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tileimagedepthreadaccessext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 (t.sample |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimageblockmatchgathersadqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Textureblockmatch2qcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetsampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencesampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimageblockmatchgatherssdqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Textureblockmatch2qcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetsampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencesampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimageblockmatchsadqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Textureblockmatchqcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.target];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reference];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimageblockmatchssdqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Textureblockmatchqcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.target];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reference];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimageblockmatchwindowsadqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Textureblockmatch2qcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetsampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencesampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimageblockmatchwindowssdqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Textureblockmatch2qcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetsampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencesampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimageboxfilterqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Textureboxfilterqcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.texture];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.boxsize]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagedrefgather t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagegather t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.component];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagequeryformat t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagequerylevels t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel;
                       Operand_kind.Payload.Capability.Imagequery] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagequerylod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Imagequery] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagequeryorder t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagequerysamples t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel;
                       Operand_kind.Payload.Capability.Imagequery] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagequerysize t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel;
                       Operand_kind.Payload.Capability.Imagequery] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagequerysizelod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel;
                       Operand_kind.Payload.Capability.Imagequery] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.levelofdetail]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesampledrefexplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 [Operand_kind.Payload.Imageoperands.satisfies_capabilities
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesampledrefimplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesamplefootprintnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Imagefootprintnv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.granularity];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.coarse];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesampleimplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesampleprojdrefexplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 [Operand_kind.Payload.Imageoperands.satisfies_capabilities
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesampleprojdrefimplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesampleprojexplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Imageoperands.satisfies_capabilities
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesampleprojimplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesampleweightedqcom t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Texturesampleweightedqcom]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.texture];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.weights]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsedrefgather t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsefetch t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsegather t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.component];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesparseread t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsesampledrefexplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 [Operand_kind.Payload.Imageoperands.satisfies_capabilities
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsesampledrefimplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsesampleexplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Imageoperands.satisfies_capabilities
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsesampleimplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsesampleprojdrefexplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 [Operand_kind.Payload.Imageoperands.satisfies_capabilities
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsesampleprojdrefimplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsesampleprojexplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Imageoperands.satisfies_capabilities
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsesampleprojimplicitlod t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opimagesparsetexelsresident t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Sparseresidency] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.residentcode]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opstencilattachmentreadext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tileimagestencilreadaccessext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 (t.sample |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Opcolorattachmentreadext _ -> true
          | Opconverthandletoimageintel _ -> true
          | Opconverthandletosampledimageintel _ -> true
          | Opconverthandletosamplerintel _ -> true
          | Opdepthattachmentreadext _ -> true
          | Opimage _ -> true
          | Opimageblockmatchgathersadqcom _ -> true
          | Opimageblockmatchgatherssdqcom _ -> true
          | Opimageblockmatchsadqcom _ -> true
          | Opimageblockmatchssdqcom _ -> true
          | Opimageblockmatchwindowsadqcom _ -> true
          | Opimageblockmatchwindowssdqcom _ -> true
          | Opimageboxfilterqcom _ -> true
          | Opimagedrefgather _ -> true
          | Opimagefetch _ -> true
          | Opimagegather _ -> true
          | Opimagequeryformat _ -> true
          | Opimagequerylevels _ -> true
          | Opimagequerylod _ -> true
          | Opimagequeryorder _ -> true
          | Opimagequerysamples _ -> true
          | Opimagequerysize _ -> true
          | Opimagequerysizelod _ -> true
          | Opimageread _ -> true
          | Opimagesampledrefexplicitlod _ -> true
          | Opimagesampledrefimplicitlod _ -> true
          | Opimagesampleexplicitlod _ -> true
          | Opimagesampleimplicitlod _ -> true
          | Opimagesampleprojdrefexplicitlod _ -> true
          | Opimagesampleprojdrefimplicitlod _ -> true
          | Opimagesampleprojexplicitlod _ -> true
          | Opimagesampleprojimplicitlod _ -> true
          | Opimagesampleweightedqcom _ -> true
          | Opimagesparsedrefgather _ -> true
          | Opimagesparsefetch _ -> true
          | Opimagesparsegather _ -> true
          | Opimagesparseread _ -> true
          | Opimagesparsesampledrefexplicitlod _ -> true
          | Opimagesparsesampledrefimplicitlod _ -> true
          | Opimagesparsesampleexplicitlod _ -> true
          | Opimagesparsesampleimplicitlod _ -> true
          | Opimagesparsesampleprojdrefexplicitlod _ -> true
          | Opimagesparsesampleprojdrefimplicitlod _ -> true
          | Opimagesparsesampleprojexplicitlod _ -> true
          | Opimagesparsesampleprojimplicitlod _ -> true
          | Opimagesparsetexelsresident _ -> true
          | Opimagewrite _ -> true
          | Opsampledimage _ -> true
          | Opstencilattachmentreadext _ -> true
          | Opimagesamplefootprintnv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_shader_image_footprint]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.granularity];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.coarse];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opcolorattachmentreadext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.attachment];
                 (t.sample |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opconverthandletoimageintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconverthandletosampledimageintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconverthandletosamplerintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opdepthattachmentreadext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 (t.sample |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimage t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimageblockmatchgathersadqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetsampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencesampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimageblockmatchgatherssdqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetsampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencesampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimageblockmatchsadqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.reference];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimageblockmatchssdqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.reference];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimageblockmatchwindowsadqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetsampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencesampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimageblockmatchwindowssdqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetsampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.targetcoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencesampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.referencecoordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.blocksize]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimageboxfilterqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.texture];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.boxsize]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagedrefgather t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagefetch t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagegather t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.component];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagequeryformat t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagequerylevels t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagequerylod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagequeryorder t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagequerysamples t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagequerysize t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagequerysizelod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.levelofdetail]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimageread t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesampledrefexplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 [Operand_kind.Payload.Imageoperands.satisfies_version
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesampledrefimplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesampleexplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Imageoperands.satisfies_version
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesamplefootprintnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.granularity];
                 [Operand_kind.Payload.Idref.satisfies_version t.coarse];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesampleimplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesampleprojdrefexplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 [Operand_kind.Payload.Imageoperands.satisfies_version
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesampleprojdrefimplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesampleprojexplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Imageoperands.satisfies_version
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesampleprojimplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesampleweightedqcom t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.texture];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.weights]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesparsedrefgather t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesparsefetch t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesparsegather t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.component];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesparseread t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesparsesampledrefexplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 [Operand_kind.Payload.Imageoperands.satisfies_version
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesparsesampledrefimplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesparsesampleexplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Imageoperands.satisfies_version
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesparsesampleimplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesparsesampleprojdrefexplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 [Operand_kind.Payload.Imageoperands.satisfies_version
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesparsesampleprojdrefimplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.dref];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesparsesampleprojexplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Imageoperands.satisfies_version
                    t.imageoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagesparsesampleprojimplicitlod t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledimage];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opimagesparsetexelsresident t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.residentcode]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagewrite t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.texel];
                 (t.imageoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Imageoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opsampledimage t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampler]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opstencilattachmentreadext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 (t.sample |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
      end
    module Memory =
      struct
        type t =
          | Opaccesschain of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Oparraylength of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          structure: Operand_kind.Payload.Idref.t ;
          arraymember: Operand_kind.Payload.Literalinteger.t } 
          | Opcooperativematrixloadkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t option ;
          memoryoperand: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativematrixloadtensornv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          memoryoperand: Operand_kind.Payload.Memoryaccess.t ;
          tensoraddressingoperands:
            Operand_kind.Payload.Tensoraddressingoperands.t }
          
          | Opcooperativematrixstorekhr of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t option ;
          memoryoperand: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativematrixstoretensornv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          memoryoperand: Operand_kind.Payload.Memoryaccess.t ;
          tensoraddressingoperands:
            Operand_kind.Payload.Tensoraddressingoperands.t }
          
          | Opcooperativevectorloadnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativevectorstorenv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcopymemory of
          {
          target: Operand_kind.Payload.Idref.t ;
          source: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option ;
          memoryaccess2: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcopymemorysized of
          {
          target: Operand_kind.Payload.Idref.t ;
          source: Operand_kind.Payload.Idref.t ;
          size: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option ;
          memoryaccess2: Operand_kind.Payload.Memoryaccess.t option } 
          | Opgenericptrmemsemantics of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opimagetexelpointer of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          sample: Operand_kind.Payload.Idref.t } 
          | Opinboundsaccesschain of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opinboundsptraccesschain of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          element: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opload of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opmaskedgatherintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          ptrvector: Operand_kind.Payload.Idref.t ;
          alignment: Operand_kind.Payload.Literalinteger.t ;
          mask: Operand_kind.Payload.Idref.t ;
          fillempty: Operand_kind.Payload.Idref.t } 
          | Opmaskedscatterintel of
          {
          inputvector: Operand_kind.Payload.Idref.t ;
          ptrvector: Operand_kind.Payload.Idref.t ;
          alignment: Operand_kind.Payload.Literalinteger.t ;
          mask: Operand_kind.Payload.Idref.t } 
          | Opptraccesschain of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          element: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opptrdiff of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opptrequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opptrnotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oprawaccesschainnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          bytestride: Operand_kind.Payload.Idref.t ;
          elementindex: Operand_kind.Payload.Idref.t ;
          byteoffset: Operand_kind.Payload.Idref.t ;
          rawaccesschainoperands:
            Operand_kind.Payload.Rawaccesschainoperands.t option }
          
          | Oprestorememoryintel of {
          ptr: Operand_kind.Payload.Idref.t } 
          | Opsavememoryintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opstore of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opuntypedaccesschainkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          basetype: Operand_kind.Payload.Idref.t ;
          base: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opuntypedarraylengthkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          structure: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          arraymember: Operand_kind.Payload.Literalinteger.t } 
          | Opuntypedinboundsaccesschainkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          basetype: Operand_kind.Payload.Idref.t ;
          base: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opuntypedinboundsptraccesschainkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          basetype: Operand_kind.Payload.Idref.t ;
          base: Operand_kind.Payload.Idref.t ;
          element: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opuntypedprefetchkhr of
          {
          pointertype: Operand_kind.Payload.Idref.t ;
          numbytes: Operand_kind.Payload.Idref.t ;
          rw: Operand_kind.Payload.Idref.t option ;
          locality: Operand_kind.Payload.Idref.t option ;
          cachetype: Operand_kind.Payload.Idref.t option } 
          | Opuntypedptraccesschainkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          basetype: Operand_kind.Payload.Idref.t ;
          base: Operand_kind.Payload.Idref.t ;
          element: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opuntypedvariablekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          storageclass: Operand_kind.Payload.Storageclass.t ;
          datatype: Operand_kind.Payload.Idref.t option ;
          initializer_: Operand_kind.Payload.Idref.t option } 
          | Opuntypedvariablelengtharrayintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          elementtype: Operand_kind.Payload.Idref.t ;
          length: Operand_kind.Payload.Idref.t } 
          | Opvariable of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          storageclass: Operand_kind.Payload.Storageclass.t ;
          initializer_: Operand_kind.Payload.Idref.t option } 
          | Opvariablelengtharrayintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          length: Operand_kind.Payload.Idref.t } [@@deriving
                                                   compare, sexp_of]
        let provisional =
          function
          | Opaccesschain _ -> false
          | Oparraylength _ -> false
          | Opcooperativematrixloadkhr _ -> false
          | Opcooperativematrixloadtensornv _ -> false
          | Opcooperativematrixstorekhr _ -> false
          | Opcooperativematrixstoretensornv _ -> false
          | Opcooperativevectorloadnv _ -> false
          | Opcooperativevectorstorenv _ -> false
          | Opcopymemory _ -> false
          | Opcopymemorysized _ -> false
          | Opgenericptrmemsemantics _ -> false
          | Opimagetexelpointer _ -> false
          | Opinboundsaccesschain _ -> false
          | Opinboundsptraccesschain _ -> false
          | Opload _ -> false
          | Opmaskedgatherintel _ -> false
          | Opmaskedscatterintel _ -> false
          | Opptraccesschain _ -> false
          | Opptrdiff _ -> false
          | Opptrequal _ -> false
          | Opptrnotequal _ -> false
          | Oprawaccesschainnv _ -> false
          | Oprestorememoryintel _ -> false
          | Opsavememoryintel _ -> false
          | Opstore _ -> false
          | Opuntypedaccesschainkhr _ -> false
          | Opuntypedarraylengthkhr _ -> false
          | Opuntypedinboundsaccesschainkhr _ -> false
          | Opuntypedinboundsptraccesschainkhr _ -> false
          | Opuntypedprefetchkhr _ -> false
          | Opuntypedptraccesschainkhr _ -> false
          | Opuntypedvariablekhr _ -> false
          | Opuntypedvariablelengtharrayintel _ -> false
          | Opvariable _ -> false
          | Opvariablelengtharrayintel _ -> false
        let value =
          function
          | Opaccesschain t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 List.map t.indexes ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 65l in
              heading :: payload
          | Oparraylength t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.structure];
                 [Operand_kind.Payload.Literalinteger.value t.arraymember]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 68l in
              heading :: payload
          | Opcooperativematrixloadkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.memorylayout];
                 (t.stride |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.memoryoperand |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4457l in
              heading :: payload
          | Opcooperativematrixloadtensornv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.object_];
                 [Operand_kind.Payload.Idref.value t.tensorlayout];
                 [Operand_kind.Payload.Memoryaccess.value t.memoryoperand];
                 [Operand_kind.Payload.Tensoraddressingoperands.value
                    t.tensoraddressingoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5367l in
              heading :: payload
          | Opcooperativematrixstorekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.object_];
                 [Operand_kind.Payload.Idref.value t.memorylayout];
                 (t.stride |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.memoryoperand |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4458l in
              heading :: payload
          | Opcooperativematrixstoretensornv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.object_];
                 [Operand_kind.Payload.Idref.value t.tensorlayout];
                 [Operand_kind.Payload.Memoryaccess.value t.memoryoperand];
                 [Operand_kind.Payload.Tensoraddressingoperands.value
                    t.tensoraddressingoperands]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5368l in
              heading :: payload
          | Opcooperativevectorloadnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.offset];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5302l in
              heading :: payload
          | Opcooperativevectorstorenv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.offset];
                 [Operand_kind.Payload.Idref.value t.object_];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5303l in
              heading :: payload
          | Opcopymemory t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Idref.value t.source];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list;
                 (t.memoryaccess2 |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 63l in
              heading :: payload
          | Opcopymemorysized t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.target];
                 [Operand_kind.Payload.Idref.value t.source];
                 [Operand_kind.Payload.Idref.value t.size];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list;
                 (t.memoryaccess2 |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 64l in
              heading :: payload
          | Opgenericptrmemsemantics t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 69l in
              heading :: payload
          | Opimagetexelpointer t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.sample]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 60l in
              heading :: payload
          | Opinboundsaccesschain t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 List.map t.indexes ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 66l in
              heading :: payload
          | Opinboundsptraccesschain t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.element];
                 List.map t.indexes ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 70l in
              heading :: payload
          | Opload t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 61l in
              heading :: payload
          | Opmaskedgatherintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.ptrvector];
                 [Operand_kind.Payload.Literalinteger.value t.alignment];
                 [Operand_kind.Payload.Idref.value t.mask];
                 [Operand_kind.Payload.Idref.value t.fillempty]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6428l in
              heading :: payload
          | Opmaskedscatterintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.inputvector];
                 [Operand_kind.Payload.Idref.value t.ptrvector];
                 [Operand_kind.Payload.Literalinteger.value t.alignment];
                 [Operand_kind.Payload.Idref.value t.mask]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6429l in
              heading :: payload
          | Opptraccesschain t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.element];
                 List.map t.indexes ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 67l in
              heading :: payload
          | Opptrdiff t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 403l in
              heading :: payload
          | Opptrequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 401l in
              heading :: payload
          | Opptrnotequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 402l in
              heading :: payload
          | Oprawaccesschainnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.bytestride];
                 [Operand_kind.Payload.Idref.value t.elementindex];
                 [Operand_kind.Payload.Idref.value t.byteoffset];
                 (t.rawaccesschainoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Rawaccesschainoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5398l in
              heading :: payload
          | Oprestorememoryintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.ptr]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5820l in
              heading :: payload
          | Opsavememoryintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5819l in
              heading :: payload
          | Opstore t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.object_];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 62l in
              heading :: payload
          | Opuntypedaccesschainkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.basetype];
                 [Operand_kind.Payload.Idref.value t.base];
                 List.map t.indexes ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4419l in
              heading :: payload
          | Opuntypedarraylengthkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.structure];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Literalinteger.value t.arraymember]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4425l in
              heading :: payload
          | Opuntypedinboundsaccesschainkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.basetype];
                 [Operand_kind.Payload.Idref.value t.base];
                 List.map t.indexes ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4420l in
              heading :: payload
          | Opuntypedinboundsptraccesschainkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.basetype];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.element];
                 List.map t.indexes ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4424l in
              heading :: payload
          | Opuntypedprefetchkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointertype];
                 [Operand_kind.Payload.Idref.value t.numbytes];
                 (t.rw |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.locality |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.cachetype |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4426l in
              heading :: payload
          | Opuntypedptraccesschainkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.basetype];
                 [Operand_kind.Payload.Idref.value t.base];
                 [Operand_kind.Payload.Idref.value t.element];
                 List.map t.indexes ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4423l in
              heading :: payload
          | Opuntypedvariablekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Storageclass.value t.storageclass];
                 (t.datatype |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.initializer_ |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4418l in
              heading :: payload
          | Opuntypedvariablelengtharrayintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.elementtype];
                 [Operand_kind.Payload.Idref.value t.length]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6244l in
              heading :: payload
          | Opvariable t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Storageclass.value t.storageclass];
                 (t.initializer_ |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 59l in
              heading :: payload
          | Opvariablelengtharrayintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.length]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5818l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opaccesschain _ -> true
          | Opcopymemory _ -> true
          | Opimagetexelpointer _ -> true
          | Opinboundsaccesschain _ -> true
          | Opload _ -> true
          | Opptrequal _ -> true
          | Opptrnotequal _ -> true
          | Opstore _ -> true
          | Opvariable _ -> true
          | Oparraylength t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.structure];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.arraymember]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixloadkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixkhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorylayout];
                 (t.stride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.memoryoperand |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixloadtensornv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixtensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.object_];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorlayout];
                 [Operand_kind.Payload.Memoryaccess.satisfies_capabilities
                    t.memoryoperand];
                 [Operand_kind.Payload.Tensoraddressingoperands.satisfies_capabilities
                    t.tensoraddressingoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixstorekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixkhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.object_];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorylayout];
                 (t.stride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.memoryoperand |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixstoretensornv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixtensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.object_];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorlayout];
                 [Operand_kind.Payload.Memoryaccess.satisfies_capabilities
                    t.memoryoperand];
                 [Operand_kind.Payload.Tensoraddressingoperands.satisfies_capabilities
                    t.tensoraddressingoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativevectorloadnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativevectornv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.offset];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativevectorstorenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativevectornv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.offset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.object_];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcopymemorysized t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Addresses;
                       Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.target];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.source];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.size];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list;
                 (t.memoryaccess2 |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgenericptrmemsemantics t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opinboundsptraccesschain t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Addresses] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.element];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opmaskedgatherintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Maskedgatherscatterintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.ptrvector];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.alignment];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.mask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fillempty]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opmaskedscatterintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Maskedgatherscatterintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.inputvector];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.ptrvector];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.alignment];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.mask]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opptraccesschain t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Addresses;
                       Operand_kind.Payload.Capability.Variablepointers;
                       Operand_kind.Payload.Capability.Variablepointersstoragebuffer;
                       Operand_kind.Payload.Capability.Physicalstoragebufferaddresses]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.element];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opptrdiff t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Addresses;
                       Operand_kind.Payload.Capability.Variablepointers;
                       Operand_kind.Payload.Capability.Variablepointersstoragebuffer]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprawaccesschainnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rawaccesschainsnv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.bytestride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.elementindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.byteoffset];
                 (t.rawaccesschainoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Rawaccesschainoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Oprestorememoryintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Variablelengtharrayintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.ptr]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsavememoryintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Variablelengtharrayintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuntypedaccesschainkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.basetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuntypedarraylengthkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.structure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.arraymember]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuntypedinboundsaccesschainkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.basetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuntypedinboundsptraccesschainkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.basetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.element];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuntypedprefetchkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointertype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numbytes];
                 (t.rw |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.locality |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.cachetype |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opuntypedptraccesschainkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.basetype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.base];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.element];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuntypedvariablekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Storageclass.satisfies_capabilities
                    t.storageclass];
                 (t.datatype |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.initializer_ |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opuntypedvariablelengtharrayintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedvariablelengtharrayintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.elementtype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.length]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opvariablelengtharrayintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Variablelengtharrayintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.length]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opaccesschain _ -> true
          | Oparraylength _ -> true
          | Opcooperativematrixloadkhr _ -> true
          | Opcooperativematrixloadtensornv _ -> true
          | Opcooperativematrixstorekhr _ -> true
          | Opcooperativematrixstoretensornv _ -> true
          | Opcooperativevectorloadnv _ -> true
          | Opcooperativevectorstorenv _ -> true
          | Opcopymemory _ -> true
          | Opcopymemorysized _ -> true
          | Opgenericptrmemsemantics _ -> true
          | Opimagetexelpointer _ -> true
          | Opinboundsaccesschain _ -> true
          | Opinboundsptraccesschain _ -> true
          | Opload _ -> true
          | Opmaskedgatherintel _ -> true
          | Opmaskedscatterintel _ -> true
          | Opptraccesschain _ -> true
          | Opptrdiff _ -> true
          | Opptrequal _ -> true
          | Opptrnotequal _ -> true
          | Oprawaccesschainnv _ -> true
          | Oprestorememoryintel _ -> true
          | Opsavememoryintel _ -> true
          | Opstore _ -> true
          | Opuntypedaccesschainkhr _ -> true
          | Opuntypedarraylengthkhr _ -> true
          | Opuntypedinboundsaccesschainkhr _ -> true
          | Opuntypedinboundsptraccesschainkhr _ -> true
          | Opuntypedprefetchkhr _ -> true
          | Opuntypedptraccesschainkhr _ -> true
          | Opuntypedvariablekhr _ -> true
          | Opuntypedvariablelengtharrayintel _ -> true
          | Opvariable _ -> true
          | Opvariablelengtharrayintel _ -> true
        let satisfies_version t ~version =
          match t with
          | Opaccesschain t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Oparraylength t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.structure];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.arraymember]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativematrixloadkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorylayout];
                 (t.stride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.memoryoperand |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativematrixloadtensornv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.object_];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorlayout];
                 [Operand_kind.Payload.Memoryaccess.satisfies_version
                    t.memoryoperand];
                 [Operand_kind.Payload.Tensoraddressingoperands.satisfies_version
                    t.tensoraddressingoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativematrixstorekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.object_];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorylayout];
                 (t.stride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.memoryoperand |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativematrixstoretensornv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.object_];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorlayout];
                 [Operand_kind.Payload.Memoryaccess.satisfies_version
                    t.memoryoperand];
                 [Operand_kind.Payload.Tensoraddressingoperands.satisfies_version
                    t.tensoraddressingoperands]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativevectorloadnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.offset];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativevectorstorenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.offset];
                 [Operand_kind.Payload.Idref.satisfies_version t.object_];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcopymemory t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Idref.satisfies_version t.source];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list;
                 (t.memoryaccess2 |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcopymemorysized t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.target];
                 [Operand_kind.Payload.Idref.satisfies_version t.source];
                 [Operand_kind.Payload.Idref.satisfies_version t.size];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list;
                 (t.memoryaccess2 |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgenericptrmemsemantics t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opimagetexelpointer t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version t.sample]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opinboundsaccesschain t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opinboundsptraccesschain t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.element];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opload t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opmaskedgatherintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.ptrvector];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.alignment];
                 [Operand_kind.Payload.Idref.satisfies_version t.mask];
                 [Operand_kind.Payload.Idref.satisfies_version t.fillempty]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmaskedscatterintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.inputvector];
                 [Operand_kind.Payload.Idref.satisfies_version t.ptrvector];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.alignment];
                 [Operand_kind.Payload.Idref.satisfies_version t.mask]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opptraccesschain t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.element];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opptrdiff t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_4) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opptrequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_4) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opptrnotequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_4) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprawaccesschainnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.bytestride];
                 [Operand_kind.Payload.Idref.satisfies_version t.elementindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.byteoffset];
                 (t.rawaccesschainoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Rawaccesschainoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Oprestorememoryintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.ptr]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsavememoryintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opstore t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.object_];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opuntypedaccesschainkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.basetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opuntypedarraylengthkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.structure];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.arraymember]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opuntypedinboundsaccesschainkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.basetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opuntypedinboundsptraccesschainkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.basetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.element];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opuntypedprefetchkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointertype];
                 [Operand_kind.Payload.Idref.satisfies_version t.numbytes];
                 (t.rw |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.locality |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.cachetype |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opuntypedptraccesschainkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.basetype];
                 [Operand_kind.Payload.Idref.satisfies_version t.base];
                 [Operand_kind.Payload.Idref.satisfies_version t.element];
                 List.map t.indexes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opuntypedvariablekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Storageclass.satisfies_version
                    t.storageclass];
                 (t.datatype |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.initializer_ |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opuntypedvariablelengtharrayintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.elementtype];
                 [Operand_kind.Payload.Idref.satisfies_version t.length]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opvariable t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Storageclass.satisfies_version
                    t.storageclass];
                 (t.initializer_ |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opvariablelengtharrayintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.length]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Miscellaneous =
      struct
        type t =
          | Oparithmeticfenceext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          target: Operand_kind.Payload.Idref.t } 
          | Opassumetruekhr of {
          condition: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixlengthkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          type_: Operand_kind.Payload.Idref.t } 
          | Opexpectkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t ;
          expectedvalue: Operand_kind.Payload.Idref.t } 
          | Opnop 
          | Opsizeof of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opundef of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } [@@deriving
                                                        compare, sexp_of]
        let provisional =
          function
          | Oparithmeticfenceext _ -> false
          | Opassumetruekhr _ -> false
          | Opcooperativematrixlengthkhr _ -> false
          | Opexpectkhr _ -> false
          | Opnop -> false
          | Opsizeof _ -> false
          | Opundef _ -> false
        let value =
          function
          | Oparithmeticfenceext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.target]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6145l in
              heading :: payload
          | Opassumetruekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.condition]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5630l in
              heading :: payload
          | Opcooperativematrixlengthkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.type_]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4460l in
              heading :: payload
          | Opexpectkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.expectedvalue]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5631l in
              heading :: payload
          | Opnop ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 0l in
              [heading]
          | Opsizeof t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 321l in
              heading :: payload
          | Opundef t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 1l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opnop -> true
          | Opundef _ -> true
          | Oparithmeticfenceext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Arithmeticfenceext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.target]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opassumetruekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Expectassumekhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.condition]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixlengthkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixkhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.type_]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opexpectkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Expectassumekhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.expectedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsizeof t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Addresses] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Oparithmeticfenceext _ -> true
          | Opcooperativematrixlengthkhr _ -> true
          | Opnop -> true
          | Opsizeof _ -> true
          | Opundef _ -> true
          | Opassumetruekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_expect_assume] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions
                     t.condition]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opexpectkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_expect_assume] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.value];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.expectedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Oparithmeticfenceext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.target]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opassumetruekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.condition]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativematrixlengthkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.type_]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opexpectkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.expectedvalue]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opnop ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opsizeof t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opundef t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Mode_setting =
      struct
        type t =
          | Opcapability of {
          capability: Operand_kind.Payload.Capability.t } 
          | Opconditionalcapabilityintel of
          {
          condition: Operand_kind.Payload.Idref.t ;
          capability: Operand_kind.Payload.Capability.t } 
          | Opconditionalentrypointintel of
          {
          condition: Operand_kind.Payload.Idref.t ;
          executionmodel: Operand_kind.Payload.Executionmodel.t ;
          entrypoint: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t ;
          interface: Operand_kind.Payload.Idref.t list } 
          | Opentrypoint of
          {
          executionmodel: Operand_kind.Payload.Executionmodel.t ;
          entrypoint: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t ;
          interface: Operand_kind.Payload.Idref.t list } 
          | Opexecutionmode of
          {
          entrypoint: Operand_kind.Payload.Idref.t ;
          mode: Operand_kind.Payload.Executionmode.t } 
          | Opexecutionmodeid of
          {
          entrypoint: Operand_kind.Payload.Idref.t ;
          mode: Operand_kind.Payload.Executionmode.t } 
          | Opmemorymodel of
          {
          addressingmodel: Operand_kind.Payload.Addressingmodel.t ;
          memorymodel: Operand_kind.Payload.Memorymodel.t } [@@deriving
                                                              compare, sexp_of]
        let provisional =
          function
          | Opcapability _ -> false
          | Opconditionalcapabilityintel _ -> true
          | Opconditionalentrypointintel _ -> true
          | Opentrypoint _ -> false
          | Opexecutionmode _ -> false
          | Opexecutionmodeid _ -> false
          | Opmemorymodel _ -> false
        let value =
          function
          | Opcapability t ->
              let payload =
                ([[Operand_kind.Payload.Capability.value t.capability]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 17l in
              heading :: payload
          | Opconditionalcapabilityintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.condition];
                 [Operand_kind.Payload.Capability.value t.capability]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6250l in
              heading :: payload
          | Opconditionalentrypointintel t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.condition];
                 [Operand_kind.Payload.Executionmodel.value t.executionmodel];
                 [Operand_kind.Payload.Idref.value t.entrypoint];
                 [Operand_kind.Payload.Literalstring.value t.name];
                 List.map t.interface ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6249l in
              heading :: payload
          | Opentrypoint t ->
              let payload =
                ([[Operand_kind.Payload.Executionmodel.value t.executionmodel];
                 [Operand_kind.Payload.Idref.value t.entrypoint];
                 [Operand_kind.Payload.Literalstring.value t.name];
                 List.map t.interface ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 15l in
              heading :: payload
          | Opexecutionmode t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.entrypoint];
                 [Operand_kind.Payload.Executionmode.value t.mode]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 16l in
              heading :: payload
          | Opexecutionmodeid t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.entrypoint];
                 [Operand_kind.Payload.Executionmode.value t.mode]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 331l in
              heading :: payload
          | Opmemorymodel t ->
              let payload =
                ([[Operand_kind.Payload.Addressingmodel.value
                     t.addressingmodel];
                 [Operand_kind.Payload.Memorymodel.value t.memorymodel]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 14l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opcapability _ -> true
          | Opentrypoint _ -> true
          | Opexecutionmode _ -> true
          | Opexecutionmodeid _ -> true
          | Opmemorymodel _ -> true
          | Opconditionalcapabilityintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Specconditionalintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.condition];
                 [Operand_kind.Payload.Capability.satisfies_capabilities
                    t.capability]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconditionalentrypointintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Specconditionalintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.condition];
                 [Operand_kind.Payload.Executionmodel.satisfies_capabilities
                    t.executionmodel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.entrypoint];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.name];
                 List.map t.interface
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opcapability _ -> true
          | Opconditionalcapabilityintel _ -> true
          | Opconditionalentrypointintel _ -> true
          | Opentrypoint _ -> true
          | Opexecutionmode _ -> true
          | Opexecutionmodeid _ -> true
          | Opmemorymodel _ -> true
        let satisfies_version t ~version =
          match t with
          | Opcapability t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Capability.satisfies_version
                     t.capability]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconditionalcapabilityintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.condition];
                 [Operand_kind.Payload.Capability.satisfies_version
                    t.capability]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconditionalentrypointintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.condition];
                 [Operand_kind.Payload.Executionmodel.satisfies_version
                    t.executionmodel];
                 [Operand_kind.Payload.Idref.satisfies_version t.entrypoint];
                 [Operand_kind.Payload.Literalstring.satisfies_version t.name];
                 List.map t.interface
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opentrypoint t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Executionmodel.satisfies_version
                     t.executionmodel];
                 [Operand_kind.Payload.Idref.satisfies_version t.entrypoint];
                 [Operand_kind.Payload.Literalstring.satisfies_version t.name];
                 List.map t.interface
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opexecutionmode t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.entrypoint];
                 [Operand_kind.Payload.Executionmode.satisfies_version t.mode]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opexecutionmodeid t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_2) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.entrypoint];
                 [Operand_kind.Payload.Executionmode.satisfies_version t.mode]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opmemorymodel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Addressingmodel.satisfies_version
                     t.addressingmodel];
                 [Operand_kind.Payload.Memorymodel.satisfies_version
                    t.memorymodel]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Non_uniform =
      struct
        type t =
          | Opgroupnonuniformall of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformallequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformany of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballotbitcount of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballotbitextract of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballotfindlsb of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballotfindmsb of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformbitwiseand of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformbitwiseor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformbitwisexor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformbroadcast of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          invocationid: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformbroadcastfirst of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformelect of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t } 
          | Opgroupnonuniformfadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformfmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformfmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformfmul of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformiadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformimul of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniforminverseballot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformlogicaland of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformlogicalor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformlogicalxor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformpartitionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformquadallkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformquadanykhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformquadbroadcast of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformquadswap of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformshuffle of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          invocationid: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformshuffledown of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformshuffleup of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformshufflexor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          mask: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformsmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformsmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformumax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformumin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } [@@deriving
                                                               compare, sexp_of]
        let provisional =
          function
          | Opgroupnonuniformall _ -> false
          | Opgroupnonuniformallequal _ -> false
          | Opgroupnonuniformany _ -> false
          | Opgroupnonuniformballot _ -> false
          | Opgroupnonuniformballotbitcount _ -> false
          | Opgroupnonuniformballotbitextract _ -> false
          | Opgroupnonuniformballotfindlsb _ -> false
          | Opgroupnonuniformballotfindmsb _ -> false
          | Opgroupnonuniformbitwiseand _ -> false
          | Opgroupnonuniformbitwiseor _ -> false
          | Opgroupnonuniformbitwisexor _ -> false
          | Opgroupnonuniformbroadcast _ -> false
          | Opgroupnonuniformbroadcastfirst _ -> false
          | Opgroupnonuniformelect _ -> false
          | Opgroupnonuniformfadd _ -> false
          | Opgroupnonuniformfmax _ -> false
          | Opgroupnonuniformfmin _ -> false
          | Opgroupnonuniformfmul _ -> false
          | Opgroupnonuniformiadd _ -> false
          | Opgroupnonuniformimul _ -> false
          | Opgroupnonuniforminverseballot _ -> false
          | Opgroupnonuniformlogicaland _ -> false
          | Opgroupnonuniformlogicalor _ -> false
          | Opgroupnonuniformlogicalxor _ -> false
          | Opgroupnonuniformpartitionnv _ -> false
          | Opgroupnonuniformquadallkhr _ -> false
          | Opgroupnonuniformquadanykhr _ -> false
          | Opgroupnonuniformquadbroadcast _ -> false
          | Opgroupnonuniformquadswap _ -> false
          | Opgroupnonuniformshuffle _ -> false
          | Opgroupnonuniformshuffledown _ -> false
          | Opgroupnonuniformshuffleup _ -> false
          | Opgroupnonuniformshufflexor _ -> false
          | Opgroupnonuniformsmax _ -> false
          | Opgroupnonuniformsmin _ -> false
          | Opgroupnonuniformumax _ -> false
          | Opgroupnonuniformumin _ -> false
        let value =
          function
          | Opgroupnonuniformall t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 334l in
              heading :: payload
          | Opgroupnonuniformallequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 336l in
              heading :: payload
          | Opgroupnonuniformany t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 335l in
              heading :: payload
          | Opgroupnonuniformballot t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 339l in
              heading :: payload
          | Opgroupnonuniformballotbitcount t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 342l in
              heading :: payload
          | Opgroupnonuniformballotbitextract t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.index]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 341l in
              heading :: payload
          | Opgroupnonuniformballotfindlsb t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 343l in
              heading :: payload
          | Opgroupnonuniformballotfindmsb t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 344l in
              heading :: payload
          | Opgroupnonuniformbitwiseand t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 359l in
              heading :: payload
          | Opgroupnonuniformbitwiseor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 360l in
              heading :: payload
          | Opgroupnonuniformbitwisexor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 361l in
              heading :: payload
          | Opgroupnonuniformbroadcast t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.invocationid]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 337l in
              heading :: payload
          | Opgroupnonuniformbroadcastfirst t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 338l in
              heading :: payload
          | Opgroupnonuniformelect t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 333l in
              heading :: payload
          | Opgroupnonuniformfadd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 350l in
              heading :: payload
          | Opgroupnonuniformfmax t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 358l in
              heading :: payload
          | Opgroupnonuniformfmin t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 355l in
              heading :: payload
          | Opgroupnonuniformfmul t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 352l in
              heading :: payload
          | Opgroupnonuniformiadd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 349l in
              heading :: payload
          | Opgroupnonuniformimul t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 351l in
              heading :: payload
          | Opgroupnonuniforminverseballot t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 340l in
              heading :: payload
          | Opgroupnonuniformlogicaland t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 362l in
              heading :: payload
          | Opgroupnonuniformlogicalor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 363l in
              heading :: payload
          | Opgroupnonuniformlogicalxor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 364l in
              heading :: payload
          | Opgroupnonuniformpartitionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5296l in
              heading :: payload
          | Opgroupnonuniformquadallkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5110l in
              heading :: payload
          | Opgroupnonuniformquadanykhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.predicate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5111l in
              heading :: payload
          | Opgroupnonuniformquadbroadcast t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.index]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 365l in
              heading :: payload
          | Opgroupnonuniformquadswap t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.direction]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 366l in
              heading :: payload
          | Opgroupnonuniformshuffle t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.invocationid]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 345l in
              heading :: payload
          | Opgroupnonuniformshuffledown t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.delta]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 348l in
              heading :: payload
          | Opgroupnonuniformshuffleup t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.delta]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 347l in
              heading :: payload
          | Opgroupnonuniformshufflexor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.value];
                 [Operand_kind.Payload.Idref.value t.mask]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 346l in
              heading :: payload
          | Opgroupnonuniformsmax t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 356l in
              heading :: payload
          | Opgroupnonuniformsmin t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 353l in
              heading :: payload
          | Opgroupnonuniformumax t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 357l in
              heading :: payload
          | Opgroupnonuniformumin t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Groupoperation.value t.operation];
                 [Operand_kind.Payload.Idref.value t.value];
                 (t.clustersize |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 354l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opgroupnonuniformall t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformvote]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformallequal t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformvote]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformany t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformvote]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformballot t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformballot]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformballotbitcount t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformballot]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformballotbitextract t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformballot]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.index]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformballotfindlsb t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformballot]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformballotfindmsb t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformballot]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformbitwiseand t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformbitwiseor t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformbitwisexor t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformbroadcast t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformballot]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.invocationid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformbroadcastfirst t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformballot]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformelect t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniform] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformfadd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformfmax t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformfmin t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformfmul t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformiadd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformimul t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniforminverseballot t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformballot]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformlogicaland t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformlogicalor t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformlogicalxor t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformpartitionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformquadallkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Quadcontrolkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformquadanykhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Quadcontrolkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformquadbroadcast t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformquad]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.index]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformquadswap t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformquad]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformshuffle t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformshuffle]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.invocationid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformshuffledown t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformshufflerelative]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.delta]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformshuffleup t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformshufflerelative]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.delta]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformshufflexor t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformshuffle]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.mask]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformsmax t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformsmin t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformumax t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opgroupnonuniformumin t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
                       Operand_kind.Payload.Capability.Groupnonuniformclustered;
                       Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_capabilities
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Opgroupnonuniformall _ -> true
          | Opgroupnonuniformallequal _ -> true
          | Opgroupnonuniformany _ -> true
          | Opgroupnonuniformballot _ -> true
          | Opgroupnonuniformballotbitcount _ -> true
          | Opgroupnonuniformballotbitextract _ -> true
          | Opgroupnonuniformballotfindlsb _ -> true
          | Opgroupnonuniformballotfindmsb _ -> true
          | Opgroupnonuniformbitwiseand _ -> true
          | Opgroupnonuniformbitwiseor _ -> true
          | Opgroupnonuniformbitwisexor _ -> true
          | Opgroupnonuniformbroadcast _ -> true
          | Opgroupnonuniformbroadcastfirst _ -> true
          | Opgroupnonuniformelect _ -> true
          | Opgroupnonuniformfadd _ -> true
          | Opgroupnonuniformfmax _ -> true
          | Opgroupnonuniformfmin _ -> true
          | Opgroupnonuniformfmul _ -> true
          | Opgroupnonuniformiadd _ -> true
          | Opgroupnonuniformimul _ -> true
          | Opgroupnonuniforminverseballot _ -> true
          | Opgroupnonuniformlogicaland _ -> true
          | Opgroupnonuniformlogicalor _ -> true
          | Opgroupnonuniformlogicalxor _ -> true
          | Opgroupnonuniformquadallkhr _ -> true
          | Opgroupnonuniformquadanykhr _ -> true
          | Opgroupnonuniformquadbroadcast _ -> true
          | Opgroupnonuniformquadswap _ -> true
          | Opgroupnonuniformshuffle _ -> true
          | Opgroupnonuniformshuffledown _ -> true
          | Opgroupnonuniformshuffleup _ -> true
          | Opgroupnonuniformshufflexor _ -> true
          | Opgroupnonuniformsmax _ -> true
          | Opgroupnonuniformsmin _ -> true
          | Opgroupnonuniformumax _ -> true
          | Opgroupnonuniformumin _ -> true
          | Opgroupnonuniformpartitionnv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opgroupnonuniformall t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformallequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformany t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformballot t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformballotbitcount t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformballotbitextract t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.index]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformballotfindlsb t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformballotfindmsb t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformbitwiseand t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformbitwiseor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformbitwisexor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformbroadcast t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.invocationid]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformbroadcastfirst t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformelect t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformfadd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformfmax t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformfmin t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformfmul t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformiadd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformimul t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniforminverseballot t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformlogicaland t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformlogicalor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformlogicalxor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformpartitionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformquadallkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformquadanykhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.predicate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformquadbroadcast t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.index]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformquadswap t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformshuffle t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.invocationid]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformshuffledown t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.delta]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformshuffleup t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.delta]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformshufflexor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 [Operand_kind.Payload.Idref.satisfies_version t.mask]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformsmax t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformsmin t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformumax t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opgroupnonuniformumin t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_3) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Groupoperation.satisfies_version
                    t.operation];
                 [Operand_kind.Payload.Idref.satisfies_version t.value];
                 (t.clustersize |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
      end
    module Pipe =
      struct
        type t =
          | Opcommitreadpipe of
          {
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opcommitwritepipe of
          {
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opconstantpipestorage of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packetsize: Operand_kind.Payload.Literalinteger.t ;
          packetalignment: Operand_kind.Payload.Literalinteger.t ;
          capacity: Operand_kind.Payload.Literalinteger.t } 
          | Opcreatepipefrompipestorage of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipestorage: Operand_kind.Payload.Idref.t } 
          | Opgetmaxpipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgetnumpipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgroupcommitreadpipe of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgroupcommitwritepipe of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgroupreservereadpipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          numpackets: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgroupreservewritepipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          numpackets: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opisvalidreserveid of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          reserveid: Operand_kind.Payload.Idref.t } 
          | Opreadpipe of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opreservedreadpipe of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opreservedwritepipe of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opreservereadpipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          numpackets: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opreservewritepipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          numpackets: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opwritepipe of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } [@@deriving
                                                            compare, sexp_of]
        let provisional =
          function
          | Opcommitreadpipe _ -> false
          | Opcommitwritepipe _ -> false
          | Opconstantpipestorage _ -> false
          | Opcreatepipefrompipestorage _ -> false
          | Opgetmaxpipepackets _ -> false
          | Opgetnumpipepackets _ -> false
          | Opgroupcommitreadpipe _ -> false
          | Opgroupcommitwritepipe _ -> false
          | Opgroupreservereadpipepackets _ -> false
          | Opgroupreservewritepipepackets _ -> false
          | Opisvalidreserveid _ -> false
          | Opreadpipe _ -> false
          | Opreservedreadpipe _ -> false
          | Opreservedwritepipe _ -> false
          | Opreservereadpipepackets _ -> false
          | Opreservewritepipepackets _ -> false
          | Opwritepipe _ -> false
        let value =
          function
          | Opcommitreadpipe t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.reserveid];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 280l in
              heading :: payload
          | Opcommitwritepipe t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.reserveid];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 281l in
              heading :: payload
          | Opconstantpipestorage t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalinteger.value t.packetsize];
                 [Operand_kind.Payload.Literalinteger.value t.packetalignment];
                 [Operand_kind.Payload.Literalinteger.value t.capacity]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 323l in
              heading :: payload
          | Opcreatepipefrompipestorage t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipestorage]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 324l in
              heading :: payload
          | Opgetmaxpipepackets t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 284l in
              heading :: payload
          | Opgetnumpipepackets t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 283l in
              heading :: payload
          | Opgroupcommitreadpipe t ->
              let payload =
                ([[Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.reserveid];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 287l in
              heading :: payload
          | Opgroupcommitwritepipe t ->
              let payload =
                ([[Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.reserveid];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 288l in
              heading :: payload
          | Opgroupreservereadpipepackets t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.numpackets];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 285l in
              heading :: payload
          | Opgroupreservewritepipepackets t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.numpackets];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 286l in
              heading :: payload
          | Opisvalidreserveid t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.reserveid]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 282l in
              heading :: payload
          | Opreadpipe t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 274l in
              heading :: payload
          | Opreservedreadpipe t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.reserveid];
                 [Operand_kind.Payload.Idref.value t.index];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 276l in
              heading :: payload
          | Opreservedwritepipe t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.reserveid];
                 [Operand_kind.Payload.Idref.value t.index];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 277l in
              heading :: payload
          | Opreservereadpipepackets t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.numpackets];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 278l in
              heading :: payload
          | Opreservewritepipepackets t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.numpackets];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 279l in
              heading :: payload
          | Opwritepipe t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pipe];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.packetsize];
                 [Operand_kind.Payload.Idref.value t.packetalignment]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 275l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opcommitreadpipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcommitwritepipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconstantpipestorage t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipestorage] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.packetalignment];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.capacity]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcreatepipefrompipestorage t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipestorage] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.pipestorage]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetmaxpipepackets t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgetnumpipepackets t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupcommitreadpipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idscope.satisfies_capabilities
                     t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupcommitwritepipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idscope.satisfies_capabilities
                     t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupreservereadpipepackets t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numpackets];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opgroupreservewritepipepackets t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numpackets];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opisvalidreserveid t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reserveid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreadpipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreservedreadpipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.index];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreservedwritepipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.index];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreservereadpipepackets t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numpackets];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreservewritepipepackets t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.numpackets];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opwritepipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opcommitreadpipe _ -> true
          | Opcommitwritepipe _ -> true
          | Opconstantpipestorage _ -> true
          | Opcreatepipefrompipestorage _ -> true
          | Opgetmaxpipepackets _ -> true
          | Opgetnumpipepackets _ -> true
          | Opgroupcommitreadpipe _ -> true
          | Opgroupcommitwritepipe _ -> true
          | Opgroupreservereadpipepackets _ -> true
          | Opgroupreservewritepipepackets _ -> true
          | Opisvalidreserveid _ -> true
          | Opreadpipe _ -> true
          | Opreservedreadpipe _ -> true
          | Opreservedwritepipe _ -> true
          | Opreservereadpipepackets _ -> true
          | Opreservewritepipepackets _ -> true
          | Opwritepipe _ -> true
        let satisfies_version t ~version =
          match t with
          | Opcommitreadpipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcommitwritepipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconstantpipestorage t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.packetsize];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.packetalignment];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.capacity]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcreatepipefrompipestorage t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipestorage]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetmaxpipepackets t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgetnumpipepackets t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupcommitreadpipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupcommitwritepipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupreservereadpipepackets t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.numpackets];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opgroupreservewritepipepackets t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.numpackets];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opisvalidreserveid t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.reserveid]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opreadpipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opreservedreadpipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_version t.index];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opreservedwritepipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.reserveid];
                 [Operand_kind.Payload.Idref.satisfies_version t.index];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opreservereadpipepackets t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.numpackets];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opreservewritepipepackets t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.numpackets];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opwritepipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pipe];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.packetsize];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packetalignment]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Primitive =
      struct
        type t =
          | Opemitstreamvertex of {
          stream: Operand_kind.Payload.Idref.t } 
          | Opemitvertex 
          | Opendprimitive 
          | Opendstreamprimitive of {
          stream: Operand_kind.Payload.Idref.t } [@@deriving
                                                   compare, sexp_of]
        let provisional =
          function
          | Opemitstreamvertex _ -> false
          | Opemitvertex -> false
          | Opendprimitive -> false
          | Opendstreamprimitive _ -> false
        let value =
          function
          | Opemitstreamvertex t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.stream]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 220l in
              heading :: payload
          | Opemitvertex ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 218l in
              [heading]
          | Opendprimitive ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 219l in
              [heading]
          | Opendstreamprimitive t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.stream]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 221l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opemitstreamvertex t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Geometrystreams] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.stream]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opemitvertex ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Geometry] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Opendprimitive ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Geometry] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Opendstreamprimitive t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Geometrystreams] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.stream]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opemitstreamvertex _ -> true
          | Opemitvertex -> true
          | Opendprimitive -> true
          | Opendstreamprimitive _ -> true
        let satisfies_version t ~version =
          match t with
          | Opemitstreamvertex t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.stream]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opemitvertex ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opendprimitive ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opendstreamprimitive t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.stream]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Relational_and_logical =
      struct
        type t =
          | Opall of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t } 
          | Opany of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t } 
          | Opfordequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordgreaterthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordgreaterthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordlessthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordlessthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordnotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordgreaterthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordgreaterthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordlessthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordlessthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordnotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opinotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opisfinite of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opisinf of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opisnan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opisnormal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Oplessorgreater of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t ;
          y: Operand_kind.Payload.Idref.t } 
          | Oplogicaland of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oplogicalequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oplogicalnot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Oplogicalnotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oplogicalor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opordered of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t ;
          y: Operand_kind.Payload.Idref.t } 
          | Opselect of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          condition: Operand_kind.Payload.Idref.t ;
          object1: Operand_kind.Payload.Idref.t ;
          object2: Operand_kind.Payload.Idref.t } 
          | Opsgreaterthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsgreaterthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsignbitset of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opslessthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opslessthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opugreaterthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opugreaterthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opulessthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opulessthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opunordered of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t ;
          y: Operand_kind.Payload.Idref.t } [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opall _ -> false
          | Opany _ -> false
          | Opfordequal _ -> false
          | Opfordgreaterthan _ -> false
          | Opfordgreaterthanequal _ -> false
          | Opfordlessthan _ -> false
          | Opfordlessthanequal _ -> false
          | Opfordnotequal _ -> false
          | Opfunordequal _ -> false
          | Opfunordgreaterthan _ -> false
          | Opfunordgreaterthanequal _ -> false
          | Opfunordlessthan _ -> false
          | Opfunordlessthanequal _ -> false
          | Opfunordnotequal _ -> false
          | Opiequal _ -> false
          | Opinotequal _ -> false
          | Opisfinite _ -> false
          | Opisinf _ -> false
          | Opisnan _ -> false
          | Opisnormal _ -> false
          | Oplessorgreater _ -> false
          | Oplogicaland _ -> false
          | Oplogicalequal _ -> false
          | Oplogicalnot _ -> false
          | Oplogicalnotequal _ -> false
          | Oplogicalor _ -> false
          | Opordered _ -> false
          | Opselect _ -> false
          | Opsgreaterthan _ -> false
          | Opsgreaterthanequal _ -> false
          | Opsignbitset _ -> false
          | Opslessthan _ -> false
          | Opslessthanequal _ -> false
          | Opugreaterthan _ -> false
          | Opugreaterthanequal _ -> false
          | Opulessthan _ -> false
          | Opulessthanequal _ -> false
          | Opunordered _ -> false
        let value =
          function
          | Opall t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 155l in
              heading :: payload
          | Opany t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.vector]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 154l in
              heading :: payload
          | Opfordequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 180l in
              heading :: payload
          | Opfordgreaterthan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 186l in
              heading :: payload
          | Opfordgreaterthanequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 190l in
              heading :: payload
          | Opfordlessthan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 184l in
              heading :: payload
          | Opfordlessthanequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 188l in
              heading :: payload
          | Opfordnotequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 182l in
              heading :: payload
          | Opfunordequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 181l in
              heading :: payload
          | Opfunordgreaterthan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 187l in
              heading :: payload
          | Opfunordgreaterthanequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 191l in
              heading :: payload
          | Opfunordlessthan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 185l in
              heading :: payload
          | Opfunordlessthanequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 189l in
              heading :: payload
          | Opfunordnotequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 183l in
              heading :: payload
          | Opiequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 170l in
              heading :: payload
          | Opinotequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 171l in
              heading :: payload
          | Opisfinite t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 158l in
              heading :: payload
          | Opisinf t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 157l in
              heading :: payload
          | Opisnan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 156l in
              heading :: payload
          | Opisnormal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 159l in
              heading :: payload
          | Oplessorgreater t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.x];
                 [Operand_kind.Payload.Idref.value t.y]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 161l in
              heading :: payload
          | Oplogicaland t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 167l in
              heading :: payload
          | Oplogicalequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 164l in
              heading :: payload
          | Oplogicalnot t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 168l in
              heading :: payload
          | Oplogicalnotequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 165l in
              heading :: payload
          | Oplogicalor t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 166l in
              heading :: payload
          | Opordered t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.x];
                 [Operand_kind.Payload.Idref.value t.y]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 162l in
              heading :: payload
          | Opselect t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.condition];
                 [Operand_kind.Payload.Idref.value t.object1];
                 [Operand_kind.Payload.Idref.value t.object2]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 169l in
              heading :: payload
          | Opsgreaterthan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 173l in
              heading :: payload
          | Opsgreaterthanequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 175l in
              heading :: payload
          | Opsignbitset t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.x]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 160l in
              heading :: payload
          | Opslessthan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 177l in
              heading :: payload
          | Opslessthanequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 179l in
              heading :: payload
          | Opugreaterthan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 172l in
              heading :: payload
          | Opugreaterthanequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 174l in
              heading :: payload
          | Opulessthan t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 176l in
              heading :: payload
          | Opulessthanequal t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 178l in
              heading :: payload
          | Opunordered t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.x];
                 [Operand_kind.Payload.Idref.value t.y]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 163l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opall _ -> true
          | Opany _ -> true
          | Opfordequal _ -> true
          | Opfordgreaterthan _ -> true
          | Opfordgreaterthanequal _ -> true
          | Opfordlessthan _ -> true
          | Opfordlessthanequal _ -> true
          | Opfordnotequal _ -> true
          | Opfunordequal _ -> true
          | Opfunordgreaterthan _ -> true
          | Opfunordgreaterthanequal _ -> true
          | Opfunordlessthan _ -> true
          | Opfunordlessthanequal _ -> true
          | Opfunordnotequal _ -> true
          | Opiequal _ -> true
          | Opinotequal _ -> true
          | Opisinf _ -> true
          | Opisnan _ -> true
          | Oplogicaland _ -> true
          | Oplogicalequal _ -> true
          | Oplogicalnot _ -> true
          | Oplogicalnotequal _ -> true
          | Oplogicalor _ -> true
          | Opselect _ -> true
          | Opsgreaterthan _ -> true
          | Opsgreaterthanequal _ -> true
          | Opslessthan _ -> true
          | Opslessthanequal _ -> true
          | Opugreaterthan _ -> true
          | Opugreaterthanequal _ -> true
          | Opulessthan _ -> true
          | Opulessthanequal _ -> true
          | Opisfinite t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opisnormal t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oplessorgreater t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.y]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opordered t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.y]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsignbitset t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opunordered t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.x];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.y]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Opall _ -> true
          | Opany _ -> true
          | Opfordequal _ -> true
          | Opfordgreaterthan _ -> true
          | Opfordgreaterthanequal _ -> true
          | Opfordlessthan _ -> true
          | Opfordlessthanequal _ -> true
          | Opfordnotequal _ -> true
          | Opfunordequal _ -> true
          | Opfunordgreaterthan _ -> true
          | Opfunordgreaterthanequal _ -> true
          | Opfunordlessthan _ -> true
          | Opfunordlessthanequal _ -> true
          | Opfunordnotequal _ -> true
          | Opiequal _ -> true
          | Opinotequal _ -> true
          | Opisfinite _ -> true
          | Opisinf _ -> true
          | Opisnan _ -> true
          | Opisnormal _ -> true
          | Oplessorgreater _ -> true
          | Oplogicaland _ -> true
          | Oplogicalequal _ -> true
          | Oplogicalnot _ -> true
          | Oplogicalnotequal _ -> true
          | Oplogicalor _ -> true
          | Opordered _ -> true
          | Opselect _ -> true
          | Opsgreaterthan _ -> true
          | Opsgreaterthanequal _ -> true
          | Opsignbitset _ -> true
          | Opslessthan _ -> true
          | Opslessthanequal _ -> true
          | Opugreaterthan _ -> true
          | Opugreaterthanequal _ -> true
          | Opulessthan _ -> true
          | Opulessthanequal _ -> true
          | Opunordered _ -> true
        let satisfies_version t ~version =
          match t with
          | Opall t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opany t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.vector]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfordequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfordgreaterthan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfordgreaterthanequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfordlessthan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfordlessthanequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfordnotequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunordequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunordgreaterthan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunordgreaterthanequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunordlessthan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunordlessthanequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfunordnotequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opiequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opinotequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opisfinite t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opisinf t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opisnan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opisnormal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Oplessorgreater t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:(Some V1_5))
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.x];
                 [Operand_kind.Payload.Idref.satisfies_version t.y]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Oplogicaland t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oplogicalequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oplogicalnot t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Oplogicalnotequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oplogicalor t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opordered t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.x];
                 [Operand_kind.Payload.Idref.satisfies_version t.y]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opselect t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.condition];
                 [Operand_kind.Payload.Idref.satisfies_version t.object1];
                 [Operand_kind.Payload.Idref.satisfies_version t.object2]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsgreaterthan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsgreaterthanequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsignbitset t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.x]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opslessthan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opslessthanequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opugreaterthan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opugreaterthanequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opulessthan t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opulessthanequal t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opunordered t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.x];
                 [Operand_kind.Payload.Idref.satisfies_version t.y]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Reserved =
      struct
        type t =
          | Opabsisubintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opabsusubintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opallocatenodepayloadsamdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          visibility: Operand_kind.Payload.Idscope.t ;
          payloadcount: Operand_kind.Payload.Idref.t ;
          nodeindex: Operand_kind.Payload.Idref.t } 
          | Opbegininvocationinterlockext 
          | Opconstantstringamdx of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          literalstring: Operand_kind.Payload.Literalstring.t } 
          | Opconvertimagetounv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertsampledimagetounv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertsamplertounv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertutoaccelerationstructurekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          accel: Operand_kind.Payload.Idref.t } 
          | Opconvertutoimagenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertutosampledimagenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertutosamplernv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixlengthnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          type_: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixloadnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t ;
          columnmajor: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativematrixmuladdnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          b: Operand_kind.Payload.Idref.t ;
          c: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixstorenv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t ;
          columnmajor: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativevectormatrixmuladdnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          inputinterpretation: Operand_kind.Payload.Idref.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          matrixoffset: Operand_kind.Payload.Idref.t ;
          matrixinterpretation: Operand_kind.Payload.Idref.t ;
          bias: Operand_kind.Payload.Idref.t ;
          biasoffset: Operand_kind.Payload.Idref.t ;
          biasinterpretation: Operand_kind.Payload.Idref.t ;
          m: Operand_kind.Payload.Idref.t ;
          k: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          transpose: Operand_kind.Payload.Idref.t ;
          matrixstride: Operand_kind.Payload.Idref.t option ;
          cooperativematrixoperands:
            Operand_kind.Payload.Cooperativematrixoperands.t option }
          
          | Opcooperativevectormatrixmulnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          inputinterpretation: Operand_kind.Payload.Idref.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          matrixoffset: Operand_kind.Payload.Idref.t ;
          matrixinterpretation: Operand_kind.Payload.Idref.t ;
          m: Operand_kind.Payload.Idref.t ;
          k: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          transpose: Operand_kind.Payload.Idref.t ;
          matrixstride: Operand_kind.Payload.Idref.t option ;
          cooperativematrixoperands:
            Operand_kind.Payload.Cooperativematrixoperands.t option }
          
          | Opcooperativevectorouterproductaccumulatenv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          a: Operand_kind.Payload.Idref.t ;
          b: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          matrixinterpretation: Operand_kind.Payload.Idref.t ;
          matrixstride: Operand_kind.Payload.Idref.t option } 
          | Opcooperativevectorreducesumaccumulatenv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          v: Operand_kind.Payload.Idref.t } 
          | Opcreatetensorlayoutnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opcreatetensorviewnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opemitmeshtasksext of
          {
          groupcountx: Operand_kind.Payload.Idref.t ;
          groupcounty: Operand_kind.Payload.Idref.t ;
          groupcountz: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t option } 
          | Opendinvocationinterlockext 
          | Openqueuenodepayloadsamdx of
          {
          payloadarray: Operand_kind.Payload.Idref.t } 
          | Opexecutecallablekhr of
          {
          sbtindex: Operand_kind.Payload.Idref.t ;
          callabledata: Operand_kind.Payload.Idref.t } 
          | Opexecutecallablenv of
          {
          sbtindex: Operand_kind.Payload.Idref.t ;
          callabledataid: Operand_kind.Payload.Idref.t } 
          | Opfetchmicrotrianglevertexbarycentricnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          accel: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          primitiveindex: Operand_kind.Payload.Idref.t ;
          barycentric: Operand_kind.Payload.Idref.t } 
          | Opfetchmicrotrianglevertexpositionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          accel: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          primitiveindex: Operand_kind.Payload.Idref.t ;
          barycentric: Operand_kind.Payload.Idref.t } 
          | Opfinishwritingnodepayloadamdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opfragmentfetchamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          fragmentindex: Operand_kind.Payload.Idref.t } 
          | Opfragmentmaskfetchamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Ophitobjectexecuteshaderext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjectexecuteshadernv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetattributesext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          hitobjectattribute: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetattributesnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          hitobjectattribute: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetclusteridnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetcurrenttimeext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetcurrenttimenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetgeometryindexext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetgeometryindexnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgethitkindext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgethitkindnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetinstancecustomindexext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetinstancecustomindexnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetinstanceidext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetinstanceidnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetintersectiontrianglevertexpositionsext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetlsspositionsnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetlssradiinv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjectraydirectionext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjectraydirectionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjectrayoriginext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjectrayoriginnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjecttoworldext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjecttoworldnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetprimitiveindexext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetprimitiveindexnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetrayflagsext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetraytmaxext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetraytmaxnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetraytminext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetraytminnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetshaderbindingtablerecordindexext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetshaderbindingtablerecordindexnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetshaderrecordbufferhandleext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetshaderrecordbufferhandlenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetspherepositionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetsphereradiusnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldraydirectionext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldraydirectionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldrayoriginext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldrayoriginnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldtoobjectext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldtoobjectnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectisemptyext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectisemptynv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectishitext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectishitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectislsshitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectismissext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectismissnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectisspherehitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordemptyext of
          {
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordemptynv of
          {
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordfromqueryext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          sbtrecordindex: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordhitmotionnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          primitiveid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t ;
          sbtrecordoffset: Operand_kind.Payload.Idref.t ;
          sbtrecordstride: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordhitnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          primitiveid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t ;
          sbtrecordoffset: Operand_kind.Payload.Idref.t ;
          sbtrecordstride: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordhitwithindexmotionnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          primitiveid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t ;
          sbtrecordindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordhitwithindexnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          primitiveid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t ;
          sbtrecordindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordmissext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordmissmotionext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordmissmotionnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          sbtindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordmissnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          sbtindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t } 
          | Ophitobjectreorderexecuteshaderext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Ophitobjectsetshaderbindingtablerecordindexext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          sbtrecordindex: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttracemotionreorderexecuteext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Ophitobjecttracerayext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttraceraymotionext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttraceraymotionnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtrecordoffset: Operand_kind.Payload.Idref.t ;
          sbtrecordstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          time: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttraceraynv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtrecordoffset: Operand_kind.Payload.Idref.t ;
          sbtrecordstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttracereorderexecuteext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Opiaddsatintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiaverageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiaverageroundedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opignoreintersectionkhr 
          | Opignoreintersectionnv 
          | Opimul32x16intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opishelperinvocationext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opisnodepayloadvalidamdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payloadtype: Operand_kind.Payload.Idref.t ;
          nodeindex: Operand_kind.Payload.Idref.t } 
          | Opisubsatintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oploopcontrolintel of
          {
          loopcontrolparameters: Operand_kind.Payload.Literalinteger.t list }
          
          | Opnodepayloadarraylengthamdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payloadarray: Operand_kind.Payload.Idref.t } 
          | Oprayqueryconfirmintersectionkhr of
          {
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygenerateintersectionkhr of
          {
          rayquery: Operand_kind.Payload.Idref.t ;
          hitt: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionbarycentricskhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectioncandidateaabbopaquekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionclusteridnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionfrontfacekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectiongeometryindexkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectioninstancecustomindexkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectioninstanceidkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          |
          Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionlsshitvaluenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionlsspositionsnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionlssradiinv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionobjectraydirectionkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionobjectrayoriginkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionobjecttoworldkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionprimitiveindexkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionspherepositionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionsphereradiusnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectiontkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectiontrianglevertexpositionskhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectiontypekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionworldtoobjectkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetrayflagskhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetraytminkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetworldraydirectionkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetworldrayoriginkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayqueryinitializekhr of
          {
          rayquery: Operand_kind.Payload.Idref.t ;
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t } 
          | Oprayqueryislsshitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayqueryisspherehitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayqueryproceedkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayqueryterminatekhr of
          {
          rayquery: Operand_kind.Payload.Idref.t } 
          | Opreadclockkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          scope: Operand_kind.Payload.Idscope.t } 
          | Opreorderthreadwithhintext of
          {
          hint: Operand_kind.Payload.Idref.t ;
          bits: Operand_kind.Payload.Idref.t } 
          | Opreorderthreadwithhintnv of
          {
          hint: Operand_kind.Payload.Idref.t ;
          bits: Operand_kind.Payload.Idref.t } 
          | Opreorderthreadwithhitobjectext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Opreorderthreadwithhitobjectnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Opreportintersectionkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hit: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t } 
          | Opsamplerimageaddressingmodenv of
          {
          bitwidth: Operand_kind.Payload.Literalinteger.t } 
          | Opsetmeshoutputsext of
          {
          vertexcount: Operand_kind.Payload.Idref.t ;
          primitivecount: Operand_kind.Payload.Idref.t } 
          | Opspecconstantstringamdx of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          literalstring: Operand_kind.Payload.Literalstring.t } 
          | Optensorlayoutsetblocksizenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t list } 
          | Optensorlayoutsetclampvaluenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Optensorlayoutsetdimensionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          dim: Operand_kind.Payload.Idref.t list } 
          | Optensorlayoutsetstridenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t list } 
          | Optensorlayoutslicenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          operands: Operand_kind.Payload.Idref.t list } 
          | Optensorviewsetclipnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorview: Operand_kind.Payload.Idref.t ;
          cliprowoffset: Operand_kind.Payload.Idref.t ;
          cliprowspan: Operand_kind.Payload.Idref.t ;
          clipcoloffset: Operand_kind.Payload.Idref.t ;
          clipcolspan: Operand_kind.Payload.Idref.t } 
          | Optensorviewsetdimensionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorview: Operand_kind.Payload.Idref.t ;
          dim: Operand_kind.Payload.Idref.t list } 
          | Optensorviewsetstridenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorview: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t list } 
          | Opterminateraykhr 
          | Opterminateraynv 
          | Optracemotionnv of
          {
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          time: Operand_kind.Payload.Idref.t ;
          payloadid: Operand_kind.Payload.Idref.t } 
          | Optracenv of
          {
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          payloadid: Operand_kind.Payload.Idref.t } 
          | Optraceraykhr of
          {
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Optraceraymotionnv of
          {
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          time: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Optypenodepayloadarrayamdx of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          payloadtype: Operand_kind.Payload.Idref.t } 
          | Opuaddsatintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opuaverageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opuaverageroundedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opucountleadingzerosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opucounttrailingzerosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opumul32x16intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opusubsatintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opwritepackedprimitiveindices4x8nv of
          {
          indexoffset: Operand_kind.Payload.Idref.t ;
          packedindices: Operand_kind.Payload.Idref.t } [@@deriving
                                                          compare, sexp_of]
        let provisional =
          function
          | Opabsisubintel _ -> false
          | Opabsusubintel _ -> false
          | Opallocatenodepayloadsamdx _ -> true
          | Opbegininvocationinterlockext -> false
          | Opconstantstringamdx _ -> true
          | Opconvertimagetounv _ -> false
          | Opconvertsampledimagetounv _ -> false
          | Opconvertsamplertounv _ -> false
          | Opconvertutoaccelerationstructurekhr _ -> false
          | Opconvertutoimagenv _ -> false
          | Opconvertutosampledimagenv _ -> false
          | Opconvertutosamplernv _ -> false
          | Opcooperativematrixlengthnv _ -> false
          | Opcooperativematrixloadnv _ -> false
          | Opcooperativematrixmuladdnv _ -> false
          | Opcooperativematrixstorenv _ -> false
          | Opcooperativevectormatrixmuladdnv _ -> false
          | Opcooperativevectormatrixmulnv _ -> false
          | Opcooperativevectorouterproductaccumulatenv _ -> false
          | Opcooperativevectorreducesumaccumulatenv _ -> false
          | Opcreatetensorlayoutnv _ -> false
          | Opcreatetensorviewnv _ -> false
          | Opemitmeshtasksext _ -> false
          | Opendinvocationinterlockext -> false
          | Openqueuenodepayloadsamdx _ -> true
          | Opexecutecallablekhr _ -> false
          | Opexecutecallablenv _ -> false
          | Opfetchmicrotrianglevertexbarycentricnv _ -> false
          | Opfetchmicrotrianglevertexpositionnv _ -> false
          | Opfinishwritingnodepayloadamdx _ -> true
          | Opfragmentfetchamd _ -> false
          | Opfragmentmaskfetchamd _ -> false
          | Ophitobjectexecuteshaderext _ -> false
          | Ophitobjectexecuteshadernv _ -> false
          | Ophitobjectgetattributesext _ -> false
          | Ophitobjectgetattributesnv _ -> false
          | Ophitobjectgetclusteridnv _ -> false
          | Ophitobjectgetcurrenttimeext _ -> false
          | Ophitobjectgetcurrenttimenv _ -> false
          | Ophitobjectgetgeometryindexext _ -> false
          | Ophitobjectgetgeometryindexnv _ -> false
          | Ophitobjectgethitkindext _ -> false
          | Ophitobjectgethitkindnv _ -> false
          | Ophitobjectgetinstancecustomindexext _ -> false
          | Ophitobjectgetinstancecustomindexnv _ -> false
          | Ophitobjectgetinstanceidext _ -> false
          | Ophitobjectgetinstanceidnv _ -> false
          | Ophitobjectgetintersectiontrianglevertexpositionsext _ -> false
          | Ophitobjectgetlsspositionsnv _ -> false
          | Ophitobjectgetlssradiinv _ -> false
          | Ophitobjectgetobjectraydirectionext _ -> false
          | Ophitobjectgetobjectraydirectionnv _ -> false
          | Ophitobjectgetobjectrayoriginext _ -> false
          | Ophitobjectgetobjectrayoriginnv _ -> false
          | Ophitobjectgetobjecttoworldext _ -> false
          | Ophitobjectgetobjecttoworldnv _ -> false
          | Ophitobjectgetprimitiveindexext _ -> false
          | Ophitobjectgetprimitiveindexnv _ -> false
          | Ophitobjectgetrayflagsext _ -> false
          | Ophitobjectgetraytmaxext _ -> false
          | Ophitobjectgetraytmaxnv _ -> false
          | Ophitobjectgetraytminext _ -> false
          | Ophitobjectgetraytminnv _ -> false
          | Ophitobjectgetshaderbindingtablerecordindexext _ -> false
          | Ophitobjectgetshaderbindingtablerecordindexnv _ -> false
          | Ophitobjectgetshaderrecordbufferhandleext _ -> false
          | Ophitobjectgetshaderrecordbufferhandlenv _ -> false
          | Ophitobjectgetspherepositionnv _ -> false
          | Ophitobjectgetsphereradiusnv _ -> false
          | Ophitobjectgetworldraydirectionext _ -> false
          | Ophitobjectgetworldraydirectionnv _ -> false
          | Ophitobjectgetworldrayoriginext _ -> false
          | Ophitobjectgetworldrayoriginnv _ -> false
          | Ophitobjectgetworldtoobjectext _ -> false
          | Ophitobjectgetworldtoobjectnv _ -> false
          | Ophitobjectisemptyext _ -> false
          | Ophitobjectisemptynv _ -> false
          | Ophitobjectishitext _ -> false
          | Ophitobjectishitnv _ -> false
          | Ophitobjectislsshitnv _ -> false
          | Ophitobjectismissext _ -> false
          | Ophitobjectismissnv _ -> false
          | Ophitobjectisspherehitnv _ -> false
          | Ophitobjectrecordemptyext _ -> false
          | Ophitobjectrecordemptynv _ -> false
          | Ophitobjectrecordfromqueryext _ -> false
          | Ophitobjectrecordhitmotionnv _ -> false
          | Ophitobjectrecordhitnv _ -> false
          | Ophitobjectrecordhitwithindexmotionnv _ -> false
          | Ophitobjectrecordhitwithindexnv _ -> false
          | Ophitobjectrecordmissext _ -> false
          | Ophitobjectrecordmissmotionext _ -> false
          | Ophitobjectrecordmissmotionnv _ -> false
          | Ophitobjectrecordmissnv _ -> false
          | Ophitobjectreorderexecuteshaderext _ -> false
          | Ophitobjectsetshaderbindingtablerecordindexext _ -> false
          | Ophitobjecttracemotionreorderexecuteext _ -> false
          | Ophitobjecttracerayext _ -> false
          | Ophitobjecttraceraymotionext _ -> false
          | Ophitobjecttraceraymotionnv _ -> false
          | Ophitobjecttraceraynv _ -> false
          | Ophitobjecttracereorderexecuteext _ -> false
          | Opiaddsatintel _ -> false
          | Opiaverageintel _ -> false
          | Opiaverageroundedintel _ -> false
          | Opignoreintersectionkhr -> false
          | Opignoreintersectionnv -> false
          | Opimul32x16intel _ -> false
          | Opishelperinvocationext _ -> false
          | Opisnodepayloadvalidamdx _ -> true
          | Opisubsatintel _ -> false
          | Oploopcontrolintel _ -> false
          | Opnodepayloadarraylengthamdx _ -> true
          | Oprayqueryconfirmintersectionkhr _ -> false
          | Oprayquerygenerateintersectionkhr _ -> false
          | Oprayquerygetintersectionbarycentricskhr _ -> false
          | Oprayquerygetintersectioncandidateaabbopaquekhr _ -> false
          | Oprayquerygetintersectionclusteridnv _ -> false
          | Oprayquerygetintersectionfrontfacekhr _ -> false
          | Oprayquerygetintersectiongeometryindexkhr _ -> false
          | Oprayquerygetintersectioninstancecustomindexkhr _ -> false
          | Oprayquerygetintersectioninstanceidkhr _ -> false
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              _ -> false
          | Oprayquerygetintersectionlsshitvaluenv _ -> false
          | Oprayquerygetintersectionlsspositionsnv _ -> false
          | Oprayquerygetintersectionlssradiinv _ -> false
          | Oprayquerygetintersectionobjectraydirectionkhr _ -> false
          | Oprayquerygetintersectionobjectrayoriginkhr _ -> false
          | Oprayquerygetintersectionobjecttoworldkhr _ -> false
          | Oprayquerygetintersectionprimitiveindexkhr _ -> false
          | Oprayquerygetintersectionspherepositionnv _ -> false
          | Oprayquerygetintersectionsphereradiusnv _ -> false
          | Oprayquerygetintersectiontkhr _ -> false
          | Oprayquerygetintersectiontrianglevertexpositionskhr _ -> false
          | Oprayquerygetintersectiontypekhr _ -> false
          | Oprayquerygetintersectionworldtoobjectkhr _ -> false
          | Oprayquerygetrayflagskhr _ -> false
          | Oprayquerygetraytminkhr _ -> false
          | Oprayquerygetworldraydirectionkhr _ -> false
          | Oprayquerygetworldrayoriginkhr _ -> false
          | Oprayqueryinitializekhr _ -> false
          | Oprayqueryislsshitnv _ -> false
          | Oprayqueryisspherehitnv _ -> false
          | Oprayqueryproceedkhr _ -> false
          | Oprayqueryterminatekhr _ -> false
          | Opreadclockkhr _ -> false
          | Opreorderthreadwithhintext _ -> false
          | Opreorderthreadwithhintnv _ -> false
          | Opreorderthreadwithhitobjectext _ -> false
          | Opreorderthreadwithhitobjectnv _ -> false
          | Opreportintersectionkhr _ -> false
          | Opsamplerimageaddressingmodenv _ -> false
          | Opsetmeshoutputsext _ -> false
          | Opspecconstantstringamdx _ -> true
          | Optensorlayoutsetblocksizenv _ -> false
          | Optensorlayoutsetclampvaluenv _ -> false
          | Optensorlayoutsetdimensionnv _ -> false
          | Optensorlayoutsetstridenv _ -> false
          | Optensorlayoutslicenv _ -> false
          | Optensorviewsetclipnv _ -> false
          | Optensorviewsetdimensionnv _ -> false
          | Optensorviewsetstridenv _ -> false
          | Opterminateraykhr -> false
          | Opterminateraynv -> false
          | Optracemotionnv _ -> false
          | Optracenv _ -> false
          | Optraceraykhr _ -> false
          | Optraceraymotionnv _ -> false
          | Optypenodepayloadarrayamdx _ -> true
          | Opuaddsatintel _ -> false
          | Opuaverageintel _ -> false
          | Opuaverageroundedintel _ -> false
          | Opucountleadingzerosintel _ -> false
          | Opucounttrailingzerosintel _ -> false
          | Opumul32x16intel _ -> false
          | Opusubsatintel _ -> false
          | Opwritepackedprimitiveindices4x8nv _ -> false
        let value =
          function
          | Opabsisubintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5587l in
              heading :: payload
          | Opabsusubintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5588l in
              heading :: payload
          | Opallocatenodepayloadsamdx t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.visibility];
                 [Operand_kind.Payload.Idref.value t.payloadcount];
                 [Operand_kind.Payload.Idref.value t.nodeindex]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5074l in
              heading :: payload
          | Opbegininvocationinterlockext ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5364l in
              [heading]
          | Opconstantstringamdx t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalstring.value t.literalstring]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5103l in
              heading :: payload
          | Opconvertimagetounv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5393l in
              heading :: payload
          | Opconvertsampledimagetounv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5396l in
              heading :: payload
          | Opconvertsamplertounv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5394l in
              heading :: payload
          | Opconvertutoaccelerationstructurekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.accel]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4447l in
              heading :: payload
          | Opconvertutoimagenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5391l in
              heading :: payload
          | Opconvertutosampledimagenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5395l in
              heading :: payload
          | Opconvertutosamplernv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5392l in
              heading :: payload
          | Opcooperativematrixlengthnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.type_]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5362l in
              heading :: payload
          | Opcooperativematrixloadnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.stride];
                 [Operand_kind.Payload.Idref.value t.columnmajor];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5359l in
              heading :: payload
          | Opcooperativematrixmuladdnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Idref.value t.c]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5361l in
              heading :: payload
          | Opcooperativematrixstorenv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.object_];
                 [Operand_kind.Payload.Idref.value t.stride];
                 [Operand_kind.Payload.Idref.value t.columnmajor];
                 (t.memoryaccess |>
                    (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5360l in
              heading :: payload
          | Opcooperativevectormatrixmuladdnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Idref.value t.inputinterpretation];
                 [Operand_kind.Payload.Idref.value t.matrix];
                 [Operand_kind.Payload.Idref.value t.matrixoffset];
                 [Operand_kind.Payload.Idref.value t.matrixinterpretation];
                 [Operand_kind.Payload.Idref.value t.bias];
                 [Operand_kind.Payload.Idref.value t.biasoffset];
                 [Operand_kind.Payload.Idref.value t.biasinterpretation];
                 [Operand_kind.Payload.Idref.value t.m];
                 [Operand_kind.Payload.Idref.value t.k];
                 [Operand_kind.Payload.Idref.value t.memorylayout];
                 [Operand_kind.Payload.Idref.value t.transpose];
                 (t.matrixstride |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5292l in
              heading :: payload
          | Opcooperativevectormatrixmulnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.input];
                 [Operand_kind.Payload.Idref.value t.inputinterpretation];
                 [Operand_kind.Payload.Idref.value t.matrix];
                 [Operand_kind.Payload.Idref.value t.matrixoffset];
                 [Operand_kind.Payload.Idref.value t.matrixinterpretation];
                 [Operand_kind.Payload.Idref.value t.m];
                 [Operand_kind.Payload.Idref.value t.k];
                 [Operand_kind.Payload.Idref.value t.memorylayout];
                 [Operand_kind.Payload.Idref.value t.transpose];
                 (t.matrixstride |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5289l in
              heading :: payload
          | Opcooperativevectorouterproductaccumulatenv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.offset];
                 [Operand_kind.Payload.Idref.value t.a];
                 [Operand_kind.Payload.Idref.value t.b];
                 [Operand_kind.Payload.Idref.value t.memorylayout];
                 [Operand_kind.Payload.Idref.value t.matrixinterpretation];
                 (t.matrixstride |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5290l in
              heading :: payload
          | Opcooperativevectorreducesumaccumulatenv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointer];
                 [Operand_kind.Payload.Idref.value t.offset];
                 [Operand_kind.Payload.Idref.value t.v]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5291l in
              heading :: payload
          | Opcreatetensorlayoutnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5372l in
              heading :: payload
          | Opcreatetensorviewnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5377l in
              heading :: payload
          | Opemitmeshtasksext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.groupcountx];
                 [Operand_kind.Payload.Idref.value t.groupcounty];
                 [Operand_kind.Payload.Idref.value t.groupcountz];
                 (t.payload |>
                    (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5294l in
              heading :: payload
          | Opendinvocationinterlockext ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5365l in
              [heading]
          | Openqueuenodepayloadsamdx t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.payloadarray]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5075l in
              heading :: payload
          | Opexecutecallablekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.sbtindex];
                 [Operand_kind.Payload.Idref.value t.callabledata]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4446l in
              heading :: payload
          | Opexecutecallablenv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.sbtindex];
                 [Operand_kind.Payload.Idref.value t.callabledataid]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5344l in
              heading :: payload
          | Opfetchmicrotrianglevertexbarycentricnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.accel];
                 [Operand_kind.Payload.Idref.value t.instanceid];
                 [Operand_kind.Payload.Idref.value t.geometryindex];
                 [Operand_kind.Payload.Idref.value t.primitiveindex];
                 [Operand_kind.Payload.Idref.value t.barycentric]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5301l in
              heading :: payload
          | Opfetchmicrotrianglevertexpositionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.accel];
                 [Operand_kind.Payload.Idref.value t.instanceid];
                 [Operand_kind.Payload.Idref.value t.geometryindex];
                 [Operand_kind.Payload.Idref.value t.primitiveindex];
                 [Operand_kind.Payload.Idref.value t.barycentric]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5300l in
              heading :: payload
          | Opfinishwritingnodepayloadamdx t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5078l in
              heading :: payload
          | Opfragmentfetchamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate];
                 [Operand_kind.Payload.Idref.value t.fragmentindex]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5012l in
              heading :: payload
          | Opfragmentmaskfetchamd t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.image];
                 [Operand_kind.Payload.Idref.value t.coordinate]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5011l in
              heading :: payload
          | Ophitobjectexecuteshaderext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5319l in
              heading :: payload
          | Ophitobjectexecuteshadernv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5264l in
              heading :: payload
          | Ophitobjectgetattributesext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.hitobjectattribute]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5321l in
              heading :: payload
          | Ophitobjectgetattributesnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.hitobjectattribute]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5266l in
              heading :: payload
          | Ophitobjectgetclusteridnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5346l in
              heading :: payload
          | Ophitobjectgetcurrenttimeext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5320l in
              heading :: payload
          | Ophitobjectgetcurrenttimenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5265l in
              heading :: payload
          | Ophitobjectgetgeometryindexext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5324l in
              heading :: payload
          | Ophitobjectgetgeometryindexnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5269l in
              heading :: payload
          | Ophitobjectgethitkindext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5322l in
              heading :: payload
          | Ophitobjectgethitkindnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5267l in
              heading :: payload
          | Ophitobjectgetinstancecustomindexext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5326l in
              heading :: payload
          | Ophitobjectgetinstancecustomindexnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5271l in
              heading :: payload
          | Ophitobjectgetinstanceidext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5325l in
              heading :: payload
          | Ophitobjectgetinstanceidnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5270l in
              heading :: payload
          | Ophitobjectgetintersectiontrianglevertexpositionsext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5307l in
              heading :: payload
          | Ophitobjectgetlsspositionsnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5434l in
              heading :: payload
          | Ophitobjectgetlssradiinv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5435l in
              heading :: payload
          | Ophitobjectgetobjectraydirectionext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5328l in
              heading :: payload
          | Ophitobjectgetobjectraydirectionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5254l in
              heading :: payload
          | Ophitobjectgetobjectrayoriginext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5327l in
              heading :: payload
          | Ophitobjectgetobjectrayoriginnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5255l in
              heading :: payload
          | Ophitobjectgetobjecttoworldext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5331l in
              heading :: payload
          | Ophitobjectgetobjecttoworldnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5253l in
              heading :: payload
          | Ophitobjectgetprimitiveindexext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5323l in
              heading :: payload
          | Ophitobjectgetprimitiveindexnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5268l in
              heading :: payload
          | Ophitobjectgetrayflagsext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5308l in
              heading :: payload
          | Ophitobjectgetraytmaxext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5333l in
              heading :: payload
          | Ophitobjectgetraytmaxnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5274l in
              heading :: payload
          | Ophitobjectgetraytminext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5347l in
              heading :: payload
          | Ophitobjectgetraytminnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5275l in
              heading :: payload
          | Ophitobjectgetshaderbindingtablerecordindexext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5348l in
              heading :: payload
          | Ophitobjectgetshaderbindingtablerecordindexnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5258l in
              heading :: payload
          | Ophitobjectgetshaderrecordbufferhandleext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5349l in
              heading :: payload
          | Ophitobjectgetshaderrecordbufferhandlenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5257l in
              heading :: payload
          | Ophitobjectgetspherepositionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5432l in
              heading :: payload
          | Ophitobjectgetsphereradiusnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5433l in
              heading :: payload
          | Ophitobjectgetworldraydirectionext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5329l in
              heading :: payload
          | Ophitobjectgetworldraydirectionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5272l in
              heading :: payload
          | Ophitobjectgetworldrayoriginext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5330l in
              heading :: payload
          | Ophitobjectgetworldrayoriginnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5273l in
              heading :: payload
          | Ophitobjectgetworldtoobjectext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5332l in
              heading :: payload
          | Ophitobjectgetworldtoobjectnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5252l in
              heading :: payload
          | Ophitobjectisemptyext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5350l in
              heading :: payload
          | Ophitobjectisemptynv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5276l in
              heading :: payload
          | Ophitobjectishitext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5351l in
              heading :: payload
          | Ophitobjectishitnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5277l in
              heading :: payload
          | Ophitobjectislsshitnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5437l in
              heading :: payload
          | Ophitobjectismissext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5352l in
              heading :: payload
          | Ophitobjectismissnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5278l in
              heading :: payload
          | Ophitobjectisspherehitnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5436l in
              heading :: payload
          | Ophitobjectrecordemptyext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5318l in
              heading :: payload
          | Ophitobjectrecordemptynv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5259l in
              heading :: payload
          | Ophitobjectrecordfromqueryext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.value t.hitobjectattributes]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5304l in
              heading :: payload
          | Ophitobjectrecordhitmotionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.instanceid];
                 [Operand_kind.Payload.Idref.value t.primitiveid];
                 [Operand_kind.Payload.Idref.value t.geometryindex];
                 [Operand_kind.Payload.Idref.value t.hitkind];
                 [Operand_kind.Payload.Idref.value t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.value t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.value t.origin];
                 [Operand_kind.Payload.Idref.value t.tmin];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.tmax];
                 [Operand_kind.Payload.Idref.value t.currenttime];
                 [Operand_kind.Payload.Idref.value t.hitobjectattributes]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5249l in
              heading :: payload
          | Ophitobjectrecordhitnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.instanceid];
                 [Operand_kind.Payload.Idref.value t.primitiveid];
                 [Operand_kind.Payload.Idref.value t.geometryindex];
                 [Operand_kind.Payload.Idref.value t.hitkind];
                 [Operand_kind.Payload.Idref.value t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.value t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.value t.origin];
                 [Operand_kind.Payload.Idref.value t.tmin];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.tmax];
                 [Operand_kind.Payload.Idref.value t.hitobjectattributes]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5261l in
              heading :: payload
          | Ophitobjectrecordhitwithindexmotionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.instanceid];
                 [Operand_kind.Payload.Idref.value t.primitiveid];
                 [Operand_kind.Payload.Idref.value t.geometryindex];
                 [Operand_kind.Payload.Idref.value t.hitkind];
                 [Operand_kind.Payload.Idref.value t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.value t.origin];
                 [Operand_kind.Payload.Idref.value t.tmin];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.tmax];
                 [Operand_kind.Payload.Idref.value t.currenttime];
                 [Operand_kind.Payload.Idref.value t.hitobjectattributes]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5250l in
              heading :: payload
          | Ophitobjectrecordhitwithindexnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.instanceid];
                 [Operand_kind.Payload.Idref.value t.primitiveid];
                 [Operand_kind.Payload.Idref.value t.geometryindex];
                 [Operand_kind.Payload.Idref.value t.hitkind];
                 [Operand_kind.Payload.Idref.value t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.value t.origin];
                 [Operand_kind.Payload.Idref.value t.tmin];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.tmax];
                 [Operand_kind.Payload.Idref.value t.hitobjectattributes]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5262l in
              heading :: payload
          | Ophitobjectrecordmissext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5305l in
              heading :: payload
          | Ophitobjectrecordmissmotionext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.currenttime]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5306l in
              heading :: payload
          | Ophitobjectrecordmissmotionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.sbtindex];
                 [Operand_kind.Payload.Idref.value t.origin];
                 [Operand_kind.Payload.Idref.value t.tmin];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.tmax];
                 [Operand_kind.Payload.Idref.value t.currenttime]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5251l in
              heading :: payload
          | Ophitobjectrecordmissnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.sbtindex];
                 [Operand_kind.Payload.Idref.value t.origin];
                 [Operand_kind.Payload.Idref.value t.tmin];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.tmax]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5263l in
              heading :: payload
          | Ophitobjectreorderexecuteshaderext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.payload];
                 (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5310l in
              heading :: payload
          | Ophitobjectsetshaderbindingtablerecordindexext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.sbtrecordindex]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5309l in
              heading :: payload
          | Ophitobjecttracemotionreorderexecuteext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtoffset];
                 [Operand_kind.Payload.Idref.value t.sbtstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.currenttime];
                 [Operand_kind.Payload.Idref.value t.payload];
                 (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5312l in
              heading :: payload
          | Ophitobjecttracerayext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtoffset];
                 [Operand_kind.Payload.Idref.value t.sbtstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5316l in
              heading :: payload
          | Ophitobjecttraceraymotionext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtoffset];
                 [Operand_kind.Payload.Idref.value t.sbtstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.currenttime];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5317l in
              heading :: payload
          | Ophitobjecttraceraymotionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.value t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.origin];
                 [Operand_kind.Payload.Idref.value t.tmin];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.tmax];
                 [Operand_kind.Payload.Idref.value t.time];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5256l in
              heading :: payload
          | Ophitobjecttraceraynv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.value t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.origin];
                 [Operand_kind.Payload.Idref.value t.tmin];
                 [Operand_kind.Payload.Idref.value t.direction];
                 [Operand_kind.Payload.Idref.value t.tmax];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5260l in
              heading :: payload
          | Ophitobjecttracereorderexecuteext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 [Operand_kind.Payload.Idref.value t.accelerationstructure];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtoffset];
                 [Operand_kind.Payload.Idref.value t.sbtstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.payload];
                 (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5311l in
              heading :: payload
          | Opiaddsatintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5589l in
              heading :: payload
          | Opiaverageintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5591l in
              heading :: payload
          | Opiaverageroundedintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5593l in
              heading :: payload
          | Opignoreintersectionkhr ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 4448l in
              [heading]
          | Opignoreintersectionnv ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5335l in
              [heading]
          | Opimul32x16intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5597l in
              heading :: payload
          | Opishelperinvocationext t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5381l in
              heading :: payload
          | Opisnodepayloadvalidamdx t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payloadtype];
                 [Operand_kind.Payload.Idref.value t.nodeindex]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5101l in
              heading :: payload
          | Opisubsatintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5595l in
              heading :: payload
          | Oploopcontrolintel t ->
              let payload =
                ([List.map t.loopcontrolparameters
                    ~f:Operand_kind.Payload.Literalinteger.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5887l in
              heading :: payload
          | Opnodepayloadarraylengthamdx t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payloadarray]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5090l in
              heading :: payload
          | Oprayqueryconfirmintersectionkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.rayquery]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4476l in
              heading :: payload
          | Oprayquerygenerateintersectionkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.hitt]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4475l in
              heading :: payload
          | Oprayquerygetintersectionbarycentricskhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6024l in
              heading :: payload
          | Oprayquerygetintersectioncandidateaabbopaquekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6026l in
              heading :: payload
          | Oprayquerygetintersectionclusteridnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5345l in
              heading :: payload
          | Oprayquerygetintersectionfrontfacekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6025l in
              heading :: payload
          | Oprayquerygetintersectiongeometryindexkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6022l in
              heading :: payload
          | Oprayquerygetintersectioninstancecustomindexkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6019l in
              heading :: payload
          | Oprayquerygetintersectioninstanceidkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6020l in
              heading :: payload
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6021l in
              heading :: payload
          | Oprayquerygetintersectionlsshitvaluenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5431l in
              heading :: payload
          | Oprayquerygetintersectionlsspositionsnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5429l in
              heading :: payload
          | Oprayquerygetintersectionlssradiinv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5430l in
              heading :: payload
          | Oprayquerygetintersectionobjectraydirectionkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6027l in
              heading :: payload
          | Oprayquerygetintersectionobjectrayoriginkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6028l in
              heading :: payload
          | Oprayquerygetintersectionobjecttoworldkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6031l in
              heading :: payload
          | Oprayquerygetintersectionprimitiveindexkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6023l in
              heading :: payload
          | Oprayquerygetintersectionspherepositionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5427l in
              heading :: payload
          | Oprayquerygetintersectionsphereradiusnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5428l in
              heading :: payload
          | Oprayquerygetintersectiontkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6018l in
              heading :: payload
          | Oprayquerygetintersectiontrianglevertexpositionskhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5340l in
              heading :: payload
          | Oprayquerygetintersectiontypekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4479l in
              heading :: payload
          | Oprayquerygetintersectionworldtoobjectkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6032l in
              heading :: payload
          | Oprayquerygetrayflagskhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6017l in
              heading :: payload
          | Oprayquerygetraytminkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6016l in
              heading :: payload
          | Oprayquerygetworldraydirectionkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6029l in
              heading :: payload
          | Oprayquerygetworldrayoriginkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6030l in
              heading :: payload
          | Oprayqueryinitializekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.accel];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4473l in
              heading :: payload
          | Oprayqueryislsshitnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5439l in
              heading :: payload
          | Oprayqueryisspherehitnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery];
                 [Operand_kind.Payload.Idref.value t.intersection]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5438l in
              heading :: payload
          | Oprayqueryproceedkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.rayquery]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4477l in
              heading :: payload
          | Oprayqueryterminatekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.rayquery]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4474l in
              heading :: payload
          | Opreadclockkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idscope.value t.scope]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5056l in
              heading :: payload
          | Opreorderthreadwithhintext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hint];
                 [Operand_kind.Payload.Idref.value t.bits]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5314l in
              heading :: payload
          | Opreorderthreadwithhintnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hint];
                 [Operand_kind.Payload.Idref.value t.bits]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5280l in
              heading :: payload
          | Opreorderthreadwithhitobjectext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5315l in
              heading :: payload
          | Opreorderthreadwithhitobjectnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.hitobject];
                 (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5279l in
              heading :: payload
          | Opreportintersectionkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.hit];
                 [Operand_kind.Payload.Idref.value t.hitkind]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5334l in
              heading :: payload
          | Opsamplerimageaddressingmodenv t ->
              let payload =
                ([[Operand_kind.Payload.Literalinteger.value t.bitwidth]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5397l in
              heading :: payload
          | Opsetmeshoutputsext t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.vertexcount];
                 [Operand_kind.Payload.Idref.value t.primitivecount]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5295l in
              heading :: payload
          | Opspecconstantstringamdx t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalstring.value t.literalstring]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5104l in
              heading :: payload
          | Optensorlayoutsetblocksizenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensorlayout];
                 List.map t.blocksize ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5384l in
              heading :: payload
          | Optensorlayoutsetclampvaluenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensorlayout];
                 [Operand_kind.Payload.Idref.value t.value]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5376l in
              heading :: payload
          | Optensorlayoutsetdimensionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensorlayout];
                 List.map t.dim ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5373l in
              heading :: payload
          | Optensorlayoutsetstridenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensorlayout];
                 List.map t.stride ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5374l in
              heading :: payload
          | Optensorlayoutslicenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensorlayout];
                 List.map t.operands ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5375l in
              heading :: payload
          | Optensorviewsetclipnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensorview];
                 [Operand_kind.Payload.Idref.value t.cliprowoffset];
                 [Operand_kind.Payload.Idref.value t.cliprowspan];
                 [Operand_kind.Payload.Idref.value t.clipcoloffset];
                 [Operand_kind.Payload.Idref.value t.clipcolspan]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5382l in
              heading :: payload
          | Optensorviewsetdimensionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensorview];
                 List.map t.dim ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5378l in
              heading :: payload
          | Optensorviewsetstridenv t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensorview];
                 List.map t.stride ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5379l in
              heading :: payload
          | Opterminateraykhr ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 4449l in
              [heading]
          | Opterminateraynv ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5336l in
              [heading]
          | Optracemotionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.accel];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtoffset];
                 [Operand_kind.Payload.Idref.value t.sbtstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.time];
                 [Operand_kind.Payload.Idref.value t.payloadid]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5338l in
              heading :: payload
          | Optracenv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.accel];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtoffset];
                 [Operand_kind.Payload.Idref.value t.sbtstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.payloadid]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5337l in
              heading :: payload
          | Optraceraykhr t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.accel];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtoffset];
                 [Operand_kind.Payload.Idref.value t.sbtstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4445l in
              heading :: payload
          | Optraceraymotionnv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.accel];
                 [Operand_kind.Payload.Idref.value t.rayflags];
                 [Operand_kind.Payload.Idref.value t.cullmask];
                 [Operand_kind.Payload.Idref.value t.sbtoffset];
                 [Operand_kind.Payload.Idref.value t.sbtstride];
                 [Operand_kind.Payload.Idref.value t.missindex];
                 [Operand_kind.Payload.Idref.value t.rayorigin];
                 [Operand_kind.Payload.Idref.value t.raytmin];
                 [Operand_kind.Payload.Idref.value t.raydirection];
                 [Operand_kind.Payload.Idref.value t.raytmax];
                 [Operand_kind.Payload.Idref.value t.time];
                 [Operand_kind.Payload.Idref.value t.payload]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5339l in
              heading :: payload
          | Optypenodepayloadarrayamdx t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.payloadtype]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5076l in
              heading :: payload
          | Opuaddsatintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5590l in
              heading :: payload
          | Opuaverageintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5592l in
              heading :: payload
          | Opuaverageroundedintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5594l in
              heading :: payload
          | Opucountleadingzerosintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5585l in
              heading :: payload
          | Opucounttrailingzerosintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5586l in
              heading :: payload
          | Opumul32x16intel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5598l in
              heading :: payload
          | Opusubsatintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.operand1];
                 [Operand_kind.Payload.Idref.value t.operand2]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5596l in
              heading :: payload
          | Opwritepackedprimitiveindices4x8nv t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.indexoffset];
                 [Operand_kind.Payload.Idref.value t.packedindices]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5299l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Opabsisubintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opabsusubintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opallocatenodepayloadsamdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.visibility];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.payloadcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.nodeindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opbegininvocationinterlockext ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Fragmentshadersampleinterlockext;
                       Operand_kind.Payload.Capability.Fragmentshaderpixelinterlockext;
                       Operand_kind.Payload.Capability.Fragmentshadershadingrateinterlockext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Opconstantstringamdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.literalstring]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertimagetounv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertsampledimagetounv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertsamplertounv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertutoaccelerationstructurekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingkhr;
                       Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.accel]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertutoimagenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertutosampledimagenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opconvertutosamplernv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixlengthnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.type_]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixloadnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.stride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.columnmajor];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixmuladdnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.c]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcooperativematrixstorenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.object_];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.stride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.columnmajor];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativevectormatrixmuladdnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativevectornv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.inputinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.matrixoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.matrixinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.bias];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.biasoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.biasinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.m];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.k];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorylayout];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.transpose];
                 (t.matrixstride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativevectormatrixmulnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativevectornv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.input];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.inputinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.matrixoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.matrixinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.m];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.k];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorylayout];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.transpose];
                 (t.matrixstride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativevectorouterproductaccumulatenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativevectortrainingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.offset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.a];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.b];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.memorylayout];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.matrixinterpretation];
                 (t.matrixstride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opcooperativevectorreducesumaccumulatenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativevectortrainingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.offset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.v]] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcreatetensorlayoutnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opcreatetensorviewnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opemitmeshtasksext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Meshshadingext] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.groupcountx];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.groupcounty];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.groupcountz];
                 (t.payload |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opendinvocationinterlockext ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Fragmentshadersampleinterlockext;
                       Operand_kind.Payload.Capability.Fragmentshaderpixelinterlockext;
                       Operand_kind.Payload.Capability.Fragmentshadershadingrateinterlockext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Openqueuenodepayloadsamdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.payloadarray]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opexecutecallablekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.callabledata]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opexecutecallablenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingnv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.callabledataid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfetchmicrotrianglevertexbarycentricnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Displacementmicromapnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.accel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.primitiveindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.barycentric]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfetchmicrotrianglevertexpositionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Displacementmicromapnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.accel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.primitiveindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.barycentric]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfinishwritingnodepayloadamdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfragmentfetchamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Fragmentmaskamd] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.fragmentindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opfragmentmaskfetchamd t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Fragmentmaskamd] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.image];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectexecuteshaderext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectexecuteshadernv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetattributesext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobjectattribute]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetattributesnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobjectattribute]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetclusteridnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingclusteraccelerationstructurenv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetcurrenttimeext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext;
                       Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetcurrenttimenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetgeometryindexext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetgeometryindexnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgethitkindext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgethitkindnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetinstancecustomindexext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetinstancecustomindexnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetinstanceidext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetinstanceidnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetintersectiontrianglevertexpositionsext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetlsspositionsnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetlssradiinv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetobjectraydirectionext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetobjectraydirectionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetobjectrayoriginext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetobjectrayoriginnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetobjecttoworldext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetobjecttoworldnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetprimitiveindexext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetprimitiveindexnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetrayflagsext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetraytmaxext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetraytmaxnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetraytminext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetraytminnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetshaderbindingtablerecordindexext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetshaderbindingtablerecordindexnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetshaderrecordbufferhandleext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetshaderrecordbufferhandlenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetspherepositionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetsphereradiusnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetworldraydirectionext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetworldraydirectionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetworldrayoriginext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetworldrayoriginnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetworldtoobjectext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectgetworldtoobjectnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectisemptyext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectisemptynv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectishitext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectishitnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectislsshitnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectismissext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectismissnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectisspherehitnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordemptyext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordemptynv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordfromqueryext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordhitmotionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv;
                       Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.primitiveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.hitkind];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.origin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.currenttime];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordhitnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.primitiveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.hitkind];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.origin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordhitwithindexmotionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv;
                       Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.primitiveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.hitkind];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.origin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.currenttime];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordhitwithindexnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.primitiveid];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.hitkind];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.origin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordmissext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordmissmotionext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext;
                       Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.currenttime]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordmissmotionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv;
                       Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.origin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.currenttime]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectrecordmissnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.origin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmax]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectreorderexecuteshaderext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Ophitobjectsetshaderbindingtablerecordindexext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjecttracemotionreorderexecuteext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext;
                       Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.currenttime];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Ophitobjecttracerayext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjecttraceraymotionext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext;
                       Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.currenttime];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjecttraceraymotionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv;
                       Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.origin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.time];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjecttraceraynv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.origin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.direction];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Ophitobjecttracereorderexecuteext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opiaddsatintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opiaverageintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opiaverageroundedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opignoreintersectionkhr ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Opignoreintersectionnv ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingnv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Opimul32x16intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opishelperinvocationext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Demotetohelperinvocation]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opisnodepayloadvalidamdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.payloadtype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.nodeindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opisubsatintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oploopcontrolintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Unstructuredloopcontrolsintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([List.map t.loopcontrolparameters
                    ~f:Operand_kind.Payload.Literalinteger.satisfies_capabilities]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opnodepayloadarraylengthamdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.payloadarray]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayqueryconfirmintersectionkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygenerateintersectionkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.hitt]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionbarycentricskhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectioncandidateaabbopaquekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionclusteridnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingclusteraccelerationstructurenv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionfrontfacekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectiongeometryindexkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectioninstancecustomindexkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectioninstanceidkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionlsshitvaluenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionlsspositionsnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionlssradiinv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionobjectraydirectionkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionobjectrayoriginkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionobjecttoworldkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionprimitiveindexkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionspherepositionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionsphereradiusnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectiontkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectiontrianglevertexpositionskhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerypositionfetchkhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectiontypekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetintersectionworldtoobjectkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetrayflagskhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetraytminkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetworldraydirectionkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayquerygetworldrayoriginkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayqueryinitializekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.accel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayqueryislsshitnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayqueryisspherehitnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayqueryproceedkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Oprayqueryterminatekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreadclockkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderclockkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities t.scope]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreorderthreadwithhintext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.hint];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.bits]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreorderthreadwithhintnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.hint];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.bits]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opreorderthreadwithhitobjectext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opreorderthreadwithhitobjectnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.hitobject];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Opreportintersectionkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingnv;
                       Operand_kind.Payload.Capability.Raytracingkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.hit];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.hitkind]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsamplerimageaddressingmodenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Literalinteger.satisfies_capabilities
                     t.bitwidth]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opsetmeshoutputsext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Meshshadingext] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.vertexcount];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.primitivecount]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opspecconstantstringamdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.literalstring]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorlayoutsetblocksizenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorlayout];
                 List.map t.blocksize
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorlayoutsetclampvaluenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorlayout];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.value]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorlayoutsetdimensionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorlayout];
                 List.map t.dim
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorlayoutsetstridenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorlayout];
                 List.map t.stride
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorlayoutslicenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorlayout];
                 List.map t.operands
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorviewsetclipnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorview];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cliprowoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cliprowspan];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.clipcoloffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.clipcolspan]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorviewsetdimensionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorview];
                 List.map t.dim
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorviewsetstridenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.tensorview];
                 List.map t.stride
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opterminateraykhr ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Opterminateraynv ->
              List.for_all
                [(fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingnv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities)] ~f:(fun fn -> fn ~capabilities)
          | Optracemotionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.accel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.time];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.payloadid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optracenv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingnv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.accel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.payloadid]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optraceraykhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingkhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.accel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optraceraymotionnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingmotionblurnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.accel];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.time];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypenodepayloadarrayamdx t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.payloadtype]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuaddsatintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuaverageintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opuaverageroundedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opucountleadingzerosintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opucounttrailingzerosintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.operand]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opumul32x16intel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opusubsatintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Integerfunctions2intel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Opwritepackedprimitiveindices4x8nv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Meshshadingnv] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.indexoffset];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.packedindices]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Opabsisubintel _ -> true
          | Opabsusubintel _ -> true
          | Opallocatenodepayloadsamdx _ -> true
          | Opconstantstringamdx _ -> true
          | Opconvertimagetounv _ -> true
          | Opconvertsampledimagetounv _ -> true
          | Opconvertsamplertounv _ -> true
          | Opconvertutoimagenv _ -> true
          | Opconvertutosampledimagenv _ -> true
          | Opconvertutosamplernv _ -> true
          | Opcooperativevectormatrixmuladdnv _ -> true
          | Opcooperativevectormatrixmulnv _ -> true
          | Opcooperativevectorouterproductaccumulatenv _ -> true
          | Opcooperativevectorreducesumaccumulatenv _ -> true
          | Opcreatetensorlayoutnv _ -> true
          | Opcreatetensorviewnv _ -> true
          | Opemitmeshtasksext _ -> true
          | Openqueuenodepayloadsamdx _ -> true
          | Opfetchmicrotrianglevertexbarycentricnv _ -> true
          | Opfetchmicrotrianglevertexpositionnv _ -> true
          | Opfinishwritingnodepayloadamdx _ -> true
          | Ophitobjectexecuteshaderext _ -> true
          | Ophitobjectexecuteshadernv _ -> true
          | Ophitobjectgetattributesext _ -> true
          | Ophitobjectgetattributesnv _ -> true
          | Ophitobjectgetclusteridnv _ -> true
          | Ophitobjectgetcurrenttimeext _ -> true
          | Ophitobjectgetcurrenttimenv _ -> true
          | Ophitobjectgetgeometryindexext _ -> true
          | Ophitobjectgetgeometryindexnv _ -> true
          | Ophitobjectgethitkindext _ -> true
          | Ophitobjectgethitkindnv _ -> true
          | Ophitobjectgetinstancecustomindexext _ -> true
          | Ophitobjectgetinstancecustomindexnv _ -> true
          | Ophitobjectgetinstanceidext _ -> true
          | Ophitobjectgetinstanceidnv _ -> true
          | Ophitobjectgetintersectiontrianglevertexpositionsext _ -> true
          | Ophitobjectgetlsspositionsnv _ -> true
          | Ophitobjectgetlssradiinv _ -> true
          | Ophitobjectgetobjectraydirectionext _ -> true
          | Ophitobjectgetobjectraydirectionnv _ -> true
          | Ophitobjectgetobjectrayoriginext _ -> true
          | Ophitobjectgetobjectrayoriginnv _ -> true
          | Ophitobjectgetobjecttoworldext _ -> true
          | Ophitobjectgetobjecttoworldnv _ -> true
          | Ophitobjectgetprimitiveindexext _ -> true
          | Ophitobjectgetprimitiveindexnv _ -> true
          | Ophitobjectgetrayflagsext _ -> true
          | Ophitobjectgetraytmaxext _ -> true
          | Ophitobjectgetraytmaxnv _ -> true
          | Ophitobjectgetraytminext _ -> true
          | Ophitobjectgetraytminnv _ -> true
          | Ophitobjectgetshaderbindingtablerecordindexext _ -> true
          | Ophitobjectgetshaderbindingtablerecordindexnv _ -> true
          | Ophitobjectgetshaderrecordbufferhandleext _ -> true
          | Ophitobjectgetshaderrecordbufferhandlenv _ -> true
          | Ophitobjectgetspherepositionnv _ -> true
          | Ophitobjectgetsphereradiusnv _ -> true
          | Ophitobjectgetworldraydirectionext _ -> true
          | Ophitobjectgetworldraydirectionnv _ -> true
          | Ophitobjectgetworldrayoriginext _ -> true
          | Ophitobjectgetworldrayoriginnv _ -> true
          | Ophitobjectgetworldtoobjectext _ -> true
          | Ophitobjectgetworldtoobjectnv _ -> true
          | Ophitobjectisemptyext _ -> true
          | Ophitobjectisemptynv _ -> true
          | Ophitobjectishitext _ -> true
          | Ophitobjectishitnv _ -> true
          | Ophitobjectislsshitnv _ -> true
          | Ophitobjectismissext _ -> true
          | Ophitobjectismissnv _ -> true
          | Ophitobjectisspherehitnv _ -> true
          | Ophitobjectrecordemptyext _ -> true
          | Ophitobjectrecordemptynv _ -> true
          | Ophitobjectrecordfromqueryext _ -> true
          | Ophitobjectrecordhitmotionnv _ -> true
          | Ophitobjectrecordhitnv _ -> true
          | Ophitobjectrecordhitwithindexmotionnv _ -> true
          | Ophitobjectrecordhitwithindexnv _ -> true
          | Ophitobjectrecordmissext _ -> true
          | Ophitobjectrecordmissmotionext _ -> true
          | Ophitobjectrecordmissmotionnv _ -> true
          | Ophitobjectrecordmissnv _ -> true
          | Ophitobjectreorderexecuteshaderext _ -> true
          | Ophitobjectsetshaderbindingtablerecordindexext _ -> true
          | Ophitobjecttracemotionreorderexecuteext _ -> true
          | Ophitobjecttracerayext _ -> true
          | Ophitobjecttraceraymotionext _ -> true
          | Ophitobjecttraceraymotionnv _ -> true
          | Ophitobjecttraceraynv _ -> true
          | Ophitobjecttracereorderexecuteext _ -> true
          | Opiaddsatintel _ -> true
          | Opiaverageintel _ -> true
          | Opiaverageroundedintel _ -> true
          | Opimul32x16intel _ -> true
          | Opisnodepayloadvalidamdx _ -> true
          | Opisubsatintel _ -> true
          | Opnodepayloadarraylengthamdx _ -> true
          | Oprayquerygetintersectionclusteridnv _ -> true
          | Oprayquerygetintersectionlsshitvaluenv _ -> true
          | Oprayquerygetintersectionlsspositionsnv _ -> true
          | Oprayquerygetintersectionlssradiinv _ -> true
          | Oprayquerygetintersectionspherepositionnv _ -> true
          | Oprayquerygetintersectionsphereradiusnv _ -> true
          | Oprayquerygetintersectiontrianglevertexpositionskhr _ -> true
          | Oprayqueryislsshitnv _ -> true
          | Oprayqueryisspherehitnv _ -> true
          | Opreadclockkhr _ -> true
          | Opreorderthreadwithhintext _ -> true
          | Opreorderthreadwithhintnv _ -> true
          | Opreorderthreadwithhitobjectext _ -> true
          | Opreorderthreadwithhitobjectnv _ -> true
          | Opsamplerimageaddressingmodenv _ -> true
          | Opsetmeshoutputsext _ -> true
          | Opspecconstantstringamdx _ -> true
          | Optensorlayoutsetblocksizenv _ -> true
          | Optensorlayoutsetclampvaluenv _ -> true
          | Optensorlayoutsetdimensionnv _ -> true
          | Optensorlayoutsetstridenv _ -> true
          | Optensorlayoutslicenv _ -> true
          | Optensorviewsetclipnv _ -> true
          | Optensorviewsetdimensionnv _ -> true
          | Optensorviewsetstridenv _ -> true
          | Optypenodepayloadarrayamdx _ -> true
          | Opuaddsatintel _ -> true
          | Opuaverageintel _ -> true
          | Opuaverageroundedintel _ -> true
          | Opucountleadingzerosintel _ -> true
          | Opucounttrailingzerosintel _ -> true
          | Opumul32x16intel _ -> true
          | Opusubsatintel _ -> true
          | Opbegininvocationinterlockext ->
              List.for_all
                [(fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                         |> Requirements.Extension.Set.of_list) extensions)]
                ~f:(fun fn -> fn ~extensions)
          | Opconvertutoaccelerationstructurekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_tracing;
                       Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.accel]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opcooperativematrixlengthnv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_cooperative_matrix] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.type_]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opcooperativematrixloadnv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_cooperative_matrix] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.stride];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.columnmajor];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opcooperativematrixmuladdnv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_cooperative_matrix] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.a];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.b];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.c]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opcooperativematrixstorenv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_cooperative_matrix] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.object_];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.stride];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.columnmajor];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_extensions))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~extensions)
          | Opendinvocationinterlockext ->
              List.for_all
                [(fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_ext_fragment_shader_interlock]
                         |> Requirements.Extension.Set.of_list) extensions)]
                ~f:(fun fn -> fn ~extensions)
          | Opexecutecallablekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.callabledata]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opexecutecallablenv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.callabledataid]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opfragmentfetchamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_fragment_mask]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.image];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.fragmentindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opfragmentmaskfetchamd t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_amd_shader_fragment_mask]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.image];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opignoreintersectionkhr ->
              List.for_all
                [(fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions)]
                ~f:(fun fn -> fn ~extensions)
          | Opignoreintersectionnv ->
              List.for_all
                [(fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions)]
                ~f:(fun fn -> fn ~extensions)
          | Opishelperinvocationext t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_ext_demote_to_helper_invocation]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oploopcontrolintel t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_intel_unstructured_loop_controls]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([List.map t.loopcontrolparameters
                    ~f:Operand_kind.Payload.Literalinteger.satisfies_extensions]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayqueryconfirmintersectionkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygenerateintersectionkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.hitt]] |>
                   List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectionbarycentricskhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectioncandidateaabbopaquekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectionfrontfacekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectiongeometryindexkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectioninstancecustomindexkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectioninstanceidkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectionobjectraydirectionkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectionobjectrayoriginkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectionobjecttoworldkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectionprimitiveindexkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectiontkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectiontypekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetintersectionworldtoobjectkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetrayflagskhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetraytminkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetworldraydirectionkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayquerygetworldrayoriginkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayqueryinitializekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.accel];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmax]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayqueryproceedkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Oprayqueryterminatekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opreportintersectionkhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_ray_tracing;
                       Requirements.Extension.Spv_khr_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_extensions
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_extensions
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.hit];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.hitkind]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opterminateraykhr ->
              List.for_all
                [(fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions)]
                ~f:(fun fn -> fn ~extensions)
          | Opterminateraynv ->
              List.for_all
                [(fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions)]
                ~f:(fun fn -> fn ~extensions)
          | Optracemotionnv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_ray_tracing_motion_blur]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.accel];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.time];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.payloadid]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Optracenv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.accel];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.payloadid]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Optraceraykhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_tracing] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.accel];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Optraceraymotionnv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_ray_tracing_motion_blur]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions t.accel];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.time];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.payload]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Opwritepackedprimitiveindices4x8nv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_mesh_shader] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idref.satisfies_extensions
                     t.indexoffset];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.packedindices]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Opabsisubintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opabsusubintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opallocatenodepayloadsamdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.visibility];
                 [Operand_kind.Payload.Idref.satisfies_version t.payloadcount];
                 [Operand_kind.Payload.Idref.satisfies_version t.nodeindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opbegininvocationinterlockext ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opconstantstringamdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_version
                    t.literalstring]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertimagetounv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertsampledimagetounv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertsamplertounv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertutoaccelerationstructurekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.accel]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertutoimagenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertutosampledimagenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opconvertutosamplernv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativematrixlengthnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.type_]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativematrixloadnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.stride];
                 [Operand_kind.Payload.Idref.satisfies_version t.columnmajor];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativematrixmuladdnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Idref.satisfies_version t.c]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcooperativematrixstorenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.object_];
                 [Operand_kind.Payload.Idref.satisfies_version t.stride];
                 [Operand_kind.Payload.Idref.satisfies_version t.columnmajor];
                 (t.memoryaccess |>
                    (Option.map
                       ~f:Operand_kind.Payload.Memoryaccess.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativevectormatrixmuladdnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.inputinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrixoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.matrixinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_version t.bias];
                 [Operand_kind.Payload.Idref.satisfies_version t.biasoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.biasinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_version t.m];
                 [Operand_kind.Payload.Idref.satisfies_version t.k];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorylayout];
                 [Operand_kind.Payload.Idref.satisfies_version t.transpose];
                 (t.matrixstride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativevectormatrixmulnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.input];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.inputinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrix];
                 [Operand_kind.Payload.Idref.satisfies_version t.matrixoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.matrixinterpretation];
                 [Operand_kind.Payload.Idref.satisfies_version t.m];
                 [Operand_kind.Payload.Idref.satisfies_version t.k];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorylayout];
                 [Operand_kind.Payload.Idref.satisfies_version t.transpose];
                 (t.matrixstride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.cooperativematrixoperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Cooperativematrixoperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativevectorouterproductaccumulatenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.offset];
                 [Operand_kind.Payload.Idref.satisfies_version t.a];
                 [Operand_kind.Payload.Idref.satisfies_version t.b];
                 [Operand_kind.Payload.Idref.satisfies_version t.memorylayout];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.matrixinterpretation];
                 (t.matrixstride |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opcooperativevectorreducesumaccumulatenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointer];
                 [Operand_kind.Payload.Idref.satisfies_version t.offset];
                 [Operand_kind.Payload.Idref.satisfies_version t.v]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opcreatetensorlayoutnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opcreatetensorviewnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opemitmeshtasksext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.groupcountx];
                 [Operand_kind.Payload.Idref.satisfies_version t.groupcounty];
                 [Operand_kind.Payload.Idref.satisfies_version t.groupcountz];
                 (t.payload |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opendinvocationinterlockext ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Openqueuenodepayloadsamdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version
                     t.payloadarray]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opexecutecallablekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.callabledata]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opexecutecallablenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.callabledataid]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfetchmicrotrianglevertexbarycentricnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.accel];
                 [Operand_kind.Payload.Idref.satisfies_version t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.primitiveindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.barycentric]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfetchmicrotrianglevertexpositionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.accel];
                 [Operand_kind.Payload.Idref.satisfies_version t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.primitiveindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.barycentric]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfinishwritingnodepayloadamdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opfragmentfetchamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.fragmentindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opfragmentmaskfetchamd t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.image];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinate]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectexecuteshaderext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectexecuteshadernv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetattributesext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.hitobjectattribute]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetattributesnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.hitobjectattribute]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetclusteridnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetcurrenttimeext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetcurrenttimenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetgeometryindexext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetgeometryindexnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgethitkindext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgethitkindnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetinstancecustomindexext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetinstancecustomindexnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetinstanceidext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetinstanceidnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetintersectiontrianglevertexpositionsext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetlsspositionsnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetlssradiinv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetobjectraydirectionext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetobjectraydirectionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetobjectrayoriginext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetobjectrayoriginnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetobjecttoworldext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetobjecttoworldnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetprimitiveindexext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetprimitiveindexnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetrayflagsext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetraytmaxext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetraytmaxnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetraytminext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetraytminnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetshaderbindingtablerecordindexext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetshaderbindingtablerecordindexnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetshaderrecordbufferhandleext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetshaderrecordbufferhandlenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetspherepositionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetsphereradiusnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetworldraydirectionext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetworldraydirectionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetworldrayoriginext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetworldrayoriginnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetworldtoobjectext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectgetworldtoobjectnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectisemptyext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectisemptynv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectishitext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectishitnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectislsshitnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectismissext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectismissnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectisspherehitnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordemptyext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordemptynv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordfromqueryext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordhitmotionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_version t.primitiveid];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitkind];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.origin];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.currenttime];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordhitnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_version t.primitiveid];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitkind];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.origin];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordhitwithindexmotionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_version t.primitiveid];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitkind];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.origin];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.currenttime];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordhitwithindexnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.instanceid];
                 [Operand_kind.Payload.Idref.satisfies_version t.primitiveid];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.geometryindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitkind];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.origin];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.hitobjectattributes]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordmissext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordmissmotionext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.currenttime]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordmissmotionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.origin];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.currenttime]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectrecordmissnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.origin];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmax]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjectreorderexecuteshaderext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Ophitobjectsetshaderbindingtablerecordindexext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjecttracemotionreorderexecuteext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.currenttime];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Ophitobjecttracerayext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjecttraceraymotionext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.currenttime];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjecttraceraymotionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.origin];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.time];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjecttraceraynv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.sbtrecordstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.origin];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.direction];
                 [Operand_kind.Payload.Idref.satisfies_version t.tmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Ophitobjecttracereorderexecuteext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.accelerationstructure];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opiaddsatintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opiaverageintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opiaverageroundedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opignoreintersectionkhr ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opignoreintersectionnv ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opimul32x16intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opishelperinvocationext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opisnodepayloadvalidamdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payloadtype];
                 [Operand_kind.Payload.Idref.satisfies_version t.nodeindex]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opisubsatintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oploopcontrolintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([List.map t.loopcontrolparameters
                    ~f:Operand_kind.Payload.Literalinteger.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opnodepayloadarraylengthamdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payloadarray]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayqueryconfirmintersectionkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygenerateintersectionkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitt]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionbarycentricskhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectioncandidateaabbopaquekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionclusteridnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionfrontfacekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectiongeometryindexkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectioninstancecustomindexkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectioninstanceidkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionlsshitvaluenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionlsspositionsnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionlssradiinv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionobjectraydirectionkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionobjectrayoriginkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionobjecttoworldkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionprimitiveindexkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionspherepositionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionsphereradiusnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectiontkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectiontrianglevertexpositionskhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectiontypekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetintersectionworldtoobjectkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetrayflagskhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetraytminkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetworldraydirectionkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayquerygetworldrayoriginkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayqueryinitializekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.accel];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayqueryislsshitnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayqueryisspherehitnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery];
                 [Operand_kind.Payload.Idref.satisfies_version t.intersection]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayqueryproceedkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Oprayqueryterminatekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.rayquery]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opreadclockkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idscope.satisfies_version t.scope]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opreorderthreadwithhintext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hint];
                 [Operand_kind.Payload.Idref.satisfies_version t.bits]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opreorderthreadwithhintnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hint];
                 [Operand_kind.Payload.Idref.satisfies_version t.bits]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opreorderthreadwithhitobjectext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opreorderthreadwithhitobjectnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.hitobject];
                 (t.hint |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.bits |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Opreportintersectionkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.hit];
                 [Operand_kind.Payload.Idref.satisfies_version t.hitkind]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opsamplerimageaddressingmodenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Literalinteger.satisfies_version
                     t.bitwidth]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opsetmeshoutputsext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.vertexcount];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.primitivecount]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opspecconstantstringamdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_version
                    t.literalstring]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorlayoutsetblocksizenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorlayout];
                 List.map t.blocksize
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorlayoutsetclampvaluenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorlayout];
                 [Operand_kind.Payload.Idref.satisfies_version t.value]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorlayoutsetdimensionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorlayout];
                 List.map t.dim
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorlayoutsetstridenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorlayout];
                 List.map t.stride
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorlayoutslicenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorlayout];
                 List.map t.operands
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorviewsetclipnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorview];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.cliprowoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.cliprowspan];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.clipcoloffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.clipcolspan]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorviewsetdimensionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorview];
                 List.map t.dim
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorviewsetstridenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensorview];
                 List.map t.stride
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opterminateraykhr ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Opterminateraynv ->
              List.for_all
                [(fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version)]
                ~f:(fun fn -> fn ~version)
          | Optracemotionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.accel];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.time];
                 [Operand_kind.Payload.Idref.satisfies_version t.payloadid]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optracenv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.accel];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.payloadid]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optraceraykhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.accel];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optraceraymotionnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.accel];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayflags];
                 [Operand_kind.Payload.Idref.satisfies_version t.cullmask];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtoffset];
                 [Operand_kind.Payload.Idref.satisfies_version t.sbtstride];
                 [Operand_kind.Payload.Idref.satisfies_version t.missindex];
                 [Operand_kind.Payload.Idref.satisfies_version t.rayorigin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmin];
                 [Operand_kind.Payload.Idref.satisfies_version t.raydirection];
                 [Operand_kind.Payload.Idref.satisfies_version t.raytmax];
                 [Operand_kind.Payload.Idref.satisfies_version t.time];
                 [Operand_kind.Payload.Idref.satisfies_version t.payload]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optypenodepayloadarrayamdx t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.payloadtype]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opuaddsatintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opuaverageintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opuaverageroundedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opucountleadingzerosintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opucounttrailingzerosintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Opumul32x16intel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opusubsatintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand1];
                 [Operand_kind.Payload.Idref.satisfies_version t.operand2]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Opwritepackedprimitiveindices4x8nv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.indexoffset];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.packedindices]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    module Tensor =
      struct
        type t =
          | Optensorquerysizearm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensor: Operand_kind.Payload.Idref.t ;
          dimension: Operand_kind.Payload.Idref.t } 
          | Optensorreadarm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensor: Operand_kind.Payload.Idref.t ;
          coordinates: Operand_kind.Payload.Idref.t ;
          tensoroperands: Operand_kind.Payload.Tensoroperands.t option } 
          | Optensorwritearm of
          {
          tensor: Operand_kind.Payload.Idref.t ;
          coordinates: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          tensoroperands: Operand_kind.Payload.Tensoroperands.t option } 
        [@@deriving compare, sexp_of]
        let provisional =
          function
          | Optensorquerysizearm _ -> false
          | Optensorreadarm _ -> false
          | Optensorwritearm _ -> false
        let value =
          function
          | Optensorquerysizearm t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensor];
                 [Operand_kind.Payload.Idref.value t.dimension]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4166l in
              heading :: payload
          | Optensorreadarm t ->
              let payload =
                ([[Operand_kind.Payload.Idresulttype.value t.idresulttype];
                 [Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.tensor];
                 [Operand_kind.Payload.Idref.value t.coordinates];
                 (t.tensoroperands |>
                    (Option.map ~f:Operand_kind.Payload.Tensoroperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4164l in
              heading :: payload
          | Optensorwritearm t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.tensor];
                 [Operand_kind.Payload.Idref.value t.coordinates];
                 [Operand_kind.Payload.Idref.value t.object_];
                 (t.tensoroperands |>
                    (Option.map ~f:Operand_kind.Payload.Tensoroperands.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4165l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Optensorquerysizearm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensorsarm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tensor];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.dimension]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optensorreadarm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensorsarm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_capabilities
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_capabilities
                    t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.tensor];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinates];
                 (t.tensoroperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Tensoroperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Optensorwritearm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensorsarm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities t.tensor];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.coordinates];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.object_];
                 (t.tensoroperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Tensoroperands.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions:_ =
          match t with
          | Optensorquerysizearm _ -> true
          | Optensorreadarm _ -> true
          | Optensorwritearm _ -> true
        let satisfies_version t ~version =
          match t with
          | Optensorquerysizearm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensor];
                 [Operand_kind.Payload.Idref.satisfies_version t.dimension]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optensorreadarm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresulttype.satisfies_version
                     t.idresulttype];
                 [Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.tensor];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinates];
                 (t.tensoroperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Tensoroperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Optensorwritearm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.tensor];
                 [Operand_kind.Payload.Idref.satisfies_version t.coordinates];
                 [Operand_kind.Payload.Idref.satisfies_version t.object_];
                 (t.tensoroperands |>
                    (Option.map
                       ~f:Operand_kind.Payload.Tensoroperands.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
      end
    module Type_declaration =
      struct
        type t =
          | Optypeaccelerationstructurekhr of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypearray of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          elementtype: Operand_kind.Payload.Idref.t ;
          length: Operand_kind.Payload.Idref.t } 
          | Optypebool of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypebuffersurfaceintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          accessqualifier: Operand_kind.Payload.Accessqualifier.t } 
          | Optypecooperativematrixkhr of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          componenttype: Operand_kind.Payload.Idref.t ;
          scope: Operand_kind.Payload.Idscope.t ;
          rows: Operand_kind.Payload.Idref.t ;
          columns: Operand_kind.Payload.Idref.t ;
          use: Operand_kind.Payload.Idref.t } 
          | Optypecooperativematrixnv of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          componenttype: Operand_kind.Payload.Idref.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          rows: Operand_kind.Payload.Idref.t ;
          columns: Operand_kind.Payload.Idref.t } 
          | Optypedeviceevent of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeevent of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypefloat of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          width: Operand_kind.Payload.Literalinteger.t ;
          floatingpointencoding: Operand_kind.Payload.Fpencoding.t option } 
          | Optypeforwardpointer of
          {
          pointertype: Operand_kind.Payload.Idref.t ;
          storageclass: Operand_kind.Payload.Storageclass.t } 
          | Optypefunction of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          returntype: Operand_kind.Payload.Idref.t ;
          parameter0typeparameter1type___: Operand_kind.Payload.Idref.t list }
          
          | Optypegrapharm of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          numinputs: Operand_kind.Payload.Literalinteger.t ;
          inouttypes: Operand_kind.Payload.Idref.t list } 
          | Optypehitobjectext of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypehitobjectnv of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeimage of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledtype: Operand_kind.Payload.Idref.t ;
          dim: Operand_kind.Payload.Dim.t ;
          depth: Operand_kind.Payload.Literalinteger.t ;
          arrayed: Operand_kind.Payload.Literalinteger.t ;
          ms: Operand_kind.Payload.Literalinteger.t ;
          sampled: Operand_kind.Payload.Literalinteger.t ;
          imageformat: Operand_kind.Payload.Imageformat.t ;
          accessqualifier: Operand_kind.Payload.Accessqualifier.t option } 
          | Optypeint of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          width: Operand_kind.Payload.Literalinteger.t ;
          signedness: Operand_kind.Payload.Literalinteger.t } 
          | Optypematrix of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          columntype: Operand_kind.Payload.Idref.t ;
          columncount: Operand_kind.Payload.Literalinteger.t } 
          | Optypenamedbarrier of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeopaque of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          thenameoftheopaquetype_: Operand_kind.Payload.Literalstring.t } 
          | Optypepipe of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          qualifier: Operand_kind.Payload.Accessqualifier.t } 
          | Optypepipestorage of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypepointer of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          storageclass: Operand_kind.Payload.Storageclass.t ;
          type_: Operand_kind.Payload.Idref.t } 
          | Optypequeue of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optyperayquerykhr of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypereserveid of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optyperuntimearray of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          elementtype: Operand_kind.Payload.Idref.t } 
          | Optypesampledimage of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          imagetype: Operand_kind.Payload.Idref.t } 
          | Optypesampler of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypestruct of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          member0typemember1type___: Operand_kind.Payload.Idref.t list } 
          | Optypestructcontinuedintel of
          {
          member0typemember1type___: Operand_kind.Payload.Idref.t list } 
          | Optypetensorarm of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          elementtype: Operand_kind.Payload.Idref.t ;
          rank: Operand_kind.Payload.Idref.t option ;
          shape: Operand_kind.Payload.Idref.t option } 
          | Optypetensorlayoutnv of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          dim: Operand_kind.Payload.Idref.t ;
          clampmode: Operand_kind.Payload.Idref.t } 
          | Optypetensorviewnv of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          dim: Operand_kind.Payload.Idref.t ;
          hasdimensions: Operand_kind.Payload.Idref.t ;
          p: Operand_kind.Payload.Idref.t list } 
          | Optypeuntypedpointerkhr of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          storageclass: Operand_kind.Payload.Storageclass.t } 
          | Optypevector of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          componenttype: Operand_kind.Payload.Idref.t ;
          componentcount: Operand_kind.Payload.Literalinteger.t } 
          | Optypevectoridext of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          componenttype: Operand_kind.Payload.Idref.t ;
          componentcount: Operand_kind.Payload.Idref.t } 
          | Optypevoid of {
          idresult: Operand_kind.Payload.Idresult.t } [@@deriving
                                                        compare, sexp_of]
        let provisional =
          function
          | Optypeaccelerationstructurekhr _ -> false
          | Optypearray _ -> false
          | Optypebool _ -> false
          | Optypebuffersurfaceintel _ -> false
          | Optypecooperativematrixkhr _ -> false
          | Optypecooperativematrixnv _ -> false
          | Optypedeviceevent _ -> false
          | Optypeevent _ -> false
          | Optypefloat _ -> false
          | Optypeforwardpointer _ -> false
          | Optypefunction _ -> false
          | Optypegrapharm _ -> false
          | Optypehitobjectext _ -> false
          | Optypehitobjectnv _ -> false
          | Optypeimage _ -> false
          | Optypeint _ -> false
          | Optypematrix _ -> false
          | Optypenamedbarrier _ -> false
          | Optypeopaque _ -> false
          | Optypepipe _ -> false
          | Optypepipestorage _ -> false
          | Optypepointer _ -> false
          | Optypequeue _ -> false
          | Optyperayquerykhr _ -> false
          | Optypereserveid _ -> false
          | Optyperuntimearray _ -> false
          | Optypesampledimage _ -> false
          | Optypesampler _ -> false
          | Optypestruct _ -> false
          | Optypestructcontinuedintel _ -> false
          | Optypetensorarm _ -> false
          | Optypetensorlayoutnv _ -> false
          | Optypetensorviewnv _ -> false
          | Optypeuntypedpointerkhr _ -> false
          | Optypevector _ -> false
          | Optypevectoridext _ -> false
          | Optypevoid _ -> false
        let value =
          function
          | Optypeaccelerationstructurekhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5341l in
              heading :: payload
          | Optypearray t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.elementtype];
                 [Operand_kind.Payload.Idref.value t.length]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 28l in
              heading :: payload
          | Optypebool t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 20l in
              heading :: payload
          | Optypebuffersurfaceintel t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Accessqualifier.value
                    t.accessqualifier]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6086l in
              heading :: payload
          | Optypecooperativematrixkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.componenttype];
                 [Operand_kind.Payload.Idscope.value t.scope];
                 [Operand_kind.Payload.Idref.value t.rows];
                 [Operand_kind.Payload.Idref.value t.columns];
                 [Operand_kind.Payload.Idref.value t.use]] |> List.concat) |>
                  List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4456l in
              heading :: payload
          | Optypecooperativematrixnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.componenttype];
                 [Operand_kind.Payload.Idscope.value t.execution];
                 [Operand_kind.Payload.Idref.value t.rows];
                 [Operand_kind.Payload.Idref.value t.columns]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5358l in
              heading :: payload
          | Optypedeviceevent t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 35l in
              heading :: payload
          | Optypeevent t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 34l in
              heading :: payload
          | Optypefloat t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalinteger.value t.width];
                 (t.floatingpointencoding |>
                    (Option.map ~f:Operand_kind.Payload.Fpencoding.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 22l in
              heading :: payload
          | Optypeforwardpointer t ->
              let payload =
                ([[Operand_kind.Payload.Idref.value t.pointertype];
                 [Operand_kind.Payload.Storageclass.value t.storageclass]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 39l in
              heading :: payload
          | Optypefunction t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.returntype];
                 List.map t.parameter0typeparameter1type___
                   ~f:Operand_kind.Payload.Idref.value] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 33l in
              heading :: payload
          | Optypegrapharm t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalinteger.value t.numinputs];
                 List.map t.inouttypes ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4190l in
              heading :: payload
          | Optypehitobjectext t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5313l in
              heading :: payload
          | Optypehitobjectnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5281l in
              heading :: payload
          | Optypeimage t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.sampledtype];
                 [Operand_kind.Payload.Dim.value t.dim];
                 [Operand_kind.Payload.Literalinteger.value t.depth];
                 [Operand_kind.Payload.Literalinteger.value t.arrayed];
                 [Operand_kind.Payload.Literalinteger.value t.ms];
                 [Operand_kind.Payload.Literalinteger.value t.sampled];
                 [Operand_kind.Payload.Imageformat.value t.imageformat];
                 (t.accessqualifier |>
                    (Option.map ~f:Operand_kind.Payload.Accessqualifier.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 25l in
              heading :: payload
          | Optypeint t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalinteger.value t.width];
                 [Operand_kind.Payload.Literalinteger.value t.signedness]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 21l in
              heading :: payload
          | Optypematrix t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.columntype];
                 [Operand_kind.Payload.Literalinteger.value t.columncount]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 24l in
              heading :: payload
          | Optypenamedbarrier t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 327l in
              heading :: payload
          | Optypeopaque t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Literalstring.value
                    t.thenameoftheopaquetype_]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 31l in
              heading :: payload
          | Optypepipe t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Accessqualifier.value t.qualifier]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 38l in
              heading :: payload
          | Optypepipestorage t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 322l in
              heading :: payload
          | Optypepointer t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Storageclass.value t.storageclass];
                 [Operand_kind.Payload.Idref.value t.type_]] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 32l in
              heading :: payload
          | Optypequeue t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 37l in
              heading :: payload
          | Optyperayquerykhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4472l in
              heading :: payload
          | Optypereserveid t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 36l in
              heading :: payload
          | Optyperuntimearray t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.elementtype]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 29l in
              heading :: payload
          | Optypesampledimage t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.imagetype]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 27l in
              heading :: payload
          | Optypesampler t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 26l in
              heading :: payload
          | Optypestruct t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 List.map t.member0typemember1type___
                   ~f:Operand_kind.Payload.Idref.value] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 30l in
              heading :: payload
          | Optypestructcontinuedintel t ->
              let payload =
                ([List.map t.member0typemember1type___
                    ~f:Operand_kind.Payload.Idref.value]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6090l in
              heading :: payload
          | Optypetensorarm t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.elementtype];
                 (t.rank |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list;
                 (t.shape |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                   |> Option.to_list] |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4163l in
              heading :: payload
          | Optypetensorlayoutnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.dim];
                 [Operand_kind.Payload.Idref.value t.clampmode]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5370l in
              heading :: payload
          | Optypetensorviewnv t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.dim];
                 [Operand_kind.Payload.Idref.value t.hasdimensions];
                 List.map t.p ~f:Operand_kind.Payload.Idref.value] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5371l in
              heading :: payload
          | Optypeuntypedpointerkhr t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Storageclass.value t.storageclass]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4417l in
              heading :: payload
          | Optypevector t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.componenttype];
                 [Operand_kind.Payload.Literalinteger.value t.componentcount]]
                   |> List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 23l in
              heading :: payload
          | Optypevectoridext t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult];
                 [Operand_kind.Payload.Idref.value t.componenttype];
                 [Operand_kind.Payload.Idref.value t.componentcount]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5288l in
              heading :: payload
          | Optypevoid t ->
              let payload =
                ([[Operand_kind.Payload.Idresult.value t.idresult]] |>
                   List.concat)
                  |> List.concat in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 19l in
              heading :: payload
        let satisfies_capabilities t ~capabilities =
          match t with
          | Optypearray _ -> true
          | Optypebool _ -> true
          | Optypefloat _ -> true
          | Optypefunction _ -> true
          | Optypeimage _ -> true
          | Optypeint _ -> true
          | Optypepointer _ -> true
          | Optypesampledimage _ -> true
          | Optypesampler _ -> true
          | Optypestruct _ -> true
          | Optypevector _ -> true
          | Optypevoid _ -> true
          | Optypeaccelerationstructurekhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Raytracingnv;
                       Operand_kind.Payload.Capability.Raytracingkhr;
                       Operand_kind.Payload.Capability.Rayquerykhr;
                       Operand_kind.Payload.Capability.Displacementmicromapnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypebuffersurfaceintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Vectorcomputeintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Accessqualifier.satisfies_capabilities
                    t.accessqualifier]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypecooperativematrixkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixkhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.componenttype];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities t.scope];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.rows];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.columns];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.use]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypecooperativematrixnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativematrixnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.componenttype];
                 [Operand_kind.Payload.Idscope.satisfies_capabilities
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.rows];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.columns]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypedeviceevent t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeevent t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeforwardpointer t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Addresses;
                       Operand_kind.Payload.Capability.Physicalstoragebufferaddresses]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idref.satisfies_capabilities
                     t.pointertype];
                 [Operand_kind.Payload.Storageclass.satisfies_capabilities
                    t.storageclass]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypegrapharm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Grapharm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.numinputs];
                 List.map t.inouttypes
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypehitobjectext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreorderext]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypehitobjectnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shaderinvocationreordernv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypematrix t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Matrix] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.columntype];
                 [Operand_kind.Payload.Literalinteger.satisfies_capabilities
                    t.columncount]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypenamedbarrier t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Namedbarrier] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeopaque t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Kernel] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_capabilities
                    t.thenameoftheopaquetype_]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypepipe t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Accessqualifier.satisfies_capabilities
                    t.qualifier]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypepipestorage t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipestorage] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypequeue t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Deviceenqueue] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optyperayquerykhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Rayquerykhr] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypereserveid t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Pipes] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optyperuntimearray t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Shader] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.elementtype]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypestructcontinuedintel t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Longcompositesintel]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([List.map t.member0typemember1type___
                    ~f:Operand_kind.Payload.Idref.satisfies_capabilities]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypetensorarm t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensorsarm] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.elementtype];
                 (t.rank |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list;
                 (t.shape |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_capabilities))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~capabilities)
          | Optypetensorlayoutnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dim];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.clampmode]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypetensorviewnv t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Tensoraddressingnv]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities t.dim];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.hasdimensions];
                 List.map t.p
                   ~f:Operand_kind.Payload.Idref.satisfies_capabilities] |>
                   List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypeuntypedpointerkhr t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Untypedpointerskhr]
                         |> Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Storageclass.satisfies_capabilities
                    t.storageclass]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
          | Optypevectoridext t ->
              List.for_all
                ((fun ~capabilities ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Operand_kind.Payload.Capability.Cooperativevectornv;
                       Operand_kind.Payload.Capability.Longvectorext] |>
                         Operand_kind.Payload.Capability.Set.of_list)
                      capabilities) ::
                ([[Operand_kind.Payload.Idresult.satisfies_capabilities
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.componenttype];
                 [Operand_kind.Payload.Idref.satisfies_capabilities
                    t.componentcount]]
                   |> List.concat)) ~f:(fun fn -> fn ~capabilities)
        let satisfies_extensions t ~extensions =
          match t with
          | Optypearray _ -> true
          | Optypebool _ -> true
          | Optypebuffersurfaceintel _ -> true
          | Optypecooperativematrixkhr _ -> true
          | Optypedeviceevent _ -> true
          | Optypeevent _ -> true
          | Optypefloat _ -> true
          | Optypeforwardpointer _ -> true
          | Optypefunction _ -> true
          | Optypegrapharm _ -> true
          | Optypehitobjectext _ -> true
          | Optypehitobjectnv _ -> true
          | Optypeimage _ -> true
          | Optypeint _ -> true
          | Optypematrix _ -> true
          | Optypenamedbarrier _ -> true
          | Optypeopaque _ -> true
          | Optypepipe _ -> true
          | Optypepipestorage _ -> true
          | Optypepointer _ -> true
          | Optypequeue _ -> true
          | Optypereserveid _ -> true
          | Optyperuntimearray _ -> true
          | Optypesampledimage _ -> true
          | Optypesampler _ -> true
          | Optypestruct _ -> true
          | Optypestructcontinuedintel _ -> true
          | Optypetensorarm _ -> true
          | Optypetensorlayoutnv _ -> true
          | Optypetensorviewnv _ -> true
          | Optypeuntypedpointerkhr _ -> true
          | Optypevector _ -> true
          | Optypevectoridext _ -> true
          | Optypevoid _ -> true
          | Optypeaccelerationstructurekhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_ray_tracing;
                       Requirements.Extension.Spv_khr_ray_tracing;
                       Requirements.Extension.Spv_khr_ray_query;
                       Requirements.Extension.Spv_nv_displacement_micromap]
                         |> Requirements.Extension.Set.of_list) extensions)
                ::
                ([[Operand_kind.Payload.Idresult.satisfies_extensions
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Optypecooperativematrixnv t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_nv_cooperative_matrix] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresult.satisfies_extensions
                     t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_extensions
                    t.componenttype];
                 [Operand_kind.Payload.Idscope.satisfies_extensions
                    t.execution];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.rows];
                 [Operand_kind.Payload.Idref.satisfies_extensions t.columns]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
          | Optyperayquerykhr t ->
              List.for_all
                ((fun ~extensions ->
                    (fun set1 set2 -> not (Core.Set.are_disjoint set1 set2))
                      ([Requirements.Extension.Spv_khr_ray_query] |>
                         Requirements.Extension.Set.of_list) extensions) ::
                ([[Operand_kind.Payload.Idresult.satisfies_extensions
                     t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~extensions)
        let satisfies_version t ~version =
          match t with
          | Optypeaccelerationstructurekhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypearray t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.elementtype];
                 [Operand_kind.Payload.Idref.satisfies_version t.length]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optypebool t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypebuffersurfaceintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Accessqualifier.satisfies_version
                    t.accessqualifier]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypecooperativematrixkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.componenttype];
                 [Operand_kind.Payload.Idscope.satisfies_version t.scope];
                 [Operand_kind.Payload.Idref.satisfies_version t.rows];
                 [Operand_kind.Payload.Idref.satisfies_version t.columns];
                 [Operand_kind.Payload.Idref.satisfies_version t.use]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optypecooperativematrixnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.componenttype];
                 [Operand_kind.Payload.Idscope.satisfies_version t.execution];
                 [Operand_kind.Payload.Idref.satisfies_version t.rows];
                 [Operand_kind.Payload.Idref.satisfies_version t.columns]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optypedeviceevent t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeevent t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypefloat t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.width];
                 (t.floatingpointencoding |>
                    (Option.map
                       ~f:Operand_kind.Payload.Fpencoding.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Optypeforwardpointer t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idref.satisfies_version t.pointertype];
                 [Operand_kind.Payload.Storageclass.satisfies_version
                    t.storageclass]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypefunction t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.returntype];
                 List.map t.parameter0typeparameter1type___
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optypegrapharm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.numinputs];
                 List.map t.inouttypes
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optypehitobjectext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypehitobjectnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeimage t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.sampledtype];
                 [Operand_kind.Payload.Dim.satisfies_version t.dim];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.depth];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.arrayed];
                 [Operand_kind.Payload.Literalinteger.satisfies_version t.ms];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.sampled];
                 [Operand_kind.Payload.Imageformat.satisfies_version
                    t.imageformat];
                 (t.accessqualifier |>
                    (Option.map
                       ~f:Operand_kind.Payload.Accessqualifier.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Optypeint t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.width];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.signedness]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypematrix t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.columntype];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.columncount]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypenamedbarrier t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeopaque t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Literalstring.satisfies_version
                    t.thenameoftheopaquetype_]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypepipe t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Accessqualifier.satisfies_version
                    t.qualifier]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypepipestorage t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_1) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypepointer t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Storageclass.satisfies_version
                    t.storageclass];
                 [Operand_kind.Payload.Idref.satisfies_version t.type_]] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optypequeue t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optyperayquerykhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypereserveid t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optyperuntimearray t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.elementtype]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypesampledimage t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.imagetype]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypesampler t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypestruct t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 List.map t.member0typemember1type___
                   ~f:Operand_kind.Payload.Idref.satisfies_version] |>
                   List.concat)) ~f:(fun fn -> fn ~version)
          | Optypestructcontinuedintel t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([List.map t.member0typemember1type___
                    ~f:Operand_kind.Payload.Idref.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypetensorarm t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.elementtype];
                 (t.rank |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list;
                 (t.shape |>
                    (Option.map
                       ~f:Operand_kind.Payload.Idref.satisfies_version))
                   |> Option.to_list] |> List.concat))
                ~f:(fun fn -> fn ~version)
          | Optypetensorlayoutnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.dim];
                 [Operand_kind.Payload.Idref.satisfies_version t.clampmode]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypetensorviewnv t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version t.dim];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.hasdimensions];
                 List.map t.p ~f:Operand_kind.Payload.Idref.satisfies_version]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypeuntypedpointerkhr t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Storageclass.satisfies_version
                    t.storageclass]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypevector t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.componenttype];
                 [Operand_kind.Payload.Literalinteger.satisfies_version
                    t.componentcount]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypevectoridext t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions ~required:None
                          ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.componenttype];
                 [Operand_kind.Payload.Idref.satisfies_version
                    t.componentcount]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
          | Optypevoid t ->
              List.for_all
                ((fun ~version ->
                    Core.Set.mem
                      ((Requirements.Version.valid_versions
                          ~required:(Some V1_0) ~last:None)
                         |> Requirements.Version.Set.of_list) version) ::
                ([[Operand_kind.Payload.Idresult.satisfies_version t.idresult]]
                   |> List.concat)) ~f:(fun fn -> fn ~version)
      end
    type t =
      | Annotation of Annotation.t 
      | Arithmetic of Arithmetic.t 
      | Atomic of Atomic.t 
      | Barrier of Barrier.t 
      | Bit of Bit.t 
      | Composite of Composite.t 
      | Constant_creation of Constant_creation.t 
      | Control_flow of Control_flow.t 
      | Conversion of Conversion.t 
      | Debug of Debug.t 
      | Derivative of Derivative.t 
      | Device_side_enqueue of Device_side_enqueue.t 
      | Exclude of Exclude.t 
      | Extension of Extension.t 
      | Function of Function.t 
      | Graph of Graph.t 
      | Group of Group.t 
      | Image of Image.t 
      | Memory of Memory.t 
      | Miscellaneous of Miscellaneous.t 
      | Mode_setting of Mode_setting.t 
      | Non_uniform of Non_uniform.t 
      | Pipe of Pipe.t 
      | Primitive of Primitive.t 
      | Relational_and_logical of Relational_and_logical.t 
      | Reserved of Reserved.t 
      | Tensor of Tensor.t 
      | Type_declaration of Type_declaration.t [@@deriving compare, sexp_of]
    let provisional t =
      match t with
      | Annotation t -> (Annotation.provisional t) 
      | Arithmetic t -> (Arithmetic.provisional t) 
      | Atomic t -> (Atomic.provisional t) 
      | Barrier t -> (Barrier.provisional t) 
      | Bit t -> (Bit.provisional t) 
      | Composite t -> (Composite.provisional t) 
      | Constant_creation t -> (Constant_creation.provisional t) 
      | Control_flow t -> (Control_flow.provisional t) 
      | Conversion t -> (Conversion.provisional t) 
      | Debug t -> (Debug.provisional t) 
      | Derivative t -> (Derivative.provisional t) 
      | Device_side_enqueue t -> (Device_side_enqueue.provisional t) 
      | Exclude t -> (Exclude.provisional t) 
      | Extension t -> (Extension.provisional t) 
      | Function t -> (Function.provisional t) 
      | Graph t -> (Graph.provisional t) 
      | Group t -> (Group.provisional t) 
      | Image t -> (Image.provisional t) 
      | Memory t -> (Memory.provisional t) 
      | Miscellaneous t -> (Miscellaneous.provisional t) 
      | Mode_setting t -> (Mode_setting.provisional t) 
      | Non_uniform t -> (Non_uniform.provisional t) 
      | Pipe t -> (Pipe.provisional t) 
      | Primitive t -> (Primitive.provisional t) 
      | Relational_and_logical t -> (Relational_and_logical.provisional t) 
      | Reserved t -> (Reserved.provisional t) 
      | Tensor t -> (Tensor.provisional t) 
      | Type_declaration t -> (Type_declaration.provisional t) 
    let value t =
      match t with
      | Annotation t -> (Annotation.value t) 
      | Arithmetic t -> (Arithmetic.value t) 
      | Atomic t -> (Atomic.value t) 
      | Barrier t -> (Barrier.value t) 
      | Bit t -> (Bit.value t) 
      | Composite t -> (Composite.value t) 
      | Constant_creation t -> (Constant_creation.value t) 
      | Control_flow t -> (Control_flow.value t) 
      | Conversion t -> (Conversion.value t) 
      | Debug t -> (Debug.value t) 
      | Derivative t -> (Derivative.value t) 
      | Device_side_enqueue t -> (Device_side_enqueue.value t) 
      | Exclude t -> (Exclude.value t) 
      | Extension t -> (Extension.value t) 
      | Function t -> (Function.value t) 
      | Graph t -> (Graph.value t) 
      | Group t -> (Group.value t) 
      | Image t -> (Image.value t) 
      | Memory t -> (Memory.value t) 
      | Miscellaneous t -> (Miscellaneous.value t) 
      | Mode_setting t -> (Mode_setting.value t) 
      | Non_uniform t -> (Non_uniform.value t) 
      | Pipe t -> (Pipe.value t) 
      | Primitive t -> (Primitive.value t) 
      | Relational_and_logical t -> (Relational_and_logical.value t) 
      | Reserved t -> (Reserved.value t) 
      | Tensor t -> (Tensor.value t) 
      | Type_declaration t -> (Type_declaration.value t) 
    let satisfies_version t ~version =
      match t with
      | Annotation t -> (Annotation.satisfies_version t) ~version
      | Arithmetic t -> (Arithmetic.satisfies_version t) ~version
      | Atomic t -> (Atomic.satisfies_version t) ~version
      | Barrier t -> (Barrier.satisfies_version t) ~version
      | Bit t -> (Bit.satisfies_version t) ~version
      | Composite t -> (Composite.satisfies_version t) ~version
      | Constant_creation t ->
          (Constant_creation.satisfies_version t) ~version
      | Control_flow t -> (Control_flow.satisfies_version t) ~version
      | Conversion t -> (Conversion.satisfies_version t) ~version
      | Debug t -> (Debug.satisfies_version t) ~version
      | Derivative t -> (Derivative.satisfies_version t) ~version
      | Device_side_enqueue t ->
          (Device_side_enqueue.satisfies_version t) ~version
      | Exclude t -> (Exclude.satisfies_version t) ~version
      | Extension t -> (Extension.satisfies_version t) ~version
      | Function t -> (Function.satisfies_version t) ~version
      | Graph t -> (Graph.satisfies_version t) ~version
      | Group t -> (Group.satisfies_version t) ~version
      | Image t -> (Image.satisfies_version t) ~version
      | Memory t -> (Memory.satisfies_version t) ~version
      | Miscellaneous t -> (Miscellaneous.satisfies_version t) ~version
      | Mode_setting t -> (Mode_setting.satisfies_version t) ~version
      | Non_uniform t -> (Non_uniform.satisfies_version t) ~version
      | Pipe t -> (Pipe.satisfies_version t) ~version
      | Primitive t -> (Primitive.satisfies_version t) ~version
      | Relational_and_logical t ->
          (Relational_and_logical.satisfies_version t) ~version
      | Reserved t -> (Reserved.satisfies_version t) ~version
      | Tensor t -> (Tensor.satisfies_version t) ~version
      | Type_declaration t -> (Type_declaration.satisfies_version t) ~version
    let satisfies_capabilities t ~capabilities =
      match t with
      | Annotation t -> (Annotation.satisfies_capabilities t) ~capabilities
      | Arithmetic t -> (Arithmetic.satisfies_capabilities t) ~capabilities
      | Atomic t -> (Atomic.satisfies_capabilities t) ~capabilities
      | Barrier t -> (Barrier.satisfies_capabilities t) ~capabilities
      | Bit t -> (Bit.satisfies_capabilities t) ~capabilities
      | Composite t -> (Composite.satisfies_capabilities t) ~capabilities
      | Constant_creation t ->
          (Constant_creation.satisfies_capabilities t) ~capabilities
      | Control_flow t ->
          (Control_flow.satisfies_capabilities t) ~capabilities
      | Conversion t -> (Conversion.satisfies_capabilities t) ~capabilities
      | Debug t -> (Debug.satisfies_capabilities t) ~capabilities
      | Derivative t -> (Derivative.satisfies_capabilities t) ~capabilities
      | Device_side_enqueue t ->
          (Device_side_enqueue.satisfies_capabilities t) ~capabilities
      | Exclude t -> (Exclude.satisfies_capabilities t) ~capabilities
      | Extension t -> (Extension.satisfies_capabilities t) ~capabilities
      | Function t -> (Function.satisfies_capabilities t) ~capabilities
      | Graph t -> (Graph.satisfies_capabilities t) ~capabilities
      | Group t -> (Group.satisfies_capabilities t) ~capabilities
      | Image t -> (Image.satisfies_capabilities t) ~capabilities
      | Memory t -> (Memory.satisfies_capabilities t) ~capabilities
      | Miscellaneous t ->
          (Miscellaneous.satisfies_capabilities t) ~capabilities
      | Mode_setting t ->
          (Mode_setting.satisfies_capabilities t) ~capabilities
      | Non_uniform t -> (Non_uniform.satisfies_capabilities t) ~capabilities
      | Pipe t -> (Pipe.satisfies_capabilities t) ~capabilities
      | Primitive t -> (Primitive.satisfies_capabilities t) ~capabilities
      | Relational_and_logical t ->
          (Relational_and_logical.satisfies_capabilities t) ~capabilities
      | Reserved t -> (Reserved.satisfies_capabilities t) ~capabilities
      | Tensor t -> (Tensor.satisfies_capabilities t) ~capabilities
      | Type_declaration t ->
          (Type_declaration.satisfies_capabilities t) ~capabilities
    let satisfies_extensions t ~extensions =
      match t with
      | Annotation t -> (Annotation.satisfies_extensions t) ~extensions
      | Arithmetic t -> (Arithmetic.satisfies_extensions t) ~extensions
      | Atomic t -> (Atomic.satisfies_extensions t) ~extensions
      | Barrier t -> (Barrier.satisfies_extensions t) ~extensions
      | Bit t -> (Bit.satisfies_extensions t) ~extensions
      | Composite t -> (Composite.satisfies_extensions t) ~extensions
      | Constant_creation t ->
          (Constant_creation.satisfies_extensions t) ~extensions
      | Control_flow t -> (Control_flow.satisfies_extensions t) ~extensions
      | Conversion t -> (Conversion.satisfies_extensions t) ~extensions
      | Debug t -> (Debug.satisfies_extensions t) ~extensions
      | Derivative t -> (Derivative.satisfies_extensions t) ~extensions
      | Device_side_enqueue t ->
          (Device_side_enqueue.satisfies_extensions t) ~extensions
      | Exclude t -> (Exclude.satisfies_extensions t) ~extensions
      | Extension t -> (Extension.satisfies_extensions t) ~extensions
      | Function t -> (Function.satisfies_extensions t) ~extensions
      | Graph t -> (Graph.satisfies_extensions t) ~extensions
      | Group t -> (Group.satisfies_extensions t) ~extensions
      | Image t -> (Image.satisfies_extensions t) ~extensions
      | Memory t -> (Memory.satisfies_extensions t) ~extensions
      | Miscellaneous t -> (Miscellaneous.satisfies_extensions t) ~extensions
      | Mode_setting t -> (Mode_setting.satisfies_extensions t) ~extensions
      | Non_uniform t -> (Non_uniform.satisfies_extensions t) ~extensions
      | Pipe t -> (Pipe.satisfies_extensions t) ~extensions
      | Primitive t -> (Primitive.satisfies_extensions t) ~extensions
      | Relational_and_logical t ->
          (Relational_and_logical.satisfies_extensions t) ~extensions
      | Reserved t -> (Reserved.satisfies_extensions t) ~extensions
      | Tensor t -> (Tensor.satisfies_extensions t) ~extensions
      | Type_declaration t ->
          (Type_declaration.satisfies_extensions t) ~extensions
  end