[@@@warning "-32"]
open Core
module Requirements =
  struct
    module Version =
      struct
        module T =
          struct
            type t =
              | V1_0 
              | V1_1 
              | V1_2 
              | V1_3 
              | V1_4 
              | V1_5 
              | V1_6 [@@deriving compare, sexp_of, enumerate]
          end
        include T
        include (Comparable.Make_plain)(T)
        let major =
          function
          | V1_0 -> 1l
          | V1_1 -> 1l
          | V1_2 -> 1l
          | V1_3 -> 1l
          | V1_4 -> 1l
          | V1_5 -> 1l
          | V1_6 -> 1l
        let minor =
          function
          | V1_0 -> 0l
          | V1_1 -> 1l
          | V1_2 -> 2l
          | V1_3 -> 3l
          | V1_4 -> 4l
          | V1_5 -> 5l
          | V1_6 -> 6l
        let value t =
          let major_value = Int32.shift_left (major t) 16 in
          let minor_value = Int32.shift_left (minor t) 8 in
          Int32.bit_or minor_value major_value
        let valid_versions ~required ~last =
          List.filter all
            ~f:(fun t ->
                  (Option.value_map required ~default:true
                     ~f:(fun required -> t >= required))
                    &&
                    (Option.value_map last ~default:true
                       ~f:(fun last -> t <= last)))
      end
    module Extension =
      struct
        module T =
          struct
            type t =
              | Spv_altera_arbitrary_precision_fixed_point 
              | Spv_altera_arbitrary_precision_floating_point 
              | Spv_altera_arbitrary_precision_integers 
              | Spv_altera_blocking_pipes 
              | Spv_altera_fpga_argument_interfaces 
              | Spv_altera_fpga_buffer_location 
              | Spv_altera_fpga_cluster_attributes 
              | Spv_altera_fpga_dsp_control 
              | Spv_altera_fpga_invocation_pipelining_attributes 
              | Spv_altera_fpga_latency_control 
              | Spv_altera_fpga_loop_controls 
              | Spv_altera_fpga_memory_accesses 
              | Spv_altera_fpga_memory_attributes 
              | Spv_altera_fpga_reg 
              | Spv_altera_global_variable_fpga_decorations 
              | Spv_altera_io_pipes 
              | Spv_altera_loop_fuse 
              | Spv_altera_runtime_aligned 
              | Spv_altera_task_sequence 
              | Spv_altera_usm_storage_classes 
              | Spv_amdx_shader_enqueue 
              | Spv_amd_gpu_shader_half_float_fetch 
              | Spv_amd_shader_ballot 
              | Spv_amd_shader_early_and_late_fragment_tests 
              | Spv_amd_shader_explicit_vertex_parameter 
              | Spv_amd_shader_fragment_mask 
              | Spv_amd_shader_image_load_store_lod 
              | Spv_amd_texture_gather_bias_lod 
              | Spv_arm_cooperative_matrix_layouts 
              | Spv_arm_core_builtins 
              | Spv_arm_graph 
              | Spv_arm_tensors 
              | Spv_ext_arithmetic_fence 
              | Spv_ext_demote_to_helper_invocation 
              | Spv_ext_descriptor_indexing 
              | Spv_ext_float8 
              | Spv_ext_fragment_fully_covered 
              | Spv_ext_fragment_invocation_density 
              | Spv_ext_fragment_shader_interlock 
              | Spv_ext_long_vector 
              | Spv_ext_mesh_shader 
              | Spv_ext_opacity_micromap 
              | Spv_ext_optnone 
              | Spv_ext_physical_storage_buffer 
              | Spv_ext_replicated_composites 
              | Spv_ext_shader_64bit_indexing 
              | Spv_ext_shader_atomic_float16_add 
              | Spv_ext_shader_atomic_float_add 
              | Spv_ext_shader_atomic_float_min_max 
              | Spv_ext_shader_image_int64 
              | Spv_ext_shader_invocation_reorder 
              | Spv_ext_shader_stencil_export 
              | Spv_ext_shader_tile_image 
              | Spv_ext_shader_viewport_index_layer 
              | Spv_google_decorate_string 
              | Spv_google_hlsl_functionality1 
              | Spv_google_user_type 
              | Spv_intel_2d_block_io 
              | Spv_intel_arbitrary_precision_fixed_point 
              | Spv_intel_arbitrary_precision_floating_point 
              | Spv_intel_arbitrary_precision_integers 
              | Spv_intel_bfloat16_conversion 
              | Spv_intel_bindless_images 
              | Spv_intel_blocking_pipes 
              | Spv_intel_cache_controls 
              | Spv_intel_debug_module 
              | Spv_intel_device_side_avc_motion_estimation 
              | Spv_intel_float_controls2 
              | Spv_intel_fp_fast_math_mode 
              | Spv_intel_fp_max_error 
              | Spv_intel_fpga_argument_interfaces 
              | Spv_intel_fpga_buffer_location 
              | Spv_intel_fpga_cluster_attributes 
              | Spv_intel_fpga_dsp_control 
              | Spv_intel_fpga_invocation_pipelining_attributes 
              | Spv_intel_fpga_latency_control 
              | Spv_intel_fpga_loop_controls 
              | Spv_intel_fpga_memory_accesses 
              | Spv_intel_fpga_memory_attributes 
              | Spv_intel_fpga_reg 
              | Spv_intel_function_pointers 
              | Spv_intel_function_variants 
              | Spv_intel_global_variable_fpga_decorations 
              | Spv_intel_global_variable_host_access 
              | Spv_intel_inline_assembly 
              | Spv_intel_int4 
              | Spv_intel_io_pipes 
              | Spv_intel_kernel_attributes 
              | Spv_intel_long_composites 
              | Spv_intel_loop_fuse 
              | Spv_intel_masked_gather_scatter 
              | Spv_intel_maximum_registers 
              | Spv_intel_media_block_io 
              | Spv_intel_memory_access_aliasing 
              | Spv_intel_optnone 
              | Spv_intel_runtime_aligned 
              | Spv_intel_shader_integer_functions2 
              | Spv_intel_split_barrier 
              | Spv_intel_subgroup_buffer_prefetch 
              | Spv_intel_subgroup_matrix_multiply_accumulate 
              | Spv_intel_subgroups 
              | Spv_intel_task_sequence 
              | Spv_intel_tensor_float32_conversion 
              | Spv_intel_ternary_bitwise_function 
              | Spv_intel_unstructured_loop_controls 
              | Spv_intel_usm_storage_classes 
              | Spv_intel_variable_length_array 
              | Spv_intel_vector_compute 
              | Spv_khr_16bit_storage 
              | Spv_khr_8bit_storage 
              | Spv_khr_bfloat16 
              | Spv_khr_bit_instructions 
              | Spv_khr_compute_shader_derivatives 
              | Spv_khr_cooperative_matrix 
              | Spv_khr_device_group 
              | Spv_khr_expect_assume 
              | Spv_khr_float_controls 
              | Spv_khr_float_controls2 
              | Spv_khr_fma 
              | Spv_khr_fragment_shader_barycentric 
              | Spv_khr_fragment_shading_rate 
              | Spv_khr_integer_dot_product 
              | Spv_khr_linkonce_odr 
              | Spv_khr_maximal_reconvergence 
              | Spv_khr_multiview 
              | Spv_khr_no_integer_wrap_decoration 
              | Spv_khr_physical_storage_buffer 
              | Spv_khr_post_depth_coverage 
              | Spv_khr_quad_control 
              | Spv_khr_ray_cull_mask 
              | Spv_khr_ray_query 
              | Spv_khr_ray_tracing 
              | Spv_khr_ray_tracing_position_fetch 
              | Spv_khr_relaxed_extended_instruction 
              | Spv_khr_shader_atomic_counter_ops 
              | Spv_khr_shader_ballot 
              | Spv_khr_shader_clock 
              | Spv_khr_shader_draw_parameters 
              | Spv_khr_storage_buffer_storage_class 
              | Spv_khr_subgroup_rotate 
              | Spv_khr_subgroup_uniform_control_flow 
              | Spv_khr_subgroup_vote 
              | Spv_khr_terminate_invocation 
              | Spv_khr_uniform_group_instructions 
              | Spv_khr_untyped_pointers 
              | Spv_khr_variable_pointers 
              | Spv_khr_vulkan_memory_model 
              | Spv_khr_workgroup_memory_explicit_layout 
              | Spv_nvx_multiview_per_view_attributes 
              | Spv_nv_bindless_texture 
              | Spv_nv_cluster_acceleration_structure 
              | Spv_nv_compute_shader_derivatives 
              | Spv_nv_cooperative_matrix 
              | Spv_nv_cooperative_matrix2 
              | Spv_nv_cooperative_vector 
              | Spv_nv_displacement_micromap 
              | Spv_nv_fragment_shader_barycentric 
              | Spv_nv_geometry_shader_passthrough 
              | Spv_nv_linear_swept_spheres 
              | Spv_nv_mesh_shader 
              | Spv_nv_raw_access_chains 
              | Spv_nv_ray_tracing 
              | Spv_nv_ray_tracing_motion_blur 
              | Spv_nv_sample_mask_override_coverage 
              | Spv_nv_shader_atomic_fp16_vector 
              | Spv_nv_shader_image_footprint 
              | Spv_nv_shader_invocation_reorder 
              | Spv_nv_shader_sm_builtins 
              | Spv_nv_shader_subgroup_partitioned 
              | Spv_nv_shading_rate 
              | Spv_nv_stereo_view_rendering 
              | Spv_nv_tensor_addressing 
              | Spv_nv_viewport_array2 
              | Spv_qcom_cooperative_matrix_conversion 
              | Spv_qcom_image_processing 
              | Spv_qcom_image_processing2 
              | Spv_qcom_tile_shading [@@deriving
                                        compare, sexp_of, enumerate]
          end
        include T
        include (Comparable.Make_plain)(T)
        let to_string =
          function
          | Spv_altera_arbitrary_precision_fixed_point ->
              "SPV_ALTERA_arbitrary_precision_fixed_point"
          | Spv_altera_arbitrary_precision_floating_point ->
              "SPV_ALTERA_arbitrary_precision_floating_point"
          | Spv_altera_arbitrary_precision_integers ->
              "SPV_ALTERA_arbitrary_precision_integers"
          | Spv_altera_blocking_pipes -> "SPV_ALTERA_blocking_pipes"
          | Spv_altera_fpga_argument_interfaces ->
              "SPV_ALTERA_fpga_argument_interfaces"
          | Spv_altera_fpga_buffer_location ->
              "SPV_ALTERA_fpga_buffer_location"
          | Spv_altera_fpga_cluster_attributes ->
              "SPV_ALTERA_fpga_cluster_attributes"
          | Spv_altera_fpga_dsp_control -> "SPV_ALTERA_fpga_dsp_control"
          | Spv_altera_fpga_invocation_pipelining_attributes ->
              "SPV_ALTERA_fpga_invocation_pipelining_attributes"
          | Spv_altera_fpga_latency_control ->
              "SPV_ALTERA_fpga_latency_control"
          | Spv_altera_fpga_loop_controls -> "SPV_ALTERA_fpga_loop_controls"
          | Spv_altera_fpga_memory_accesses ->
              "SPV_ALTERA_fpga_memory_accesses"
          | Spv_altera_fpga_memory_attributes ->
              "SPV_ALTERA_fpga_memory_attributes"
          | Spv_altera_fpga_reg -> "SPV_ALTERA_fpga_reg"
          | Spv_altera_global_variable_fpga_decorations ->
              "SPV_ALTERA_global_variable_fpga_decorations"
          | Spv_altera_io_pipes -> "SPV_ALTERA_io_pipes"
          | Spv_altera_loop_fuse -> "SPV_ALTERA_loop_fuse"
          | Spv_altera_runtime_aligned -> "SPV_ALTERA_runtime_aligned"
          | Spv_altera_task_sequence -> "SPV_ALTERA_task_sequence"
          | Spv_altera_usm_storage_classes ->
              "SPV_ALTERA_usm_storage_classes"
          | Spv_amdx_shader_enqueue -> "SPV_AMDX_shader_enqueue"
          | Spv_amd_gpu_shader_half_float_fetch ->
              "SPV_AMD_gpu_shader_half_float_fetch"
          | Spv_amd_shader_ballot -> "SPV_AMD_shader_ballot"
          | Spv_amd_shader_early_and_late_fragment_tests ->
              "SPV_AMD_shader_early_and_late_fragment_tests"
          | Spv_amd_shader_explicit_vertex_parameter ->
              "SPV_AMD_shader_explicit_vertex_parameter"
          | Spv_amd_shader_fragment_mask -> "SPV_AMD_shader_fragment_mask"
          | Spv_amd_shader_image_load_store_lod ->
              "SPV_AMD_shader_image_load_store_lod"
          | Spv_amd_texture_gather_bias_lod ->
              "SPV_AMD_texture_gather_bias_lod"
          | Spv_arm_cooperative_matrix_layouts ->
              "SPV_ARM_cooperative_matrix_layouts"
          | Spv_arm_core_builtins -> "SPV_ARM_core_builtins"
          | Spv_arm_graph -> "SPV_ARM_graph"
          | Spv_arm_tensors -> "SPV_ARM_tensors"
          | Spv_ext_arithmetic_fence -> "SPV_EXT_arithmetic_fence"
          | Spv_ext_demote_to_helper_invocation ->
              "SPV_EXT_demote_to_helper_invocation"
          | Spv_ext_descriptor_indexing -> "SPV_EXT_descriptor_indexing"
          | Spv_ext_float8 -> "SPV_EXT_float8"
          | Spv_ext_fragment_fully_covered ->
              "SPV_EXT_fragment_fully_covered"
          | Spv_ext_fragment_invocation_density ->
              "SPV_EXT_fragment_invocation_density"
          | Spv_ext_fragment_shader_interlock ->
              "SPV_EXT_fragment_shader_interlock"
          | Spv_ext_long_vector -> "SPV_EXT_long_vector"
          | Spv_ext_mesh_shader -> "SPV_EXT_mesh_shader"
          | Spv_ext_opacity_micromap -> "SPV_EXT_opacity_micromap"
          | Spv_ext_optnone -> "SPV_EXT_optnone"
          | Spv_ext_physical_storage_buffer ->
              "SPV_EXT_physical_storage_buffer"
          | Spv_ext_replicated_composites -> "SPV_EXT_replicated_composites"
          | Spv_ext_shader_64bit_indexing -> "SPV_EXT_shader_64bit_indexing"
          | Spv_ext_shader_atomic_float16_add ->
              "SPV_EXT_shader_atomic_float16_add"
          | Spv_ext_shader_atomic_float_add ->
              "SPV_EXT_shader_atomic_float_add"
          | Spv_ext_shader_atomic_float_min_max ->
              "SPV_EXT_shader_atomic_float_min_max"
          | Spv_ext_shader_image_int64 -> "SPV_EXT_shader_image_int64"
          | Spv_ext_shader_invocation_reorder ->
              "SPV_EXT_shader_invocation_reorder"
          | Spv_ext_shader_stencil_export -> "SPV_EXT_shader_stencil_export"
          | Spv_ext_shader_tile_image -> "SPV_EXT_shader_tile_image"
          | Spv_ext_shader_viewport_index_layer ->
              "SPV_EXT_shader_viewport_index_layer"
          | Spv_google_decorate_string -> "SPV_GOOGLE_decorate_string"
          | Spv_google_hlsl_functionality1 ->
              "SPV_GOOGLE_hlsl_functionality1"
          | Spv_google_user_type -> "SPV_GOOGLE_user_type"
          | Spv_intel_2d_block_io -> "SPV_INTEL_2d_block_io"
          | Spv_intel_arbitrary_precision_fixed_point ->
              "SPV_INTEL_arbitrary_precision_fixed_point"
          | Spv_intel_arbitrary_precision_floating_point ->
              "SPV_INTEL_arbitrary_precision_floating_point"
          | Spv_intel_arbitrary_precision_integers ->
              "SPV_INTEL_arbitrary_precision_integers"
          | Spv_intel_bfloat16_conversion -> "SPV_INTEL_bfloat16_conversion"
          | Spv_intel_bindless_images -> "SPV_INTEL_bindless_images"
          | Spv_intel_blocking_pipes -> "SPV_INTEL_blocking_pipes"
          | Spv_intel_cache_controls -> "SPV_INTEL_cache_controls"
          | Spv_intel_debug_module -> "SPV_INTEL_debug_module"
          | Spv_intel_device_side_avc_motion_estimation ->
              "SPV_INTEL_device_side_avc_motion_estimation"
          | Spv_intel_float_controls2 -> "SPV_INTEL_float_controls2"
          | Spv_intel_fp_fast_math_mode -> "SPV_INTEL_fp_fast_math_mode"
          | Spv_intel_fp_max_error -> "SPV_INTEL_fp_max_error"
          | Spv_intel_fpga_argument_interfaces ->
              "SPV_INTEL_fpga_argument_interfaces"
          | Spv_intel_fpga_buffer_location ->
              "SPV_INTEL_fpga_buffer_location"
          | Spv_intel_fpga_cluster_attributes ->
              "SPV_INTEL_fpga_cluster_attributes"
          | Spv_intel_fpga_dsp_control -> "SPV_INTEL_fpga_dsp_control"
          | Spv_intel_fpga_invocation_pipelining_attributes ->
              "SPV_INTEL_fpga_invocation_pipelining_attributes"
          | Spv_intel_fpga_latency_control ->
              "SPV_INTEL_fpga_latency_control"
          | Spv_intel_fpga_loop_controls -> "SPV_INTEL_fpga_loop_controls"
          | Spv_intel_fpga_memory_accesses ->
              "SPV_INTEL_fpga_memory_accesses"
          | Spv_intel_fpga_memory_attributes ->
              "SPV_INTEL_fpga_memory_attributes"
          | Spv_intel_fpga_reg -> "SPV_INTEL_fpga_reg"
          | Spv_intel_function_pointers -> "SPV_INTEL_function_pointers"
          | Spv_intel_function_variants -> "SPV_INTEL_function_variants"
          | Spv_intel_global_variable_fpga_decorations ->
              "SPV_INTEL_global_variable_fpga_decorations"
          | Spv_intel_global_variable_host_access ->
              "SPV_INTEL_global_variable_host_access"
          | Spv_intel_inline_assembly -> "SPV_INTEL_inline_assembly"
          | Spv_intel_int4 -> "SPV_INTEL_int4"
          | Spv_intel_io_pipes -> "SPV_INTEL_io_pipes"
          | Spv_intel_kernel_attributes -> "SPV_INTEL_kernel_attributes"
          | Spv_intel_long_composites -> "SPV_INTEL_long_composites"
          | Spv_intel_loop_fuse -> "SPV_INTEL_loop_fuse"
          | Spv_intel_masked_gather_scatter ->
              "SPV_INTEL_masked_gather_scatter"
          | Spv_intel_maximum_registers -> "SPV_INTEL_maximum_registers"
          | Spv_intel_media_block_io -> "SPV_INTEL_media_block_io"
          | Spv_intel_memory_access_aliasing ->
              "SPV_INTEL_memory_access_aliasing"
          | Spv_intel_optnone -> "SPV_INTEL_optnone"
          | Spv_intel_runtime_aligned -> "SPV_INTEL_runtime_aligned"
          | Spv_intel_shader_integer_functions2 ->
              "SPV_INTEL_shader_integer_functions2"
          | Spv_intel_split_barrier -> "SPV_INTEL_split_barrier"
          | Spv_intel_subgroup_buffer_prefetch ->
              "SPV_INTEL_subgroup_buffer_prefetch"
          | Spv_intel_subgroup_matrix_multiply_accumulate ->
              "SPV_INTEL_subgroup_matrix_multiply_accumulate"
          | Spv_intel_subgroups -> "SPV_INTEL_subgroups"
          | Spv_intel_task_sequence -> "SPV_INTEL_task_sequence"
          | Spv_intel_tensor_float32_conversion ->
              "SPV_INTEL_tensor_float32_conversion"
          | Spv_intel_ternary_bitwise_function ->
              "SPV_INTEL_ternary_bitwise_function"
          | Spv_intel_unstructured_loop_controls ->
              "SPV_INTEL_unstructured_loop_controls"
          | Spv_intel_usm_storage_classes -> "SPV_INTEL_usm_storage_classes"
          | Spv_intel_variable_length_array ->
              "SPV_INTEL_variable_length_array"
          | Spv_intel_vector_compute -> "SPV_INTEL_vector_compute"
          | Spv_khr_16bit_storage -> "SPV_KHR_16bit_storage"
          | Spv_khr_8bit_storage -> "SPV_KHR_8bit_storage"
          | Spv_khr_bfloat16 -> "SPV_KHR_bfloat16"
          | Spv_khr_bit_instructions -> "SPV_KHR_bit_instructions"
          | Spv_khr_compute_shader_derivatives ->
              "SPV_KHR_compute_shader_derivatives"
          | Spv_khr_cooperative_matrix -> "SPV_KHR_cooperative_matrix"
          | Spv_khr_device_group -> "SPV_KHR_device_group"
          | Spv_khr_expect_assume -> "SPV_KHR_expect_assume"
          | Spv_khr_float_controls -> "SPV_KHR_float_controls"
          | Spv_khr_float_controls2 -> "SPV_KHR_float_controls2"
          | Spv_khr_fma -> "SPV_KHR_fma"
          | Spv_khr_fragment_shader_barycentric ->
              "SPV_KHR_fragment_shader_barycentric"
          | Spv_khr_fragment_shading_rate -> "SPV_KHR_fragment_shading_rate"
          | Spv_khr_integer_dot_product -> "SPV_KHR_integer_dot_product"
          | Spv_khr_linkonce_odr -> "SPV_KHR_linkonce_odr"
          | Spv_khr_maximal_reconvergence -> "SPV_KHR_maximal_reconvergence"
          | Spv_khr_multiview -> "SPV_KHR_multiview"
          | Spv_khr_no_integer_wrap_decoration ->
              "SPV_KHR_no_integer_wrap_decoration"
          | Spv_khr_physical_storage_buffer ->
              "SPV_KHR_physical_storage_buffer"
          | Spv_khr_post_depth_coverage -> "SPV_KHR_post_depth_coverage"
          | Spv_khr_quad_control -> "SPV_KHR_quad_control"
          | Spv_khr_ray_cull_mask -> "SPV_KHR_ray_cull_mask"
          | Spv_khr_ray_query -> "SPV_KHR_ray_query"
          | Spv_khr_ray_tracing -> "SPV_KHR_ray_tracing"
          | Spv_khr_ray_tracing_position_fetch ->
              "SPV_KHR_ray_tracing_position_fetch"
          | Spv_khr_relaxed_extended_instruction ->
              "SPV_KHR_relaxed_extended_instruction"
          | Spv_khr_shader_atomic_counter_ops ->
              "SPV_KHR_shader_atomic_counter_ops"
          | Spv_khr_shader_ballot -> "SPV_KHR_shader_ballot"
          | Spv_khr_shader_clock -> "SPV_KHR_shader_clock"
          | Spv_khr_shader_draw_parameters ->
              "SPV_KHR_shader_draw_parameters"
          | Spv_khr_storage_buffer_storage_class ->
              "SPV_KHR_storage_buffer_storage_class"
          | Spv_khr_subgroup_rotate -> "SPV_KHR_subgroup_rotate"
          | Spv_khr_subgroup_uniform_control_flow ->
              "SPV_KHR_subgroup_uniform_control_flow"
          | Spv_khr_subgroup_vote -> "SPV_KHR_subgroup_vote"
          | Spv_khr_terminate_invocation -> "SPV_KHR_terminate_invocation"
          | Spv_khr_uniform_group_instructions ->
              "SPV_KHR_uniform_group_instructions"
          | Spv_khr_untyped_pointers -> "SPV_KHR_untyped_pointers"
          | Spv_khr_variable_pointers -> "SPV_KHR_variable_pointers"
          | Spv_khr_vulkan_memory_model -> "SPV_KHR_vulkan_memory_model"
          | Spv_khr_workgroup_memory_explicit_layout ->
              "SPV_KHR_workgroup_memory_explicit_layout"
          | Spv_nvx_multiview_per_view_attributes ->
              "SPV_NVX_multiview_per_view_attributes"
          | Spv_nv_bindless_texture -> "SPV_NV_bindless_texture"
          | Spv_nv_cluster_acceleration_structure ->
              "SPV_NV_cluster_acceleration_structure"
          | Spv_nv_compute_shader_derivatives ->
              "SPV_NV_compute_shader_derivatives"
          | Spv_nv_cooperative_matrix -> "SPV_NV_cooperative_matrix"
          | Spv_nv_cooperative_matrix2 -> "SPV_NV_cooperative_matrix2"
          | Spv_nv_cooperative_vector -> "SPV_NV_cooperative_vector"
          | Spv_nv_displacement_micromap -> "SPV_NV_displacement_micromap"
          | Spv_nv_fragment_shader_barycentric ->
              "SPV_NV_fragment_shader_barycentric"
          | Spv_nv_geometry_shader_passthrough ->
              "SPV_NV_geometry_shader_passthrough"
          | Spv_nv_linear_swept_spheres -> "SPV_NV_linear_swept_spheres"
          | Spv_nv_mesh_shader -> "SPV_NV_mesh_shader"
          | Spv_nv_raw_access_chains -> "SPV_NV_raw_access_chains"
          | Spv_nv_ray_tracing -> "SPV_NV_ray_tracing"
          | Spv_nv_ray_tracing_motion_blur ->
              "SPV_NV_ray_tracing_motion_blur"
          | Spv_nv_sample_mask_override_coverage ->
              "SPV_NV_sample_mask_override_coverage"
          | Spv_nv_shader_atomic_fp16_vector ->
              "SPV_NV_shader_atomic_fp16_vector"
          | Spv_nv_shader_image_footprint -> "SPV_NV_shader_image_footprint"
          | Spv_nv_shader_invocation_reorder ->
              "SPV_NV_shader_invocation_reorder"
          | Spv_nv_shader_sm_builtins -> "SPV_NV_shader_sm_builtins"
          | Spv_nv_shader_subgroup_partitioned ->
              "SPV_NV_shader_subgroup_partitioned"
          | Spv_nv_shading_rate -> "SPV_NV_shading_rate"
          | Spv_nv_stereo_view_rendering -> "SPV_NV_stereo_view_rendering"
          | Spv_nv_tensor_addressing -> "SPV_NV_tensor_addressing"
          | Spv_nv_viewport_array2 -> "SPV_NV_viewport_array2"
          | Spv_qcom_cooperative_matrix_conversion ->
              "SPV_QCOM_cooperative_matrix_conversion"
          | Spv_qcom_image_processing -> "SPV_QCOM_image_processing"
          | Spv_qcom_image_processing2 -> "SPV_QCOM_image_processing2"
          | Spv_qcom_tile_shading -> "SPV_QCOM_tile_shading"
      end
  end
module Instruction_printing_class =
  struct
    type t =
      | Annotation 
      | Arithmetic 
      | Atomic 
      | Barrier 
      | Bit 
      | Composite 
      | Constant_creation 
      | Control_flow 
      | Conversion 
      | Debug 
      | Derivative 
      | Device_side_enqueue 
      | Exclude 
      | Extension 
      | Function 
      | Graph 
      | Group 
      | Image 
      | Memory 
      | Miscellaneous 
      | Mode_setting 
      | Non_uniform 
      | Pipe 
      | Primitive 
      | Relational_and_logical 
      | Reserved 
      | Tensor 
      | Type_declaration [@@deriving compare, sexp_of, enumerate]
    let heading =
      function
      | Annotation -> Some "Annotation Instructions"
      | Arithmetic -> Some "Arithmetic Instructions"
      | Atomic -> Some "Atomic Instructions"
      | Barrier -> Some "Barrier Instructions"
      | Bit -> Some "Bit Instructions"
      | Composite -> Some "Composite Instructions"
      | Constant_creation -> Some "Constant-Creation Instructions"
      | Control_flow -> Some "Control-Flow Instructions"
      | Conversion -> Some "Conversion Instructions"
      | Debug -> Some "Debug Instructions"
      | Derivative -> Some "Derivative Instructions"
      | Device_side_enqueue -> Some "Device-Side Enqueue Instructions"
      | Exclude -> None
      | Extension -> Some "Extension Instructions"
      | Function -> Some "Function Instructions"
      | Graph -> Some "Graph Instructions"
      | Group -> Some "Group and Subgroup Instructions"
      | Image -> Some "Image Instructions"
      | Memory -> Some "Memory Instructions"
      | Miscellaneous -> Some "Miscellaneous Instructions"
      | Mode_setting -> Some "Mode-Setting Instructions"
      | Non_uniform -> Some "Non-Uniform Instructions"
      | Pipe -> Some "Pipe Instructions"
      | Primitive -> Some "Primitive Instructions"
      | Relational_and_logical -> Some "Relational and Logical Instructions"
      | Reserved -> Some "Reserved Instructions"
      | Tensor -> Some "Tensor Instructions"
      | Type_declaration -> Some "Type-Declaration Instructions"
  end
module Operand_kind =
  struct
    module Category =
      struct
        type t =
          | Bitenum 
          | Composite 
          | Id 
          | Literal 
          | Valueenum [@@deriving compare, sexp_of, enumerate]
      end
    module Payload =
      struct
        module Capability =
          struct
            module T =
              struct
                type t =
                  | Addresses 
                  | Arbitraryprecisionfixedpointaltera 
                  | Arbitraryprecisionfloatingpointaltera 
                  | Arbitraryprecisionintegersaltera 
                  | Arithmeticfenceext 
                  | Asmintel 
                  | Atomicfloat16addext 
                  | Atomicfloat16minmaxext 
                  | Atomicfloat16vectornv 
                  | Atomicfloat32addext 
                  | Atomicfloat32minmaxext 
                  | Atomicfloat64addext 
                  | Atomicfloat64minmaxext 
                  | Atomicstorage 
                  | Atomicstorageops 
                  | Bfloat16conversionintel 
                  | Bfloat16cooperativematrixkhr 
                  | Bfloat16dotproductkhr 
                  | Bfloat16typekhr 
                  | Bindlessimagesintel 
                  | Bindlesstexturenv 
                  | Bitinstructions 
                  | Blockingpipesaltera 
                  | Cachecontrolsintel 
                  | Clipdistance 
                  | Computederivativegrouplinearkhr 
                  | Computederivativegroupquadskhr 
                  | Cooperativematrixblockloadsnv 
                  | Cooperativematrixconversionqcom 
                  | Cooperativematrixconversionsnv 
                  | Cooperativematrixkhr 
                  | Cooperativematrixlayoutsarm 
                  | Cooperativematrixnv 
                  | Cooperativematrixperelementoperationsnv 
                  | Cooperativematrixreductionsnv 
                  | Cooperativematrixtensoraddressingnv 
                  | Cooperativevectornv 
                  | Cooperativevectortrainingnv 
                  | Corebuiltinsarm 
                  | Culldistance 
                  | Debuginfomoduleintel 
                  | Demotetohelperinvocation 
                  | Denormflushtozero 
                  | Denormpreserve 
                  | Derivativecontrol 
                  | Deviceenqueue 
                  | Devicegroup 
                  | Displacementmicromapnv 
                  | Dotproduct 
                  | Dotproductinput4x8bit 
                  | Dotproductinput4x8bitpacked 
                  | Dotproductinputall 
                  | Drawparameters 
                  | Expectassumekhr 
                  | Float16 
                  | Float16buffer 
                  | Float16imageamd 
                  | Float64 
                  | Float8cooperativematrixext 
                  | Float8ext 
                  | Floatcontrols2 
                  | Floatingpointmodeintel 
                  | Fmakhr 
                  | Fpfastmathmodeintel 
                  | Fpgaargumentinterfacesaltera 
                  | Fpgabufferlocationaltera 
                  | Fpgaclusterattributesaltera 
                  | Fpgaclusterattributesv2altera 
                  | Fpgadspcontrolaltera 
                  | Fpgainvocationpipeliningattributesaltera 
                  | Fpgakernelattributesintel 
                  | Fpgakernelattributesv2intel 
                  | Fpgalatencycontrolaltera 
                  | Fpgaloopcontrolsaltera 
                  | Fpgamemoryaccessesaltera 
                  | Fpgamemoryattributesaltera 
                  | Fpgaregaltera 
                  | Fpmaxerrorintel 
                  | Fragmentbarycentrickhr 
                  | Fragmentdensityext 
                  | Fragmentfullycoveredext 
                  | Fragmentmaskamd 
                  | Fragmentshaderpixelinterlockext 
                  | Fragmentshadersampleinterlockext 
                  | Fragmentshadershadingrateinterlockext 
                  | Fragmentshadingratekhr 
                  | Functionfloatcontrolintel 
                  | Functionpointersintel 
                  | Functionvariantsintel 
                  | Genericpointer 
                  | Geometry 
                  | Geometrypointsize 
                  | Geometryshaderpassthroughnv 
                  | Geometrystreams 
                  | Globalvariablefpgadecorationsaltera 
                  | Globalvariablehostaccessintel 
                  | Grapharm 
                  | Groupnonuniform 
                  | Groupnonuniformarithmetic 
                  | Groupnonuniformballot 
                  | Groupnonuniformclustered 
                  | Groupnonuniformpartitionednv 
                  | Groupnonuniformquad 
                  | Groupnonuniformrotatekhr 
                  | Groupnonuniformshuffle 
                  | Groupnonuniformshufflerelative 
                  | Groupnonuniformvote 
                  | Groups 
                  | Groupuniformarithmetickhr 
                  | Image1d 
                  | Imagebasic 
                  | Imagebuffer 
                  | Imagecubearray 
                  | Imagefootprintnv 
                  | Imagegatherbiaslodamd 
                  | Imagegatherextended 
                  | Imagemipmap 
                  | Imagemsarray 
                  | Imagequery 
                  | Imagereadwrite 
                  | Imagereadwritelodamd 
                  | Imagerect 
                  | Indirectreferencesintel 
                  | Inputattachment 
                  | Inputattachmentarraydynamicindexing 
                  | Inputattachmentarraynonuniformindexing 
                  | Int16 
                  | Int4cooperativematrixintel 
                  | Int4typeintel 
                  | Int64 
                  | Int64atomics 
                  | Int64imageext 
                  | Int8 
                  | Integerfunctions2intel 
                  | Interpolationfunction 
                  | Iopipesaltera 
                  | Kernel 
                  | Kernelattributesintel 
                  | Linkage 
                  | Literalsampler 
                  | Longcompositesintel 
                  | Longvectorext 
                  | Loopfusealtera 
                  | Maskedgatherscatterintel 
                  | Matrix 
                  | Memoryaccessaliasingintel 
                  | Meshshadingext 
                  | Meshshadingnv 
                  | Minlod 
                  | Multiview 
                  | Multiviewport 
                  | Namedbarrier 
                  | Optnoneext 
                  | Perviewattributesnv 
                  | Physicalstoragebufferaddresses 
                  | Pipes 
                  | Pipestorage 
                  | Quadcontrolkhr 
                  | Rawaccesschainsnv 
                  | Raycullmaskkhr 
                  | Rayquerykhr 
                  | Rayquerypositionfetchkhr 
                  | Rayqueryprovisionalkhr 
                  | Raytracingclusteraccelerationstructurenv 
                  | Raytracingdisplacementmicromapnv 
                  | Raytracingkhr 
                  | Raytracinglinearsweptspheresgeometrynv 
                  | Raytracingmotionblurnv 
                  | Raytracingnv 
                  | Raytracingopacitymicromapext 
                  | Raytracingpositionfetchkhr 
                  | Raytracingprovisionalkhr 
                  | Raytracingspheresgeometrynv 
                  | Raytraversalprimitivecullingkhr 
                  | Registerlimitsintel 
                  | Replicatedcompositesext 
                  | Roundingmoderte 
                  | Roundingmodertz 
                  | Roundtoinfinityintel 
                  | Runtimealignedattributealtera 
                  | Runtimedescriptorarray 
                  | Sampled1d 
                  | Sampledbuffer 
                  | Sampledcubearray 
                  | Sampledimagearraydynamicindexing 
                  | Sampledimagearraynonuniformindexing 
                  | Sampledrect 
                  | Samplemaskoverridecoveragenv 
                  | Samplemaskpostdepthcoverage 
                  | Samplerateshading 
                  | Shader 
                  | Shader64bitindexingext 
                  | Shaderclockkhr 
                  | Shaderenqueueamdx 
                  | Shaderinvocationreorderext 
                  | Shaderinvocationreordernv 
                  | Shaderlayer 
                  | Shadernonuniform 
                  | Shadersmbuiltinsnv 
                  | Shaderstereoviewnv 
                  | Shaderviewportindex 
                  | Shaderviewportindexlayerext 
                  | Shaderviewportmasknv 
                  | Signedzeroinfnanpreserve 
                  | Sparseresidency 
                  | Specconditionalintel 
                  | Splitbarrierintel 
                  | Stencilexportext 
                  | Storagebuffer16bitaccess 
                  | Storagebuffer8bitaccess 
                  | Storagebufferarraydynamicindexing 
                  | Storagebufferarraynonuniformindexing 
                  | Storageimagearraydynamicindexing 
                  | Storageimagearraynonuniformindexing 
                  | Storageimageextendedformats 
                  | Storageimagemultisample 
                  | Storageimagereadwithoutformat 
                  | Storageimagewritewithoutformat 
                  | Storageinputoutput16 
                  | Storagepushconstant16 
                  | Storagepushconstant8 
                  | Storagetensorarraydynamicindexingarm 
                  | Storagetensorarraynonuniformindexingarm 
                  | Storagetexelbufferarraydynamicindexing 
                  | Storagetexelbufferarraynonuniformindexing 
                  | Subgroup2dblockiointel 
                  | Subgroup2dblocktransformintel 
                  | Subgroup2dblocktransposeintel 
                  | Subgroupavcmotionestimationchromaintel 
                  | Subgroupavcmotionestimationintel 
                  | Subgroupavcmotionestimationintraintel 
                  | Subgroupballotkhr 
                  | Subgroupbufferblockiointel 
                  | Subgroupbufferprefetchintel 
                  | Subgroupdispatch 
                  | Subgroupimageblockiointel 
                  | Subgroupimagemediablockiointel 
                  | Subgroupmatrixmultiplyaccumulateintel 
                  | Subgroupshuffleintel 
                  | Subgroupvotekhr 
                  | Tasksequencealtera 
                  | Tensoraddressingnv 
                  | Tensorfloat32roundingintel 
                  | Tensorsarm 
                  | Ternarybitwisefunctionintel 
                  | Tessellation 
                  | Tessellationpointsize 
                  | Textureblockmatch2qcom 
                  | Textureblockmatchqcom 
                  | Textureboxfilterqcom 
                  | Texturesampleweightedqcom 
                  | Tileimagecolorreadaccessext 
                  | Tileimagedepthreadaccessext 
                  | Tileimagestencilreadaccessext 
                  | Tileshadingqcom 
                  | Transformfeedback 
                  | Uniformandstoragebuffer16bitaccess 
                  | Uniformandstoragebuffer8bitaccess 
                  | Uniformbufferarraydynamicindexing 
                  | Uniformbufferarraynonuniformindexing 
                  | Uniformdecoration 
                  | Uniformtexelbufferarraydynamicindexing 
                  | Uniformtexelbufferarraynonuniformindexing 
                  | Unstructuredloopcontrolsintel 
                  | Untypedpointerskhr 
                  | Untypedvariablelengtharrayintel 
                  | Usmstorageclassesaltera 
                  | Variablelengtharrayintel 
                  | Variablepointers 
                  | Variablepointersstoragebuffer 
                  | Vector16 
                  | Vectoranyintel 
                  | Vectorcomputeintel 
                  | Vulkanmemorymodel 
                  | Vulkanmemorymodeldevicescope 
                  | Workgroupmemoryexplicitlayout16bitaccesskhr 
                  | Workgroupmemoryexplicitlayout8bitaccesskhr 
                  | Workgroupmemoryexplicitlayoutkhr [@@deriving
                                                       compare, sexp_of, enumerate]
              end
            include T
            include (Comparable.Make_plain)(T)
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Addresses -> [4l]
              | Arbitraryprecisionfixedpointaltera -> [5922l]
              | Arbitraryprecisionfloatingpointaltera -> [5845l]
              | Arbitraryprecisionintegersaltera -> [5844l]
              | Arithmeticfenceext -> [6144l]
              | Asmintel -> [5606l]
              | Atomicfloat16addext -> [6095l]
              | Atomicfloat16minmaxext -> [5616l]
              | Atomicfloat16vectornv -> [5404l]
              | Atomicfloat32addext -> [6033l]
              | Atomicfloat32minmaxext -> [5612l]
              | Atomicfloat64addext -> [6034l]
              | Atomicfloat64minmaxext -> [5613l]
              | Atomicstorage -> [21l]
              | Atomicstorageops -> [4445l]
              | Bfloat16conversionintel -> [6115l]
              | Bfloat16cooperativematrixkhr -> [5118l]
              | Bfloat16dotproductkhr -> [5117l]
              | Bfloat16typekhr -> [5116l]
              | Bindlessimagesintel -> [6528l]
              | Bindlesstexturenv -> [5390l]
              | Bitinstructions -> [6025l]
              | Blockingpipesaltera -> [5945l]
              | Cachecontrolsintel -> [6441l]
              | Clipdistance -> [32l]
              | Computederivativegrouplinearkhr -> [5350l]
              | Computederivativegroupquadskhr -> [5288l]
              | Cooperativematrixblockloadsnv -> [5434l]
              | Cooperativematrixconversionqcom -> [4496l]
              | Cooperativematrixconversionsnv -> [5431l]
              | Cooperativematrixkhr -> [6022l]
              | Cooperativematrixlayoutsarm -> [4201l]
              | Cooperativematrixnv -> [5357l]
              | Cooperativematrixperelementoperationsnv -> [5432l]
              | Cooperativematrixreductionsnv -> [5430l]
              | Cooperativematrixtensoraddressingnv -> [5433l]
              | Cooperativevectornv -> [5394l]
              | Cooperativevectortrainingnv -> [5435l]
              | Corebuiltinsarm -> [4165l]
              | Culldistance -> [33l]
              | Debuginfomoduleintel -> [6114l]
              | Demotetohelperinvocation -> [5379l]
              | Denormflushtozero -> [4465l]
              | Denormpreserve -> [4464l]
              | Derivativecontrol -> [51l]
              | Deviceenqueue -> [19l]
              | Devicegroup -> [4437l]
              | Displacementmicromapnv -> [5380l]
              | Dotproduct -> [6019l]
              | Dotproductinput4x8bit -> [6017l]
              | Dotproductinput4x8bitpacked -> [6018l]
              | Dotproductinputall -> [6016l]
              | Drawparameters -> [4427l]
              | Expectassumekhr -> [5629l]
              | Float16 -> [9l]
              | Float16buffer -> [8l]
              | Float16imageamd -> [5008l]
              | Float64 -> [10l]
              | Float8cooperativematrixext -> [4213l]
              | Float8ext -> [4212l]
              | Floatcontrols2 -> [6029l]
              | Floatingpointmodeintel -> [5583l]
              | Fmakhr -> [6030l]
              | Fpfastmathmodeintel -> [5837l]
              | Fpgaargumentinterfacesaltera -> [6174l]
              | Fpgabufferlocationaltera -> [5920l]
              | Fpgaclusterattributesaltera -> [5904l]
              | Fpgaclusterattributesv2altera -> [6150l]
              | Fpgadspcontrolaltera -> [5908l]
              | Fpgainvocationpipeliningattributesaltera -> [5916l]
              | Fpgakernelattributesintel -> [5897l]
              | Fpgakernelattributesv2intel -> [6161l]
              | Fpgalatencycontrolaltera -> [6171l]
              | Fpgaloopcontrolsaltera -> [5888l]
              | Fpgamemoryaccessesaltera -> [5898l]
              | Fpgamemoryattributesaltera -> [5824l]
              | Fpgaregaltera -> [5948l]
              | Fpmaxerrorintel -> [6169l]
              | Fragmentbarycentrickhr -> [5284l]
              | Fragmentdensityext -> [5291l]
              | Fragmentfullycoveredext -> [5265l]
              | Fragmentmaskamd -> [5010l]
              | Fragmentshaderpixelinterlockext -> [5378l]
              | Fragmentshadersampleinterlockext -> [5363l]
              | Fragmentshadershadingrateinterlockext -> [5372l]
              | Fragmentshadingratekhr -> [4422l]
              | Functionfloatcontrolintel -> [5821l]
              | Functionpointersintel -> [5603l]
              | Functionvariantsintel -> [6246l]
              | Genericpointer -> [38l]
              | Geometry -> [2l]
              | Geometrypointsize -> [24l]
              | Geometryshaderpassthroughnv -> [5251l]
              | Geometrystreams -> [54l]
              | Globalvariablefpgadecorationsaltera -> [6189l]
              | Globalvariablehostaccessintel -> [6187l]
              | Grapharm -> [4191l]
              | Groupnonuniform -> [61l]
              | Groupnonuniformarithmetic -> [63l]
              | Groupnonuniformballot -> [64l]
              | Groupnonuniformclustered -> [67l]
              | Groupnonuniformpartitionednv -> [5297l]
              | Groupnonuniformquad -> [68l]
              | Groupnonuniformrotatekhr -> [6026l]
              | Groupnonuniformshuffle -> [65l]
              | Groupnonuniformshufflerelative -> [66l]
              | Groupnonuniformvote -> [62l]
              | Groups -> [18l]
              | Groupuniformarithmetickhr -> [6400l]
              | Image1d -> [44l]
              | Imagebasic -> [13l]
              | Imagebuffer -> [47l]
              | Imagecubearray -> [34l]
              | Imagefootprintnv -> [5282l]
              | Imagegatherbiaslodamd -> [5009l]
              | Imagegatherextended -> [25l]
              | Imagemipmap -> [15l]
              | Imagemsarray -> [48l]
              | Imagequery -> [50l]
              | Imagereadwrite -> [14l]
              | Imagereadwritelodamd -> [5015l]
              | Imagerect -> [36l]
              | Indirectreferencesintel -> [5604l]
              | Inputattachment -> [40l]
              | Inputattachmentarraydynamicindexing -> [5303l]
              | Inputattachmentarraynonuniformindexing -> [5310l]
              | Int16 -> [22l]
              | Int4cooperativematrixintel -> [5114l]
              | Int4typeintel -> [5112l]
              | Int64 -> [11l]
              | Int64atomics -> [12l]
              | Int64imageext -> [5016l]
              | Int8 -> [39l]
              | Integerfunctions2intel -> [5584l]
              | Interpolationfunction -> [52l]
              | Iopipesaltera -> [5943l]
              | Kernel -> [6l]
              | Kernelattributesintel -> [5892l]
              | Linkage -> [5l]
              | Literalsampler -> [20l]
              | Longcompositesintel -> [6089l]
              | Longvectorext -> [5425l]
              | Loopfusealtera -> [5906l]
              | Maskedgatherscatterintel -> [6427l]
              | Matrix -> [0l]
              | Memoryaccessaliasingintel -> [5910l]
              | Meshshadingext -> [5283l]
              | Meshshadingnv -> [5266l]
              | Minlod -> [42l]
              | Multiview -> [4439l]
              | Multiviewport -> [57l]
              | Namedbarrier -> [59l]
              | Optnoneext -> [6094l]
              | Perviewattributesnv -> [5260l]
              | Physicalstoragebufferaddresses -> [5347l]
              | Pipes -> [17l]
              | Pipestorage -> [60l]
              | Quadcontrolkhr -> [5087l]
              | Rawaccesschainsnv -> [5414l]
              | Raycullmaskkhr -> [6020l]
              | Rayquerykhr -> [4472l]
              | Rayquerypositionfetchkhr -> [5391l]
              | Rayqueryprovisionalkhr -> [4471l]
              | Raytracingclusteraccelerationstructurenv -> [5437l]
              | Raytracingdisplacementmicromapnv -> [5409l]
              | Raytracingkhr -> [4479l]
              | Raytracinglinearsweptspheresgeometrynv -> [5419l]
              | Raytracingmotionblurnv -> [5341l]
              | Raytracingnv -> [5340l]
              | Raytracingopacitymicromapext -> [5381l]
              | Raytracingpositionfetchkhr -> [5336l]
              | Raytracingprovisionalkhr -> [5353l]
              | Raytracingspheresgeometrynv -> [5418l]
              | Raytraversalprimitivecullingkhr -> [4478l]
              | Registerlimitsintel -> [6460l]
              | Replicatedcompositesext -> [6024l]
              | Roundingmoderte -> [4467l]
              | Roundingmodertz -> [4468l]
              | Roundtoinfinityintel -> [5582l]
              | Runtimealignedattributealtera -> [5939l]
              | Runtimedescriptorarray -> [5302l]
              | Sampled1d -> [43l]
              | Sampledbuffer -> [46l]
              | Sampledcubearray -> [45l]
              | Sampledimagearraydynamicindexing -> [29l]
              | Sampledimagearraynonuniformindexing -> [5307l]
              | Sampledrect -> [37l]
              | Samplemaskoverridecoveragenv -> [5249l]
              | Samplemaskpostdepthcoverage -> [4447l]
              | Samplerateshading -> [35l]
              | Shader -> [1l]
              | Shader64bitindexingext -> [5426l]
              | Shaderclockkhr -> [5055l]
              | Shaderenqueueamdx -> [5067l]
              | Shaderinvocationreorderext -> [5388l]
              | Shaderinvocationreordernv -> [5383l]
              | Shaderlayer -> [69l]
              | Shadernonuniform -> [5301l]
              | Shadersmbuiltinsnv -> [5373l]
              | Shaderstereoviewnv -> [5259l]
              | Shaderviewportindex -> [70l]
              | Shaderviewportindexlayerext -> [5254l]
              | Shaderviewportmasknv -> [5255l]
              | Signedzeroinfnanpreserve -> [4466l]
              | Sparseresidency -> [41l]
              | Specconditionalintel -> [6245l]
              | Splitbarrierintel -> [6141l]
              | Stencilexportext -> [5013l]
              | Storagebuffer16bitaccess -> [4433l]
              | Storagebuffer8bitaccess -> [4448l]
              | Storagebufferarraydynamicindexing -> [30l]
              | Storagebufferarraynonuniformindexing -> [5308l]
              | Storageimagearraydynamicindexing -> [31l]
              | Storageimagearraynonuniformindexing -> [5309l]
              | Storageimageextendedformats -> [49l]
              | Storageimagemultisample -> [27l]
              | Storageimagereadwithoutformat -> [55l]
              | Storageimagewritewithoutformat -> [56l]
              | Storageinputoutput16 -> [4436l]
              | Storagepushconstant16 -> [4435l]
              | Storagepushconstant8 -> [4450l]
              | Storagetensorarraydynamicindexingarm -> [4175l]
              | Storagetensorarraynonuniformindexingarm -> [4176l]
              | Storagetexelbufferarraydynamicindexing -> [5305l]
              | Storagetexelbufferarraynonuniformindexing -> [5312l]
              | Subgroup2dblockiointel -> [6228l]
              | Subgroup2dblocktransformintel -> [6229l]
              | Subgroup2dblocktransposeintel -> [6230l]
              | Subgroupavcmotionestimationchromaintel -> [5698l]
              | Subgroupavcmotionestimationintel -> [5696l]
              | Subgroupavcmotionestimationintraintel -> [5697l]
              | Subgroupballotkhr -> [4423l]
              | Subgroupbufferblockiointel -> [5569l]
              | Subgroupbufferprefetchintel -> [6220l]
              | Subgroupdispatch -> [58l]
              | Subgroupimageblockiointel -> [5570l]
              | Subgroupimagemediablockiointel -> [5579l]
              | Subgroupmatrixmultiplyaccumulateintel -> [6236l]
              | Subgroupshuffleintel -> [5568l]
              | Subgroupvotekhr -> [4431l]
              | Tasksequencealtera -> [6162l]
              | Tensoraddressingnv -> [5439l]
              | Tensorfloat32roundingintel -> [6425l]
              | Tensorsarm -> [4174l]
              | Ternarybitwisefunctionintel -> [6241l]
              | Tessellation -> [3l]
              | Tessellationpointsize -> [23l]
              | Textureblockmatch2qcom -> [4498l]
              | Textureblockmatchqcom -> [4486l]
              | Textureboxfilterqcom -> [4485l]
              | Texturesampleweightedqcom -> [4484l]
              | Tileimagecolorreadaccessext -> [4166l]
              | Tileimagedepthreadaccessext -> [4167l]
              | Tileimagestencilreadaccessext -> [4168l]
              | Tileshadingqcom -> [4495l]
              | Transformfeedback -> [53l]
              | Uniformandstoragebuffer16bitaccess -> [4434l]
              | Uniformandstoragebuffer8bitaccess -> [4449l]
              | Uniformbufferarraydynamicindexing -> [28l]
              | Uniformbufferarraynonuniformindexing -> [5306l]
              | Uniformdecoration -> [71l]
              | Uniformtexelbufferarraydynamicindexing -> [5304l]
              | Uniformtexelbufferarraynonuniformindexing -> [5311l]
              | Unstructuredloopcontrolsintel -> [5886l]
              | Untypedpointerskhr -> [4473l]
              | Untypedvariablelengtharrayintel -> [6243l]
              | Usmstorageclassesaltera -> [5935l]
              | Variablelengtharrayintel -> [5817l]
              | Variablepointers -> [4442l]
              | Variablepointersstoragebuffer -> [4441l]
              | Vector16 -> [7l]
              | Vectoranyintel -> [5619l]
              | Vectorcomputeintel -> [5617l]
              | Vulkanmemorymodel -> [5345l]
              | Vulkanmemorymodeldevicescope -> [5346l]
              | Workgroupmemoryexplicitlayout16bitaccesskhr -> [4430l]
              | Workgroupmemoryexplicitlayout8bitaccesskhr -> [4429l]
              | Workgroupmemoryexplicitlayoutkhr -> [4428l]
            let any_required_version =
              function
              | Addresses ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Arbitraryprecisionfixedpointaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Arbitraryprecisionfloatingpointaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Arbitraryprecisionintegersaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Arithmeticfenceext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Asmintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicfloat16addext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicfloat16minmaxext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicfloat16vectornv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicfloat32addext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicfloat32minmaxext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicfloat64addext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicfloat64minmaxext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicstorage ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomicstorageops ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bfloat16conversionintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bfloat16cooperativematrixkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bfloat16dotproductkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bfloat16typekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bindlessimagesintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bindlesstexturenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bitinstructions ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Blockingpipesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cachecontrolsintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Clipdistance ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Computederivativegrouplinearkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Computederivativegroupquadskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixblockloadsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixconversionqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixconversionsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixlayoutsarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixperelementoperationsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixreductionsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativematrixtensoraddressingnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativevectornv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cooperativevectortrainingnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Corebuiltinsarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Culldistance ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Debuginfomoduleintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Demotetohelperinvocation ->
                  (Requirements.Version.valid_versions ~required:(Some V1_6)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Denormflushtozero ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Denormpreserve ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Derivativecontrol ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Deviceenqueue ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Devicegroup ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Displacementmicromapnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dotproduct ->
                  (Requirements.Version.valid_versions ~required:(Some V1_6)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dotproductinput4x8bit ->
                  (Requirements.Version.valid_versions ~required:(Some V1_6)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dotproductinput4x8bitpacked ->
                  (Requirements.Version.valid_versions ~required:(Some V1_6)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dotproductinputall ->
                  (Requirements.Version.valid_versions ~required:(Some V1_6)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Drawparameters ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Expectassumekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float16buffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float16imageamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float64 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float8cooperativematrixext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float8ext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Floatcontrols2 ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Floatingpointmodeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fmakhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpfastmathmodeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgaargumentinterfacesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgabufferlocationaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgaclusterattributesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgaclusterattributesv2altera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgadspcontrolaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgainvocationpipeliningattributesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgakernelattributesintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgakernelattributesv2intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgalatencycontrolaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgaloopcontrolsaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgamemoryaccessesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgamemoryattributesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpgaregaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpmaxerrorintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragmentbarycentrickhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragmentdensityext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragmentfullycoveredext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragmentmaskamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragmentshaderpixelinterlockext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragmentshadersampleinterlockext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragmentshadershadingrateinterlockext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragmentshadingratekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Functionfloatcontrolintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Functionpointersintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Functionvariantsintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Genericpointer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Geometry ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Geometrypointsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Geometryshaderpassthroughnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Geometrystreams ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Globalvariablefpgadecorationsaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Globalvariablehostaccessintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Grapharm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniform ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformarithmetic ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformballot ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformclustered ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformpartitionednv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformquad ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformrotatekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformshuffle ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformshufflerelative ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupnonuniformvote ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groups ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Groupuniformarithmetickhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Image1d ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagebasic ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagebuffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagecubearray ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagefootprintnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagegatherbiaslodamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagegatherextended ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagemipmap ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagemsarray ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagequery ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagereadwrite ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagereadwritelodamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagerect ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Indirectreferencesintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inputattachment ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inputattachmentarraydynamicindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inputattachmentarraynonuniformindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Int16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Int4cooperativematrixintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Int4typeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Int64 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Int64atomics ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Int64imageext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Int8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Integerfunctions2intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Interpolationfunction ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Iopipesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Kernel ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Kernelattributesintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Linkage ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Literalsampler ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Longcompositesintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Longvectorext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Loopfusealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maskedgatherscatterintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrix ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Memoryaccessaliasingintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Meshshadingext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Meshshadingnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Minlod ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Multiview ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Multiviewport ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Namedbarrier ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Optnoneext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Perviewattributesnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Physicalstoragebufferaddresses ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pipes ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pipestorage ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Quadcontrolkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rawaccesschainsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raycullmaskkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rayquerykhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rayquerypositionfetchkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rayqueryprovisionalkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingclusteraccelerationstructurenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingdisplacementmicromapnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracinglinearsweptspheresgeometrynv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingmotionblurnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingopacitymicromapext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingpositionfetchkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingprovisionalkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytracingspheresgeometrynv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytraversalprimitivecullingkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Registerlimitsintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Replicatedcompositesext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Roundingmoderte ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Roundingmodertz ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Roundtoinfinityintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Runtimealignedattributealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Runtimedescriptorarray ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampled1d ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampledbuffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampledcubearray ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampledimagearraydynamicindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampledimagearraynonuniformindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampledrect ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Samplemaskoverridecoveragenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Samplemaskpostdepthcoverage ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Samplerateshading ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shader ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shader64bitindexingext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderclockkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderenqueueamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderinvocationreorderext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderinvocationreordernv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderlayer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shadernonuniform ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shadersmbuiltinsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderstereoviewnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderviewportindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderviewportindexlayerext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderviewportmasknv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedzeroinfnanpreserve ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sparseresidency ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Specconditionalintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Splitbarrierintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stencilexportext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagebuffer16bitaccess ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagebuffer8bitaccess ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagebufferarraydynamicindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagebufferarraynonuniformindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storageimagearraydynamicindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storageimagearraynonuniformindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storageimageextendedformats ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storageimagemultisample ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storageimagereadwithoutformat ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storageimagewritewithoutformat ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storageinputoutput16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagepushconstant16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagepushconstant8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagetensorarraydynamicindexingarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagetensorarraynonuniformindexingarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagetexelbufferarraydynamicindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagetexelbufferarraynonuniformindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroup2dblockiointel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroup2dblocktransformintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroup2dblocktransposeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupavcmotionestimationchromaintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupavcmotionestimationintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupavcmotionestimationintraintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupballotkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupbufferblockiointel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupbufferprefetchintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupdispatch ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupimageblockiointel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupimagemediablockiointel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupmatrixmultiplyaccumulateintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupshuffleintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupvotekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tasksequencealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tensoraddressingnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tensorfloat32roundingintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tensorsarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Ternarybitwisefunctionintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tessellation ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tessellationpointsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Textureblockmatch2qcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Textureblockmatchqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Textureboxfilterqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Texturesampleweightedqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileimagecolorreadaccessext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileimagedepthreadaccessext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileimagestencilreadaccessext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileshadingqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Transformfeedback ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformandstoragebuffer16bitaccess ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformandstoragebuffer8bitaccess ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformbufferarraydynamicindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformbufferarraynonuniformindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformdecoration ->
                  (Requirements.Version.valid_versions ~required:(Some V1_6)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformtexelbufferarraydynamicindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformtexelbufferarraynonuniformindexing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unstructuredloopcontrolsintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Untypedpointerskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Untypedvariablelengtharrayintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Usmstorageclassesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Variablelengtharrayintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Variablepointers ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Variablepointersstoragebuffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vector16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vectoranyintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vectorcomputeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vulkanmemorymodel ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vulkanmemorymodeldevicescope ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workgroupmemoryexplicitlayout16bitaccesskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workgroupmemoryexplicitlayout8bitaccesskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workgroupmemoryexplicitlayoutkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Addresses -> [] |> Requirements.Extension.Set.of_list
              | Arbitraryprecisionfixedpointaltera ->
                  [Requirements.Extension.Spv_altera_arbitrary_precision_fixed_point;
                  Requirements.Extension.Spv_intel_arbitrary_precision_fixed_point]
                    |> Requirements.Extension.Set.of_list
              | Arbitraryprecisionfloatingpointaltera ->
                  [Requirements.Extension.Spv_altera_arbitrary_precision_floating_point;
                  Requirements.Extension.Spv_intel_arbitrary_precision_floating_point]
                    |> Requirements.Extension.Set.of_list
              | Arbitraryprecisionintegersaltera ->
                  [Requirements.Extension.Spv_altera_arbitrary_precision_integers;
                  Requirements.Extension.Spv_intel_arbitrary_precision_integers]
                    |> Requirements.Extension.Set.of_list
              | Arithmeticfenceext ->
                  [Requirements.Extension.Spv_ext_arithmetic_fence] |>
                    Requirements.Extension.Set.of_list
              | Asmintel ->
                  [Requirements.Extension.Spv_intel_inline_assembly] |>
                    Requirements.Extension.Set.of_list
              | Atomicfloat16addext ->
                  [Requirements.Extension.Spv_ext_shader_atomic_float16_add]
                    |> Requirements.Extension.Set.of_list
              | Atomicfloat16minmaxext ->
                  [Requirements.Extension.Spv_ext_shader_atomic_float_min_max]
                    |> Requirements.Extension.Set.of_list
              | Atomicfloat16vectornv ->
                  [Requirements.Extension.Spv_nv_shader_atomic_fp16_vector]
                    |> Requirements.Extension.Set.of_list
              | Atomicfloat32addext ->
                  [Requirements.Extension.Spv_ext_shader_atomic_float_add] |>
                    Requirements.Extension.Set.of_list
              | Atomicfloat32minmaxext ->
                  [Requirements.Extension.Spv_ext_shader_atomic_float_min_max]
                    |> Requirements.Extension.Set.of_list
              | Atomicfloat64addext ->
                  [Requirements.Extension.Spv_ext_shader_atomic_float_add] |>
                    Requirements.Extension.Set.of_list
              | Atomicfloat64minmaxext ->
                  [Requirements.Extension.Spv_ext_shader_atomic_float_min_max]
                    |> Requirements.Extension.Set.of_list
              | Atomicstorage -> [] |> Requirements.Extension.Set.of_list
              | Atomicstorageops ->
                  [Requirements.Extension.Spv_khr_shader_atomic_counter_ops]
                    |> Requirements.Extension.Set.of_list
              | Bfloat16conversionintel ->
                  [Requirements.Extension.Spv_intel_bfloat16_conversion] |>
                    Requirements.Extension.Set.of_list
              | Bfloat16cooperativematrixkhr ->
                  [Requirements.Extension.Spv_khr_bfloat16] |>
                    Requirements.Extension.Set.of_list
              | Bfloat16dotproductkhr ->
                  [Requirements.Extension.Spv_khr_bfloat16] |>
                    Requirements.Extension.Set.of_list
              | Bfloat16typekhr ->
                  [Requirements.Extension.Spv_khr_bfloat16] |>
                    Requirements.Extension.Set.of_list
              | Bindlessimagesintel ->
                  [Requirements.Extension.Spv_intel_bindless_images] |>
                    Requirements.Extension.Set.of_list
              | Bindlesstexturenv ->
                  [Requirements.Extension.Spv_nv_bindless_texture] |>
                    Requirements.Extension.Set.of_list
              | Bitinstructions ->
                  [Requirements.Extension.Spv_khr_bit_instructions] |>
                    Requirements.Extension.Set.of_list
              | Blockingpipesaltera ->
                  [Requirements.Extension.Spv_altera_blocking_pipes;
                  Requirements.Extension.Spv_intel_blocking_pipes] |>
                    Requirements.Extension.Set.of_list
              | Cachecontrolsintel ->
                  [Requirements.Extension.Spv_intel_cache_controls] |>
                    Requirements.Extension.Set.of_list
              | Clipdistance -> [] |> Requirements.Extension.Set.of_list
              | Computederivativegrouplinearkhr ->
                  [Requirements.Extension.Spv_nv_compute_shader_derivatives;
                  Requirements.Extension.Spv_khr_compute_shader_derivatives]
                    |> Requirements.Extension.Set.of_list
              | Computederivativegroupquadskhr ->
                  [Requirements.Extension.Spv_nv_compute_shader_derivatives;
                  Requirements.Extension.Spv_khr_compute_shader_derivatives]
                    |> Requirements.Extension.Set.of_list
              | Cooperativematrixblockloadsnv ->
                  [Requirements.Extension.Spv_nv_cooperative_matrix2] |>
                    Requirements.Extension.Set.of_list
              | Cooperativematrixconversionqcom ->
                  [Requirements.Extension.Spv_qcom_cooperative_matrix_conversion]
                    |> Requirements.Extension.Set.of_list
              | Cooperativematrixconversionsnv ->
                  [Requirements.Extension.Spv_nv_cooperative_matrix2] |>
                    Requirements.Extension.Set.of_list
              | Cooperativematrixkhr ->
                  [Requirements.Extension.Spv_khr_cooperative_matrix] |>
                    Requirements.Extension.Set.of_list
              | Cooperativematrixlayoutsarm ->
                  [Requirements.Extension.Spv_arm_cooperative_matrix_layouts]
                    |> Requirements.Extension.Set.of_list
              | Cooperativematrixnv ->
                  [Requirements.Extension.Spv_nv_cooperative_matrix] |>
                    Requirements.Extension.Set.of_list
              | Cooperativematrixperelementoperationsnv ->
                  [Requirements.Extension.Spv_nv_cooperative_matrix2] |>
                    Requirements.Extension.Set.of_list
              | Cooperativematrixreductionsnv ->
                  [Requirements.Extension.Spv_nv_cooperative_matrix2] |>
                    Requirements.Extension.Set.of_list
              | Cooperativematrixtensoraddressingnv ->
                  [Requirements.Extension.Spv_nv_cooperative_matrix2] |>
                    Requirements.Extension.Set.of_list
              | Cooperativevectornv ->
                  [Requirements.Extension.Spv_nv_cooperative_vector] |>
                    Requirements.Extension.Set.of_list
              | Cooperativevectortrainingnv ->
                  [Requirements.Extension.Spv_nv_cooperative_vector] |>
                    Requirements.Extension.Set.of_list
              | Corebuiltinsarm ->
                  [Requirements.Extension.Spv_arm_core_builtins] |>
                    Requirements.Extension.Set.of_list
              | Culldistance -> [] |> Requirements.Extension.Set.of_list
              | Debuginfomoduleintel ->
                  [Requirements.Extension.Spv_intel_debug_module] |>
                    Requirements.Extension.Set.of_list
              | Demotetohelperinvocation ->
                  [Requirements.Extension.Spv_ext_demote_to_helper_invocation]
                    |> Requirements.Extension.Set.of_list
              | Denormflushtozero ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Denormpreserve ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Derivativecontrol -> [] |> Requirements.Extension.Set.of_list
              | Deviceenqueue -> [] |> Requirements.Extension.Set.of_list
              | Devicegroup ->
                  [Requirements.Extension.Spv_khr_device_group] |>
                    Requirements.Extension.Set.of_list
              | Displacementmicromapnv ->
                  [Requirements.Extension.Spv_nv_displacement_micromap] |>
                    Requirements.Extension.Set.of_list
              | Dotproduct ->
                  [Requirements.Extension.Spv_khr_integer_dot_product] |>
                    Requirements.Extension.Set.of_list
              | Dotproductinput4x8bit ->
                  [Requirements.Extension.Spv_khr_integer_dot_product] |>
                    Requirements.Extension.Set.of_list
              | Dotproductinput4x8bitpacked ->
                  [Requirements.Extension.Spv_khr_integer_dot_product] |>
                    Requirements.Extension.Set.of_list
              | Dotproductinputall ->
                  [Requirements.Extension.Spv_khr_integer_dot_product] |>
                    Requirements.Extension.Set.of_list
              | Drawparameters ->
                  [Requirements.Extension.Spv_khr_shader_draw_parameters] |>
                    Requirements.Extension.Set.of_list
              | Expectassumekhr ->
                  [Requirements.Extension.Spv_khr_expect_assume] |>
                    Requirements.Extension.Set.of_list
              | Float16 -> [] |> Requirements.Extension.Set.of_list
              | Float16buffer -> [] |> Requirements.Extension.Set.of_list
              | Float16imageamd ->
                  [Requirements.Extension.Spv_amd_gpu_shader_half_float_fetch]
                    |> Requirements.Extension.Set.of_list
              | Float64 -> [] |> Requirements.Extension.Set.of_list
              | Float8cooperativematrixext ->
                  [Requirements.Extension.Spv_ext_float8] |>
                    Requirements.Extension.Set.of_list
              | Float8ext ->
                  [Requirements.Extension.Spv_ext_float8] |>
                    Requirements.Extension.Set.of_list
              | Floatcontrols2 ->
                  [Requirements.Extension.Spv_khr_float_controls2] |>
                    Requirements.Extension.Set.of_list
              | Floatingpointmodeintel ->
                  [Requirements.Extension.Spv_intel_float_controls2] |>
                    Requirements.Extension.Set.of_list
              | Fmakhr ->
                  [Requirements.Extension.Spv_khr_fma] |>
                    Requirements.Extension.Set.of_list
              | Fpfastmathmodeintel ->
                  [Requirements.Extension.Spv_intel_fp_fast_math_mode] |>
                    Requirements.Extension.Set.of_list
              | Fpgaargumentinterfacesaltera ->
                  [Requirements.Extension.Spv_altera_fpga_argument_interfaces;
                  Requirements.Extension.Spv_intel_fpga_argument_interfaces]
                    |> Requirements.Extension.Set.of_list
              | Fpgabufferlocationaltera ->
                  [Requirements.Extension.Spv_altera_fpga_buffer_location;
                  Requirements.Extension.Spv_intel_fpga_buffer_location] |>
                    Requirements.Extension.Set.of_list
              | Fpgaclusterattributesaltera ->
                  [Requirements.Extension.Spv_altera_fpga_cluster_attributes;
                  Requirements.Extension.Spv_intel_fpga_cluster_attributes]
                    |> Requirements.Extension.Set.of_list
              | Fpgaclusterattributesv2altera ->
                  [Requirements.Extension.Spv_altera_fpga_cluster_attributes;
                  Requirements.Extension.Spv_intel_fpga_cluster_attributes]
                    |> Requirements.Extension.Set.of_list
              | Fpgadspcontrolaltera ->
                  [Requirements.Extension.Spv_altera_fpga_dsp_control;
                  Requirements.Extension.Spv_intel_fpga_dsp_control] |>
                    Requirements.Extension.Set.of_list
              | Fpgainvocationpipeliningattributesaltera ->
                  [Requirements.Extension.Spv_altera_fpga_invocation_pipelining_attributes;
                  Requirements.Extension.Spv_intel_fpga_invocation_pipelining_attributes]
                    |> Requirements.Extension.Set.of_list
              | Fpgakernelattributesintel ->
                  [Requirements.Extension.Spv_intel_kernel_attributes] |>
                    Requirements.Extension.Set.of_list
              | Fpgakernelattributesv2intel ->
                  [Requirements.Extension.Spv_intel_kernel_attributes] |>
                    Requirements.Extension.Set.of_list
              | Fpgalatencycontrolaltera ->
                  [Requirements.Extension.Spv_altera_fpga_latency_control;
                  Requirements.Extension.Spv_intel_fpga_latency_control] |>
                    Requirements.Extension.Set.of_list
              | Fpgaloopcontrolsaltera ->
                  [Requirements.Extension.Spv_altera_fpga_loop_controls;
                  Requirements.Extension.Spv_intel_fpga_loop_controls] |>
                    Requirements.Extension.Set.of_list
              | Fpgamemoryaccessesaltera ->
                  [Requirements.Extension.Spv_altera_fpga_memory_accesses;
                  Requirements.Extension.Spv_intel_fpga_memory_accesses] |>
                    Requirements.Extension.Set.of_list
              | Fpgamemoryattributesaltera ->
                  [Requirements.Extension.Spv_altera_fpga_memory_attributes;
                  Requirements.Extension.Spv_intel_fpga_memory_attributes] |>
                    Requirements.Extension.Set.of_list
              | Fpgaregaltera ->
                  [Requirements.Extension.Spv_altera_fpga_reg;
                  Requirements.Extension.Spv_intel_fpga_reg] |>
                    Requirements.Extension.Set.of_list
              | Fpmaxerrorintel ->
                  [Requirements.Extension.Spv_intel_fp_max_error] |>
                    Requirements.Extension.Set.of_list
              | Fragmentbarycentrickhr ->
                  [Requirements.Extension.Spv_nv_fragment_shader_barycentric;
                  Requirements.Extension.Spv_khr_fragment_shader_barycentric]
                    |> Requirements.Extension.Set.of_list
              | Fragmentdensityext ->
                  [Requirements.Extension.Spv_ext_fragment_invocation_density;
                  Requirements.Extension.Spv_nv_shading_rate] |>
                    Requirements.Extension.Set.of_list
              | Fragmentfullycoveredext ->
                  [Requirements.Extension.Spv_ext_fragment_fully_covered] |>
                    Requirements.Extension.Set.of_list
              | Fragmentmaskamd ->
                  [Requirements.Extension.Spv_amd_shader_fragment_mask] |>
                    Requirements.Extension.Set.of_list
              | Fragmentshaderpixelinterlockext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Fragmentshadersampleinterlockext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Fragmentshadershadingrateinterlockext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Fragmentshadingratekhr ->
                  [Requirements.Extension.Spv_khr_fragment_shading_rate] |>
                    Requirements.Extension.Set.of_list
              | Functionfloatcontrolintel ->
                  [Requirements.Extension.Spv_intel_float_controls2] |>
                    Requirements.Extension.Set.of_list
              | Functionpointersintel ->
                  [Requirements.Extension.Spv_intel_function_pointers] |>
                    Requirements.Extension.Set.of_list
              | Functionvariantsintel ->
                  [Requirements.Extension.Spv_intel_function_variants] |>
                    Requirements.Extension.Set.of_list
              | Genericpointer -> [] |> Requirements.Extension.Set.of_list
              | Geometry -> [] |> Requirements.Extension.Set.of_list
              | Geometrypointsize -> [] |> Requirements.Extension.Set.of_list
              | Geometryshaderpassthroughnv ->
                  [Requirements.Extension.Spv_nv_geometry_shader_passthrough]
                    |> Requirements.Extension.Set.of_list
              | Geometrystreams -> [] |> Requirements.Extension.Set.of_list
              | Globalvariablefpgadecorationsaltera ->
                  [Requirements.Extension.Spv_altera_global_variable_fpga_decorations;
                  Requirements.Extension.Spv_intel_global_variable_fpga_decorations]
                    |> Requirements.Extension.Set.of_list
              | Globalvariablehostaccessintel ->
                  [Requirements.Extension.Spv_intel_global_variable_host_access]
                    |> Requirements.Extension.Set.of_list
              | Grapharm ->
                  [Requirements.Extension.Spv_arm_graph] |>
                    Requirements.Extension.Set.of_list
              | Groupnonuniform -> [] |> Requirements.Extension.Set.of_list
              | Groupnonuniformarithmetic ->
                  [] |> Requirements.Extension.Set.of_list
              | Groupnonuniformballot ->
                  [] |> Requirements.Extension.Set.of_list
              | Groupnonuniformclustered ->
                  [] |> Requirements.Extension.Set.of_list
              | Groupnonuniformpartitionednv ->
                  [Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                    |> Requirements.Extension.Set.of_list
              | Groupnonuniformquad ->
                  [] |> Requirements.Extension.Set.of_list
              | Groupnonuniformrotatekhr ->
                  [Requirements.Extension.Spv_khr_subgroup_rotate] |>
                    Requirements.Extension.Set.of_list
              | Groupnonuniformshuffle ->
                  [] |> Requirements.Extension.Set.of_list
              | Groupnonuniformshufflerelative ->
                  [] |> Requirements.Extension.Set.of_list
              | Groupnonuniformvote ->
                  [] |> Requirements.Extension.Set.of_list
              | Groups ->
                  [Requirements.Extension.Spv_amd_shader_ballot] |>
                    Requirements.Extension.Set.of_list
              | Groupuniformarithmetickhr ->
                  [Requirements.Extension.Spv_khr_uniform_group_instructions]
                    |> Requirements.Extension.Set.of_list
              | Image1d -> [] |> Requirements.Extension.Set.of_list
              | Imagebasic -> [] |> Requirements.Extension.Set.of_list
              | Imagebuffer -> [] |> Requirements.Extension.Set.of_list
              | Imagecubearray -> [] |> Requirements.Extension.Set.of_list
              | Imagefootprintnv ->
                  [Requirements.Extension.Spv_nv_shader_image_footprint] |>
                    Requirements.Extension.Set.of_list
              | Imagegatherbiaslodamd ->
                  [Requirements.Extension.Spv_amd_texture_gather_bias_lod] |>
                    Requirements.Extension.Set.of_list
              | Imagegatherextended ->
                  [] |> Requirements.Extension.Set.of_list
              | Imagemipmap -> [] |> Requirements.Extension.Set.of_list
              | Imagemsarray -> [] |> Requirements.Extension.Set.of_list
              | Imagequery -> [] |> Requirements.Extension.Set.of_list
              | Imagereadwrite -> [] |> Requirements.Extension.Set.of_list
              | Imagereadwritelodamd ->
                  [Requirements.Extension.Spv_amd_shader_image_load_store_lod]
                    |> Requirements.Extension.Set.of_list
              | Imagerect -> [] |> Requirements.Extension.Set.of_list
              | Indirectreferencesintel ->
                  [Requirements.Extension.Spv_intel_function_pointers] |>
                    Requirements.Extension.Set.of_list
              | Inputattachment -> [] |> Requirements.Extension.Set.of_list
              | Inputattachmentarraydynamicindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Inputattachmentarraynonuniformindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Int16 -> [] |> Requirements.Extension.Set.of_list
              | Int4cooperativematrixintel ->
                  [Requirements.Extension.Spv_intel_int4] |>
                    Requirements.Extension.Set.of_list
              | Int4typeintel ->
                  [Requirements.Extension.Spv_intel_int4] |>
                    Requirements.Extension.Set.of_list
              | Int64 -> [] |> Requirements.Extension.Set.of_list
              | Int64atomics -> [] |> Requirements.Extension.Set.of_list
              | Int64imageext ->
                  [Requirements.Extension.Spv_ext_shader_image_int64] |>
                    Requirements.Extension.Set.of_list
              | Int8 -> [] |> Requirements.Extension.Set.of_list
              | Integerfunctions2intel ->
                  [Requirements.Extension.Spv_intel_shader_integer_functions2]
                    |> Requirements.Extension.Set.of_list
              | Interpolationfunction ->
                  [] |> Requirements.Extension.Set.of_list
              | Iopipesaltera ->
                  [Requirements.Extension.Spv_altera_io_pipes;
                  Requirements.Extension.Spv_intel_io_pipes] |>
                    Requirements.Extension.Set.of_list
              | Kernel -> [] |> Requirements.Extension.Set.of_list
              | Kernelattributesintel ->
                  [Requirements.Extension.Spv_intel_kernel_attributes] |>
                    Requirements.Extension.Set.of_list
              | Linkage -> [] |> Requirements.Extension.Set.of_list
              | Literalsampler -> [] |> Requirements.Extension.Set.of_list
              | Longcompositesintel ->
                  [Requirements.Extension.Spv_intel_long_composites] |>
                    Requirements.Extension.Set.of_list
              | Longvectorext ->
                  [Requirements.Extension.Spv_ext_long_vector] |>
                    Requirements.Extension.Set.of_list
              | Loopfusealtera ->
                  [Requirements.Extension.Spv_altera_loop_fuse;
                  Requirements.Extension.Spv_intel_loop_fuse] |>
                    Requirements.Extension.Set.of_list
              | Maskedgatherscatterintel ->
                  [Requirements.Extension.Spv_intel_masked_gather_scatter] |>
                    Requirements.Extension.Set.of_list
              | Matrix -> [] |> Requirements.Extension.Set.of_list
              | Memoryaccessaliasingintel ->
                  [Requirements.Extension.Spv_intel_memory_access_aliasing]
                    |> Requirements.Extension.Set.of_list
              | Meshshadingext ->
                  [Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Meshshadingnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Minlod -> [] |> Requirements.Extension.Set.of_list
              | Multiview ->
                  [Requirements.Extension.Spv_khr_multiview] |>
                    Requirements.Extension.Set.of_list
              | Multiviewport -> [] |> Requirements.Extension.Set.of_list
              | Namedbarrier -> [] |> Requirements.Extension.Set.of_list
              | Optnoneext ->
                  [Requirements.Extension.Spv_ext_optnone;
                  Requirements.Extension.Spv_intel_optnone] |>
                    Requirements.Extension.Set.of_list
              | Perviewattributesnv ->
                  [Requirements.Extension.Spv_nvx_multiview_per_view_attributes]
                    |> Requirements.Extension.Set.of_list
              | Physicalstoragebufferaddresses ->
                  [Requirements.Extension.Spv_ext_physical_storage_buffer;
                  Requirements.Extension.Spv_khr_physical_storage_buffer] |>
                    Requirements.Extension.Set.of_list
              | Pipes -> [] |> Requirements.Extension.Set.of_list
              | Pipestorage -> [] |> Requirements.Extension.Set.of_list
              | Quadcontrolkhr ->
                  [Requirements.Extension.Spv_khr_quad_control] |>
                    Requirements.Extension.Set.of_list
              | Rawaccesschainsnv ->
                  [Requirements.Extension.Spv_nv_raw_access_chains] |>
                    Requirements.Extension.Set.of_list
              | Raycullmaskkhr ->
                  [Requirements.Extension.Spv_khr_ray_cull_mask] |>
                    Requirements.Extension.Set.of_list
              | Rayquerykhr ->
                  [Requirements.Extension.Spv_khr_ray_query] |>
                    Requirements.Extension.Set.of_list
              | Rayquerypositionfetchkhr ->
                  [Requirements.Extension.Spv_khr_ray_tracing_position_fetch]
                    |> Requirements.Extension.Set.of_list
              | Rayqueryprovisionalkhr ->
                  [Requirements.Extension.Spv_khr_ray_query] |>
                    Requirements.Extension.Set.of_list
              | Raytracingclusteraccelerationstructurenv ->
                  [Requirements.Extension.Spv_nv_cluster_acceleration_structure]
                    |> Requirements.Extension.Set.of_list
              | Raytracingdisplacementmicromapnv ->
                  [Requirements.Extension.Spv_nv_displacement_micromap] |>
                    Requirements.Extension.Set.of_list
              | Raytracingkhr ->
                  [Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Raytracinglinearsweptspheresgeometrynv ->
                  [Requirements.Extension.Spv_nv_linear_swept_spheres] |>
                    Requirements.Extension.Set.of_list
              | Raytracingmotionblurnv ->
                  [Requirements.Extension.Spv_nv_ray_tracing_motion_blur] |>
                    Requirements.Extension.Set.of_list
              | Raytracingnv ->
                  [Requirements.Extension.Spv_nv_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Raytracingopacitymicromapext ->
                  [Requirements.Extension.Spv_ext_opacity_micromap] |>
                    Requirements.Extension.Set.of_list
              | Raytracingpositionfetchkhr ->
                  [Requirements.Extension.Spv_khr_ray_tracing_position_fetch]
                    |> Requirements.Extension.Set.of_list
              | Raytracingprovisionalkhr ->
                  [Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Raytracingspheresgeometrynv ->
                  [Requirements.Extension.Spv_nv_linear_swept_spheres] |>
                    Requirements.Extension.Set.of_list
              | Raytraversalprimitivecullingkhr ->
                  [Requirements.Extension.Spv_khr_ray_query;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Registerlimitsintel ->
                  [Requirements.Extension.Spv_intel_maximum_registers] |>
                    Requirements.Extension.Set.of_list
              | Replicatedcompositesext ->
                  [Requirements.Extension.Spv_ext_replicated_composites] |>
                    Requirements.Extension.Set.of_list
              | Roundingmoderte ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Roundingmodertz ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Roundtoinfinityintel ->
                  [Requirements.Extension.Spv_intel_float_controls2] |>
                    Requirements.Extension.Set.of_list
              | Runtimealignedattributealtera ->
                  [Requirements.Extension.Spv_altera_runtime_aligned;
                  Requirements.Extension.Spv_intel_runtime_aligned] |>
                    Requirements.Extension.Set.of_list
              | Runtimedescriptorarray ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Sampled1d -> [] |> Requirements.Extension.Set.of_list
              | Sampledbuffer -> [] |> Requirements.Extension.Set.of_list
              | Sampledcubearray -> [] |> Requirements.Extension.Set.of_list
              | Sampledimagearraydynamicindexing ->
                  [] |> Requirements.Extension.Set.of_list
              | Sampledimagearraynonuniformindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Sampledrect -> [] |> Requirements.Extension.Set.of_list
              | Samplemaskoverridecoveragenv ->
                  [Requirements.Extension.Spv_nv_sample_mask_override_coverage]
                    |> Requirements.Extension.Set.of_list
              | Samplemaskpostdepthcoverage ->
                  [Requirements.Extension.Spv_khr_post_depth_coverage] |>
                    Requirements.Extension.Set.of_list
              | Samplerateshading -> [] |> Requirements.Extension.Set.of_list
              | Shader -> [] |> Requirements.Extension.Set.of_list
              | Shader64bitindexingext ->
                  [Requirements.Extension.Spv_ext_shader_64bit_indexing] |>
                    Requirements.Extension.Set.of_list
              | Shaderclockkhr ->
                  [Requirements.Extension.Spv_khr_shader_clock] |>
                    Requirements.Extension.Set.of_list
              | Shaderenqueueamdx ->
                  [Requirements.Extension.Spv_amdx_shader_enqueue] |>
                    Requirements.Extension.Set.of_list
              | Shaderinvocationreorderext ->
                  [Requirements.Extension.Spv_ext_shader_invocation_reorder]
                    |> Requirements.Extension.Set.of_list
              | Shaderinvocationreordernv ->
                  [Requirements.Extension.Spv_nv_shader_invocation_reorder]
                    |> Requirements.Extension.Set.of_list
              | Shaderlayer -> [] |> Requirements.Extension.Set.of_list
              | Shadernonuniform ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Shadersmbuiltinsnv ->
                  [Requirements.Extension.Spv_nv_shader_sm_builtins] |>
                    Requirements.Extension.Set.of_list
              | Shaderstereoviewnv ->
                  [Requirements.Extension.Spv_nv_stereo_view_rendering] |>
                    Requirements.Extension.Set.of_list
              | Shaderviewportindex ->
                  [] |> Requirements.Extension.Set.of_list
              | Shaderviewportindexlayerext ->
                  [Requirements.Extension.Spv_ext_shader_viewport_index_layer;
                  Requirements.Extension.Spv_nv_viewport_array2] |>
                    Requirements.Extension.Set.of_list
              | Shaderviewportmasknv ->
                  [Requirements.Extension.Spv_nv_viewport_array2] |>
                    Requirements.Extension.Set.of_list
              | Signedzeroinfnanpreserve ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Sparseresidency -> [] |> Requirements.Extension.Set.of_list
              | Specconditionalintel ->
                  [Requirements.Extension.Spv_intel_function_variants] |>
                    Requirements.Extension.Set.of_list
              | Splitbarrierintel ->
                  [Requirements.Extension.Spv_intel_split_barrier] |>
                    Requirements.Extension.Set.of_list
              | Stencilexportext ->
                  [Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Storagebuffer16bitaccess ->
                  [Requirements.Extension.Spv_khr_16bit_storage] |>
                    Requirements.Extension.Set.of_list
              | Storagebuffer8bitaccess ->
                  [Requirements.Extension.Spv_khr_8bit_storage] |>
                    Requirements.Extension.Set.of_list
              | Storagebufferarraydynamicindexing ->
                  [] |> Requirements.Extension.Set.of_list
              | Storagebufferarraynonuniformindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Storageimagearraydynamicindexing ->
                  [] |> Requirements.Extension.Set.of_list
              | Storageimagearraynonuniformindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Storageimageextendedformats ->
                  [] |> Requirements.Extension.Set.of_list
              | Storageimagemultisample ->
                  [] |> Requirements.Extension.Set.of_list
              | Storageimagereadwithoutformat ->
                  [] |> Requirements.Extension.Set.of_list
              | Storageimagewritewithoutformat ->
                  [] |> Requirements.Extension.Set.of_list
              | Storageinputoutput16 ->
                  [Requirements.Extension.Spv_khr_16bit_storage] |>
                    Requirements.Extension.Set.of_list
              | Storagepushconstant16 ->
                  [Requirements.Extension.Spv_khr_16bit_storage] |>
                    Requirements.Extension.Set.of_list
              | Storagepushconstant8 ->
                  [Requirements.Extension.Spv_khr_8bit_storage] |>
                    Requirements.Extension.Set.of_list
              | Storagetensorarraydynamicindexingarm ->
                  [Requirements.Extension.Spv_arm_tensors] |>
                    Requirements.Extension.Set.of_list
              | Storagetensorarraynonuniformindexingarm ->
                  [Requirements.Extension.Spv_arm_tensors] |>
                    Requirements.Extension.Set.of_list
              | Storagetexelbufferarraydynamicindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Storagetexelbufferarraynonuniformindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Subgroup2dblockiointel ->
                  [Requirements.Extension.Spv_intel_2d_block_io] |>
                    Requirements.Extension.Set.of_list
              | Subgroup2dblocktransformintel ->
                  [Requirements.Extension.Spv_intel_2d_block_io] |>
                    Requirements.Extension.Set.of_list
              | Subgroup2dblocktransposeintel ->
                  [Requirements.Extension.Spv_intel_2d_block_io] |>
                    Requirements.Extension.Set.of_list
              | Subgroupavcmotionestimationchromaintel ->
                  [Requirements.Extension.Spv_intel_device_side_avc_motion_estimation]
                    |> Requirements.Extension.Set.of_list
              | Subgroupavcmotionestimationintel ->
                  [Requirements.Extension.Spv_intel_device_side_avc_motion_estimation]
                    |> Requirements.Extension.Set.of_list
              | Subgroupavcmotionestimationintraintel ->
                  [Requirements.Extension.Spv_intel_device_side_avc_motion_estimation]
                    |> Requirements.Extension.Set.of_list
              | Subgroupballotkhr ->
                  [Requirements.Extension.Spv_khr_shader_ballot] |>
                    Requirements.Extension.Set.of_list
              | Subgroupbufferblockiointel ->
                  [Requirements.Extension.Spv_intel_subgroups] |>
                    Requirements.Extension.Set.of_list
              | Subgroupbufferprefetchintel ->
                  [Requirements.Extension.Spv_intel_subgroup_buffer_prefetch]
                    |> Requirements.Extension.Set.of_list
              | Subgroupdispatch -> [] |> Requirements.Extension.Set.of_list
              | Subgroupimageblockiointel ->
                  [Requirements.Extension.Spv_intel_subgroups] |>
                    Requirements.Extension.Set.of_list
              | Subgroupimagemediablockiointel ->
                  [Requirements.Extension.Spv_intel_media_block_io] |>
                    Requirements.Extension.Set.of_list
              | Subgroupmatrixmultiplyaccumulateintel ->
                  [Requirements.Extension.Spv_intel_subgroup_matrix_multiply_accumulate]
                    |> Requirements.Extension.Set.of_list
              | Subgroupshuffleintel ->
                  [Requirements.Extension.Spv_intel_subgroups] |>
                    Requirements.Extension.Set.of_list
              | Subgroupvotekhr ->
                  [Requirements.Extension.Spv_khr_subgroup_vote] |>
                    Requirements.Extension.Set.of_list
              | Tasksequencealtera ->
                  [Requirements.Extension.Spv_altera_task_sequence;
                  Requirements.Extension.Spv_intel_task_sequence] |>
                    Requirements.Extension.Set.of_list
              | Tensoraddressingnv ->
                  [Requirements.Extension.Spv_nv_tensor_addressing] |>
                    Requirements.Extension.Set.of_list
              | Tensorfloat32roundingintel ->
                  [Requirements.Extension.Spv_intel_tensor_float32_conversion]
                    |> Requirements.Extension.Set.of_list
              | Tensorsarm ->
                  [Requirements.Extension.Spv_arm_tensors] |>
                    Requirements.Extension.Set.of_list
              | Ternarybitwisefunctionintel ->
                  [Requirements.Extension.Spv_intel_ternary_bitwise_function]
                    |> Requirements.Extension.Set.of_list
              | Tessellation -> [] |> Requirements.Extension.Set.of_list
              | Tessellationpointsize ->
                  [] |> Requirements.Extension.Set.of_list
              | Textureblockmatch2qcom ->
                  [Requirements.Extension.Spv_qcom_image_processing2] |>
                    Requirements.Extension.Set.of_list
              | Textureblockmatchqcom ->
                  [Requirements.Extension.Spv_qcom_image_processing] |>
                    Requirements.Extension.Set.of_list
              | Textureboxfilterqcom ->
                  [Requirements.Extension.Spv_qcom_image_processing] |>
                    Requirements.Extension.Set.of_list
              | Texturesampleweightedqcom ->
                  [Requirements.Extension.Spv_qcom_image_processing] |>
                    Requirements.Extension.Set.of_list
              | Tileimagecolorreadaccessext ->
                  [Requirements.Extension.Spv_ext_shader_tile_image] |>
                    Requirements.Extension.Set.of_list
              | Tileimagedepthreadaccessext ->
                  [Requirements.Extension.Spv_ext_shader_tile_image] |>
                    Requirements.Extension.Set.of_list
              | Tileimagestencilreadaccessext ->
                  [Requirements.Extension.Spv_ext_shader_tile_image] |>
                    Requirements.Extension.Set.of_list
              | Tileshadingqcom ->
                  [Requirements.Extension.Spv_qcom_tile_shading] |>
                    Requirements.Extension.Set.of_list
              | Transformfeedback -> [] |> Requirements.Extension.Set.of_list
              | Uniformandstoragebuffer16bitaccess ->
                  [Requirements.Extension.Spv_khr_16bit_storage] |>
                    Requirements.Extension.Set.of_list
              | Uniformandstoragebuffer8bitaccess ->
                  [Requirements.Extension.Spv_khr_8bit_storage] |>
                    Requirements.Extension.Set.of_list
              | Uniformbufferarraydynamicindexing ->
                  [] |> Requirements.Extension.Set.of_list
              | Uniformbufferarraynonuniformindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Uniformdecoration -> [] |> Requirements.Extension.Set.of_list
              | Uniformtexelbufferarraydynamicindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Uniformtexelbufferarraynonuniformindexing ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Unstructuredloopcontrolsintel ->
                  [Requirements.Extension.Spv_intel_unstructured_loop_controls]
                    |> Requirements.Extension.Set.of_list
              | Untypedpointerskhr ->
                  [Requirements.Extension.Spv_khr_untyped_pointers] |>
                    Requirements.Extension.Set.of_list
              | Untypedvariablelengtharrayintel ->
                  [Requirements.Extension.Spv_intel_variable_length_array] |>
                    Requirements.Extension.Set.of_list
              | Usmstorageclassesaltera ->
                  [Requirements.Extension.Spv_altera_usm_storage_classes;
                  Requirements.Extension.Spv_intel_usm_storage_classes] |>
                    Requirements.Extension.Set.of_list
              | Variablelengtharrayintel ->
                  [Requirements.Extension.Spv_intel_variable_length_array] |>
                    Requirements.Extension.Set.of_list
              | Variablepointers ->
                  [Requirements.Extension.Spv_khr_variable_pointers] |>
                    Requirements.Extension.Set.of_list
              | Variablepointersstoragebuffer ->
                  [Requirements.Extension.Spv_khr_variable_pointers] |>
                    Requirements.Extension.Set.of_list
              | Vector16 -> [] |> Requirements.Extension.Set.of_list
              | Vectoranyintel ->
                  [Requirements.Extension.Spv_intel_vector_compute] |>
                    Requirements.Extension.Set.of_list
              | Vectorcomputeintel ->
                  [Requirements.Extension.Spv_intel_vector_compute] |>
                    Requirements.Extension.Set.of_list
              | Vulkanmemorymodel ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Vulkanmemorymodeldevicescope ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Workgroupmemoryexplicitlayout16bitaccesskhr ->
                  [Requirements.Extension.Spv_khr_workgroup_memory_explicit_layout]
                    |> Requirements.Extension.Set.of_list
              | Workgroupmemoryexplicitlayout8bitaccesskhr ->
                  [Requirements.Extension.Spv_khr_workgroup_memory_explicit_layout]
                    |> Requirements.Extension.Set.of_list
              | Workgroupmemoryexplicitlayoutkhr ->
                  [Requirements.Extension.Spv_khr_workgroup_memory_explicit_layout]
                    |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Addresses -> [] |> Set.of_list
              | Arbitraryprecisionfixedpointaltera -> [] |> Set.of_list
              | Arbitraryprecisionfloatingpointaltera -> [] |> Set.of_list
              | Arbitraryprecisionintegersaltera -> [] |> Set.of_list
              | Arithmeticfenceext -> [] |> Set.of_list
              | Asmintel -> [] |> Set.of_list
              | Atomicfloat16addext -> [] |> Set.of_list
              | Atomicfloat16minmaxext -> [] |> Set.of_list
              | Atomicfloat16vectornv -> [] |> Set.of_list
              | Atomicfloat32addext -> [] |> Set.of_list
              | Atomicfloat32minmaxext -> [] |> Set.of_list
              | Atomicfloat64addext -> [] |> Set.of_list
              | Atomicfloat64minmaxext -> [] |> Set.of_list
              | Atomicstorage -> [Shader] |> Set.of_list
              | Atomicstorageops -> [Atomicstorage] |> Set.of_list
              | Bfloat16conversionintel -> [] |> Set.of_list
              | Bfloat16cooperativematrixkhr ->
                  [Bfloat16typekhr; Cooperativematrixkhr] |> Set.of_list
              | Bfloat16dotproductkhr -> [Bfloat16typekhr] |> Set.of_list
              | Bfloat16typekhr -> [] |> Set.of_list
              | Bindlessimagesintel -> [] |> Set.of_list
              | Bindlesstexturenv -> [] |> Set.of_list
              | Bitinstructions -> [] |> Set.of_list
              | Blockingpipesaltera -> [] |> Set.of_list
              | Cachecontrolsintel -> [] |> Set.of_list
              | Clipdistance -> [Shader] |> Set.of_list
              | Computederivativegrouplinearkhr -> [Shader] |> Set.of_list
              | Computederivativegroupquadskhr -> [Shader] |> Set.of_list
              | Cooperativematrixblockloadsnv -> [] |> Set.of_list
              | Cooperativematrixconversionqcom ->
                  [Cooperativematrixkhr] |> Set.of_list
              | Cooperativematrixconversionsnv -> [] |> Set.of_list
              | Cooperativematrixkhr -> [] |> Set.of_list
              | Cooperativematrixlayoutsarm -> [] |> Set.of_list
              | Cooperativematrixnv -> [Shader] |> Set.of_list
              | Cooperativematrixperelementoperationsnv -> [] |> Set.of_list
              | Cooperativematrixreductionsnv -> [] |> Set.of_list
              | Cooperativematrixtensoraddressingnv -> [] |> Set.of_list
              | Cooperativevectornv -> [] |> Set.of_list
              | Cooperativevectortrainingnv -> [] |> Set.of_list
              | Corebuiltinsarm -> [] |> Set.of_list
              | Culldistance -> [Shader] |> Set.of_list
              | Debuginfomoduleintel -> [] |> Set.of_list
              | Demotetohelperinvocation -> [Shader] |> Set.of_list
              | Denormflushtozero -> [] |> Set.of_list
              | Denormpreserve -> [] |> Set.of_list
              | Derivativecontrol -> [Shader] |> Set.of_list
              | Deviceenqueue -> [Kernel] |> Set.of_list
              | Devicegroup -> [] |> Set.of_list
              | Displacementmicromapnv -> [Shader] |> Set.of_list
              | Dotproduct -> [] |> Set.of_list
              | Dotproductinput4x8bit -> [Int8] |> Set.of_list
              | Dotproductinput4x8bitpacked -> [] |> Set.of_list
              | Dotproductinputall -> [] |> Set.of_list
              | Drawparameters -> [Shader] |> Set.of_list
              | Expectassumekhr -> [] |> Set.of_list
              | Float16 -> [] |> Set.of_list
              | Float16buffer -> [Kernel] |> Set.of_list
              | Float16imageamd -> [Shader] |> Set.of_list
              | Float64 -> [] |> Set.of_list
              | Float8cooperativematrixext ->
                  [Float8ext; Cooperativematrixkhr] |> Set.of_list
              | Float8ext -> [] |> Set.of_list
              | Floatcontrols2 -> [] |> Set.of_list
              | Floatingpointmodeintel -> [] |> Set.of_list
              | Fmakhr -> [] |> Set.of_list
              | Fpfastmathmodeintel -> [Kernel] |> Set.of_list
              | Fpgaargumentinterfacesaltera -> [] |> Set.of_list
              | Fpgabufferlocationaltera -> [] |> Set.of_list
              | Fpgaclusterattributesaltera -> [] |> Set.of_list
              | Fpgaclusterattributesv2altera ->
                  [Fpgaclusterattributesaltera] |> Set.of_list
              | Fpgadspcontrolaltera -> [] |> Set.of_list
              | Fpgainvocationpipeliningattributesaltera -> [] |> Set.of_list
              | Fpgakernelattributesintel -> [] |> Set.of_list
              | Fpgakernelattributesv2intel ->
                  [Fpgakernelattributesintel] |> Set.of_list
              | Fpgalatencycontrolaltera -> [] |> Set.of_list
              | Fpgaloopcontrolsaltera -> [] |> Set.of_list
              | Fpgamemoryaccessesaltera -> [] |> Set.of_list
              | Fpgamemoryattributesaltera -> [] |> Set.of_list
              | Fpgaregaltera -> [] |> Set.of_list
              | Fpmaxerrorintel -> [] |> Set.of_list
              | Fragmentbarycentrickhr -> [] |> Set.of_list
              | Fragmentdensityext -> [Shader] |> Set.of_list
              | Fragmentfullycoveredext -> [Shader] |> Set.of_list
              | Fragmentmaskamd -> [Shader] |> Set.of_list
              | Fragmentshaderpixelinterlockext -> [Shader] |> Set.of_list
              | Fragmentshadersampleinterlockext -> [Shader] |> Set.of_list
              | Fragmentshadershadingrateinterlockext ->
                  [Shader] |> Set.of_list
              | Fragmentshadingratekhr -> [Shader] |> Set.of_list
              | Functionfloatcontrolintel -> [] |> Set.of_list
              | Functionpointersintel -> [] |> Set.of_list
              | Functionvariantsintel ->
                  [Specconditionalintel] |> Set.of_list
              | Genericpointer -> [Addresses] |> Set.of_list
              | Geometry -> [Shader] |> Set.of_list
              | Geometrypointsize -> [Geometry] |> Set.of_list
              | Geometryshaderpassthroughnv -> [Geometry] |> Set.of_list
              | Geometrystreams -> [Geometry] |> Set.of_list
              | Globalvariablefpgadecorationsaltera -> [] |> Set.of_list
              | Globalvariablehostaccessintel -> [] |> Set.of_list
              | Grapharm -> [] |> Set.of_list
              | Groupnonuniform -> [] |> Set.of_list
              | Groupnonuniformarithmetic -> [Groupnonuniform] |> Set.of_list
              | Groupnonuniformballot -> [Groupnonuniform] |> Set.of_list
              | Groupnonuniformclustered -> [Groupnonuniform] |> Set.of_list
              | Groupnonuniformpartitionednv -> [] |> Set.of_list
              | Groupnonuniformquad -> [Groupnonuniform] |> Set.of_list
              | Groupnonuniformrotatekhr -> [Groupnonuniform] |> Set.of_list
              | Groupnonuniformshuffle -> [Groupnonuniform] |> Set.of_list
              | Groupnonuniformshufflerelative ->
                  [Groupnonuniform] |> Set.of_list
              | Groupnonuniformvote -> [Groupnonuniform] |> Set.of_list
              | Groups -> [] |> Set.of_list
              | Groupuniformarithmetickhr -> [] |> Set.of_list
              | Image1d -> [Sampled1d] |> Set.of_list
              | Imagebasic -> [Kernel] |> Set.of_list
              | Imagebuffer -> [Sampledbuffer] |> Set.of_list
              | Imagecubearray -> [Sampledcubearray] |> Set.of_list
              | Imagefootprintnv -> [] |> Set.of_list
              | Imagegatherbiaslodamd -> [Shader] |> Set.of_list
              | Imagegatherextended -> [Shader] |> Set.of_list
              | Imagemipmap -> [Imagebasic] |> Set.of_list
              | Imagemsarray -> [Shader] |> Set.of_list
              | Imagequery -> [Shader] |> Set.of_list
              | Imagereadwrite -> [Imagebasic] |> Set.of_list
              | Imagereadwritelodamd -> [Shader] |> Set.of_list
              | Imagerect -> [Sampledrect] |> Set.of_list
              | Indirectreferencesintel -> [] |> Set.of_list
              | Inputattachment -> [Shader] |> Set.of_list
              | Inputattachmentarraydynamicindexing ->
                  [Inputattachment] |> Set.of_list
              | Inputattachmentarraynonuniformindexing ->
                  [Inputattachment; Shadernonuniform] |> Set.of_list
              | Int16 -> [] |> Set.of_list
              | Int4cooperativematrixintel ->
                  [Int4typeintel; Cooperativematrixkhr] |> Set.of_list
              | Int4typeintel -> [] |> Set.of_list
              | Int64 -> [] |> Set.of_list
              | Int64atomics -> [Int64] |> Set.of_list
              | Int64imageext -> [Shader] |> Set.of_list
              | Int8 -> [] |> Set.of_list
              | Integerfunctions2intel -> [] |> Set.of_list
              | Interpolationfunction -> [Shader] |> Set.of_list
              | Iopipesaltera -> [] |> Set.of_list
              | Kernel -> [] |> Set.of_list
              | Kernelattributesintel -> [] |> Set.of_list
              | Linkage -> [] |> Set.of_list
              | Literalsampler -> [Kernel] |> Set.of_list
              | Longcompositesintel -> [] |> Set.of_list
              | Longvectorext -> [] |> Set.of_list
              | Loopfusealtera -> [] |> Set.of_list
              | Maskedgatherscatterintel -> [] |> Set.of_list
              | Matrix -> [] |> Set.of_list
              | Memoryaccessaliasingintel -> [] |> Set.of_list
              | Meshshadingext -> [Shader] |> Set.of_list
              | Meshshadingnv -> [Shader] |> Set.of_list
              | Minlod -> [Shader] |> Set.of_list
              | Multiview -> [Shader] |> Set.of_list
              | Multiviewport -> [Geometry] |> Set.of_list
              | Namedbarrier -> [Kernel] |> Set.of_list
              | Optnoneext -> [] |> Set.of_list
              | Perviewattributesnv -> [Multiview] |> Set.of_list
              | Physicalstoragebufferaddresses -> [Shader] |> Set.of_list
              | Pipes -> [Kernel] |> Set.of_list
              | Pipestorage -> [Pipes] |> Set.of_list
              | Quadcontrolkhr -> [] |> Set.of_list
              | Rawaccesschainsnv -> [] |> Set.of_list
              | Raycullmaskkhr -> [] |> Set.of_list
              | Rayquerykhr -> [Shader] |> Set.of_list
              | Rayquerypositionfetchkhr -> [Shader] |> Set.of_list
              | Rayqueryprovisionalkhr -> [Shader] |> Set.of_list
              | Raytracingclusteraccelerationstructurenv ->
                  [Raytracingkhr] |> Set.of_list
              | Raytracingdisplacementmicromapnv ->
                  [Raytracingkhr] |> Set.of_list
              | Raytracingkhr -> [Shader] |> Set.of_list
              | Raytracinglinearsweptspheresgeometrynv -> [] |> Set.of_list
              | Raytracingmotionblurnv -> [Shader] |> Set.of_list
              | Raytracingnv -> [Shader] |> Set.of_list
              | Raytracingopacitymicromapext -> [Shader] |> Set.of_list
              | Raytracingpositionfetchkhr -> [Shader] |> Set.of_list
              | Raytracingprovisionalkhr -> [Shader] |> Set.of_list
              | Raytracingspheresgeometrynv -> [] |> Set.of_list
              | Raytraversalprimitivecullingkhr ->
                  [Rayquerykhr; Raytracingkhr] |> Set.of_list
              | Registerlimitsintel -> [] |> Set.of_list
              | Replicatedcompositesext -> [] |> Set.of_list
              | Roundingmoderte -> [] |> Set.of_list
              | Roundingmodertz -> [] |> Set.of_list
              | Roundtoinfinityintel -> [] |> Set.of_list
              | Runtimealignedattributealtera -> [] |> Set.of_list
              | Runtimedescriptorarray -> [Shader] |> Set.of_list
              | Sampled1d -> [] |> Set.of_list
              | Sampledbuffer -> [] |> Set.of_list
              | Sampledcubearray -> [Shader] |> Set.of_list
              | Sampledimagearraydynamicindexing -> [Shader] |> Set.of_list
              | Sampledimagearraynonuniformindexing ->
                  [Shadernonuniform] |> Set.of_list
              | Sampledrect -> [Shader] |> Set.of_list
              | Samplemaskoverridecoveragenv ->
                  [Samplerateshading] |> Set.of_list
              | Samplemaskpostdepthcoverage -> [] |> Set.of_list
              | Samplerateshading -> [Shader] |> Set.of_list
              | Shader -> [Matrix] |> Set.of_list
              | Shader64bitindexingext -> [] |> Set.of_list
              | Shaderclockkhr -> [] |> Set.of_list
              | Shaderenqueueamdx -> [Shader] |> Set.of_list
              | Shaderinvocationreorderext -> [Raytracingkhr] |> Set.of_list
              | Shaderinvocationreordernv -> [Raytracingkhr] |> Set.of_list
              | Shaderlayer -> [] |> Set.of_list
              | Shadernonuniform -> [Shader] |> Set.of_list
              | Shadersmbuiltinsnv -> [Shader] |> Set.of_list
              | Shaderstereoviewnv -> [Shaderviewportmasknv] |> Set.of_list
              | Shaderviewportindex -> [] |> Set.of_list
              | Shaderviewportindexlayerext -> [Multiviewport] |> Set.of_list
              | Shaderviewportmasknv ->
                  [Shaderviewportindexlayerext] |> Set.of_list
              | Signedzeroinfnanpreserve -> [] |> Set.of_list
              | Sparseresidency -> [Shader] |> Set.of_list
              | Specconditionalintel -> [] |> Set.of_list
              | Splitbarrierintel -> [] |> Set.of_list
              | Stencilexportext -> [Shader] |> Set.of_list
              | Storagebuffer16bitaccess -> [] |> Set.of_list
              | Storagebuffer8bitaccess -> [] |> Set.of_list
              | Storagebufferarraydynamicindexing -> [Shader] |> Set.of_list
              | Storagebufferarraynonuniformindexing ->
                  [Shadernonuniform] |> Set.of_list
              | Storageimagearraydynamicindexing -> [Shader] |> Set.of_list
              | Storageimagearraynonuniformindexing ->
                  [Shadernonuniform] |> Set.of_list
              | Storageimageextendedformats -> [Shader] |> Set.of_list
              | Storageimagemultisample -> [Shader] |> Set.of_list
              | Storageimagereadwithoutformat -> [Shader] |> Set.of_list
              | Storageimagewritewithoutformat -> [Shader] |> Set.of_list
              | Storageinputoutput16 -> [] |> Set.of_list
              | Storagepushconstant16 -> [] |> Set.of_list
              | Storagepushconstant8 -> [] |> Set.of_list
              | Storagetensorarraydynamicindexingarm -> [] |> Set.of_list
              | Storagetensorarraynonuniformindexingarm -> [] |> Set.of_list
              | Storagetexelbufferarraydynamicindexing ->
                  [Imagebuffer] |> Set.of_list
              | Storagetexelbufferarraynonuniformindexing ->
                  [Imagebuffer; Shadernonuniform] |> Set.of_list
              | Subgroup2dblockiointel -> [] |> Set.of_list
              | Subgroup2dblocktransformintel ->
                  [Subgroup2dblockiointel] |> Set.of_list
              | Subgroup2dblocktransposeintel ->
                  [Subgroup2dblockiointel] |> Set.of_list
              | Subgroupavcmotionestimationchromaintel -> [] |> Set.of_list
              | Subgroupavcmotionestimationintel -> [] |> Set.of_list
              | Subgroupavcmotionestimationintraintel -> [] |> Set.of_list
              | Subgroupballotkhr -> [] |> Set.of_list
              | Subgroupbufferblockiointel -> [] |> Set.of_list
              | Subgroupbufferprefetchintel -> [] |> Set.of_list
              | Subgroupdispatch -> [Deviceenqueue] |> Set.of_list
              | Subgroupimageblockiointel -> [] |> Set.of_list
              | Subgroupimagemediablockiointel -> [] |> Set.of_list
              | Subgroupmatrixmultiplyaccumulateintel -> [] |> Set.of_list
              | Subgroupshuffleintel -> [] |> Set.of_list
              | Subgroupvotekhr -> [] |> Set.of_list
              | Tasksequencealtera -> [] |> Set.of_list
              | Tensoraddressingnv -> [] |> Set.of_list
              | Tensorfloat32roundingintel -> [] |> Set.of_list
              | Tensorsarm -> [] |> Set.of_list
              | Ternarybitwisefunctionintel -> [] |> Set.of_list
              | Tessellation -> [Shader] |> Set.of_list
              | Tessellationpointsize -> [Tessellation] |> Set.of_list
              | Textureblockmatch2qcom -> [] |> Set.of_list
              | Textureblockmatchqcom -> [] |> Set.of_list
              | Textureboxfilterqcom -> [] |> Set.of_list
              | Texturesampleweightedqcom -> [] |> Set.of_list
              | Tileimagecolorreadaccessext -> [] |> Set.of_list
              | Tileimagedepthreadaccessext -> [] |> Set.of_list
              | Tileimagestencilreadaccessext -> [] |> Set.of_list
              | Tileshadingqcom -> [Shader] |> Set.of_list
              | Transformfeedback -> [Shader] |> Set.of_list
              | Uniformandstoragebuffer16bitaccess ->
                  [Storagebuffer16bitaccess] |> Set.of_list
              | Uniformandstoragebuffer8bitaccess ->
                  [Storagebuffer8bitaccess] |> Set.of_list
              | Uniformbufferarraydynamicindexing -> [Shader] |> Set.of_list
              | Uniformbufferarraynonuniformindexing ->
                  [Shadernonuniform] |> Set.of_list
              | Uniformdecoration -> [] |> Set.of_list
              | Uniformtexelbufferarraydynamicindexing ->
                  [Sampledbuffer] |> Set.of_list
              | Uniformtexelbufferarraynonuniformindexing ->
                  [Sampledbuffer; Shadernonuniform] |> Set.of_list
              | Unstructuredloopcontrolsintel -> [] |> Set.of_list
              | Untypedpointerskhr -> [] |> Set.of_list
              | Untypedvariablelengtharrayintel ->
                  [Variablelengtharrayintel; Untypedpointerskhr] |>
                    Set.of_list
              | Usmstorageclassesaltera -> [] |> Set.of_list
              | Variablelengtharrayintel -> [] |> Set.of_list
              | Variablepointers ->
                  [Variablepointersstoragebuffer] |> Set.of_list
              | Variablepointersstoragebuffer -> [Shader] |> Set.of_list
              | Vector16 -> [Kernel] |> Set.of_list
              | Vectoranyintel -> [] |> Set.of_list
              | Vectorcomputeintel -> [Vectoranyintel] |> Set.of_list
              | Vulkanmemorymodel -> [] |> Set.of_list
              | Vulkanmemorymodeldevicescope -> [] |> Set.of_list
              | Workgroupmemoryexplicitlayout16bitaccesskhr ->
                  [Workgroupmemoryexplicitlayoutkhr] |> Set.of_list
              | Workgroupmemoryexplicitlayout8bitaccesskhr ->
                  [Workgroupmemoryexplicitlayoutkhr] |> Set.of_list
              | Workgroupmemoryexplicitlayoutkhr -> [Shader] |> Set.of_list
          end
        module Accessqualifier =
          struct
            type t =
              | Readonly 
              | Readwrite 
              | Writeonly [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Readonly -> [0l]
              | Readwrite -> [2l]
              | Writeonly -> [1l]
            let any_required_version =
              function
              | Readonly ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Readwrite ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Writeonly ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Readonly -> [] |> Requirements.Extension.Set.of_list
              | Readwrite -> [] |> Requirements.Extension.Set.of_list
              | Writeonly -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Readonly -> [Capability.Kernel] |> Capability.Set.of_list
              | Readwrite -> [Capability.Kernel] |> Capability.Set.of_list
              | Writeonly -> [Capability.Kernel] |> Capability.Set.of_list
          end
        module Addressingmodel =
          struct
            type t =
              | Logical 
              | Physical32 
              | Physical64 
              | Physicalstoragebuffer64 [@@deriving
                                          compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Logical -> [0l]
              | Physical32 -> [1l]
              | Physical64 -> [2l]
              | Physicalstoragebuffer64 -> [5348l]
            let any_required_version =
              function
              | Logical ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Physical32 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Physical64 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Physicalstoragebuffer64 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Logical -> [] |> Requirements.Extension.Set.of_list
              | Physical32 -> [] |> Requirements.Extension.Set.of_list
              | Physical64 -> [] |> Requirements.Extension.Set.of_list
              | Physicalstoragebuffer64 ->
                  [Requirements.Extension.Spv_ext_physical_storage_buffer;
                  Requirements.Extension.Spv_khr_physical_storage_buffer] |>
                    Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Logical -> [] |> Capability.Set.of_list
              | Physical32 ->
                  [Capability.Addresses] |> Capability.Set.of_list
              | Physical64 ->
                  [Capability.Addresses] |> Capability.Set.of_list
              | Physicalstoragebuffer64 ->
                  [Capability.Physicalstoragebufferaddresses] |>
                    Capability.Set.of_list
          end
        module Builtin =
          struct
            type t =
              | Barycoordkhr 
              | Barycoordnoperspamd 
              | Barycoordnoperspcentroidamd 
              | Barycoordnoperspkhr 
              | Barycoordnoperspsampleamd 
              | Barycoordpullmodelamd 
              | Barycoordsmoothamd 
              | Barycoordsmoothcentroidamd 
              | Barycoordsmoothsampleamd 
              | Baseinstance 
              | Basevertex 
              | Clipdistance 
              | Clipdistanceperviewnv 
              | Clusteridnv 
              | Corecountarm 
              | Coreidarm 
              | Coremaxidarm 
              | Culldistance 
              | Culldistanceperviewnv 
              | Cullmaskkhr 
              | Cullprimitiveext 
              | Currentraytimenv 
              | Deviceindex 
              | Drawindex 
              | Enqueuedworkgroupsize 
              | Fragcoord 
              | Fragdepth 
              | Fraginvocationcountext 
              | Fragsizeext 
              | Fragstencilrefext 
              | Frontfacing 
              | Fullycoveredext 
              | Globalinvocationid 
              | Globallinearid 
              | Globaloffset 
              | Globalsize 
              | Helperinvocation 
              | Hitislssnv 
              | Hitisspherenv 
              | Hitkindbackfacingmicrotrianglenv 
              | Hitkindfrontfacingmicrotrianglenv 
              | Hitkindkhr 
              | Hitlsspositionsnv 
              | Hitlssradiinv 
              | Hitmicrotrianglevertexbarycentricsnv 
              | Hitmicrotrianglevertexpositionsnv 
              | Hitspherepositionnv 
              | Hitsphereradiusnv 
              | Hittnv 
              | Hittrianglevertexpositionskhr 
              | Incomingrayflagskhr 
              | Instancecustomindexkhr 
              | Instanceid 
              | Instanceindex 
              | Invocationid 
              | Launchidkhr 
              | Launchsizekhr 
              | Layer 
              | Layerperviewnv 
              | Localinvocationid 
              | Localinvocationindex 
              | Meshviewcountnv 
              | Meshviewindicesnv 
              | Numenqueuedsubgroups 
              | Numsubgroups 
              | Numworkgroups 
              | Objectraydirectionkhr 
              | Objectrayoriginkhr 
              | Objecttoworldkhr 
              | Patchvertices 
              | Pointcoord 
              | Pointsize 
              | Position 
              | Positionperviewnv 
              | Primitivecountnv 
              | Primitiveid 
              | Primitiveindicesnv 
              | Primitivelineindicesext 
              | Primitivepointindicesext 
              | Primitiveshadingratekhr 
              | Primitivetriangleindicesext 
              | Raygeometryindexkhr 
              | Raytmaxkhr 
              | Raytminkhr 
              | Remainingrecursionlevelsamdx 
              | Sampleid 
              | Samplemask 
              | Sampleposition 
              | Secondarypositionnv 
              | Secondaryviewportmasknv 
              | Shaderindexamdx 
              | Shadingratekhr 
              | Smcountnv 
              | Smidnv 
              | Subgroupeqmask 
              | Subgroupgemask 
              | Subgroupgtmask 
              | Subgroupid 
              | Subgrouplemask 
              | Subgrouplocalinvocationid 
              | Subgroupltmask 
              | Subgroupmaxsize 
              | Subgroupsize 
              | Taskcountnv 
              | Tesscoord 
              | Tesslevelinner 
              | Tesslevelouter 
              | Tileapronsizeqcom 
              | Tiledimensionqcom 
              | Tileoffsetqcom 
              | Vertexid 
              | Vertexindex 
              | Viewindex 
              | Viewportindex 
              | Viewportmasknv 
              | Viewportmaskperviewnv 
              | Warpidarm 
              | Warpidnv 
              | Warpmaxidarm 
              | Warpspersmnv 
              | Workdim 
              | Workgroupid 
              | Workgroupsize 
              | Worldraydirectionkhr 
              | Worldrayoriginkhr 
              | Worldtoobjectkhr [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Barycoordkhr -> [5286l]
              | Barycoordnoperspamd -> [4992l]
              | Barycoordnoperspcentroidamd -> [4993l]
              | Barycoordnoperspkhr -> [5287l]
              | Barycoordnoperspsampleamd -> [4994l]
              | Barycoordpullmodelamd -> [4998l]
              | Barycoordsmoothamd -> [4995l]
              | Barycoordsmoothcentroidamd -> [4996l]
              | Barycoordsmoothsampleamd -> [4997l]
              | Baseinstance -> [4425l]
              | Basevertex -> [4424l]
              | Clipdistance -> [3l]
              | Clipdistanceperviewnv -> [5277l]
              | Clusteridnv -> [5436l]
              | Corecountarm -> [4161l]
              | Coreidarm -> [4160l]
              | Coremaxidarm -> [4162l]
              | Culldistance -> [4l]
              | Culldistanceperviewnv -> [5278l]
              | Cullmaskkhr -> [6021l]
              | Cullprimitiveext -> [5299l]
              | Currentraytimenv -> [5334l]
              | Deviceindex -> [4438l]
              | Drawindex -> [4426l]
              | Enqueuedworkgroupsize -> [32l]
              | Fragcoord -> [15l]
              | Fragdepth -> [22l]
              | Fraginvocationcountext -> [5293l]
              | Fragsizeext -> [5292l]
              | Fragstencilrefext -> [5014l]
              | Frontfacing -> [17l]
              | Fullycoveredext -> [5264l]
              | Globalinvocationid -> [28l]
              | Globallinearid -> [34l]
              | Globaloffset -> [33l]
              | Globalsize -> [31l]
              | Helperinvocation -> [23l]
              | Hitislssnv -> [5360l]
              | Hitisspherenv -> [5359l]
              | Hitkindbackfacingmicrotrianglenv -> [5406l]
              | Hitkindfrontfacingmicrotrianglenv -> [5405l]
              | Hitkindkhr -> [5333l]
              | Hitlsspositionsnv -> [5396l]
              | Hitlssradiinv -> [5421l]
              | Hitmicrotrianglevertexbarycentricsnv -> [5344l]
              | Hitmicrotrianglevertexpositionsnv -> [5337l]
              | Hitspherepositionnv -> [5361l]
              | Hitsphereradiusnv -> [5420l]
              | Hittnv -> [5332l]
              | Hittrianglevertexpositionskhr -> [5335l]
              | Incomingrayflagskhr -> [5351l]
              | Instancecustomindexkhr -> [5327l]
              | Instanceid -> [6l]
              | Instanceindex -> [43l]
              | Invocationid -> [8l]
              | Launchidkhr -> [5319l]
              | Launchsizekhr -> [5320l]
              | Layer -> [9l]
              | Layerperviewnv -> [5279l]
              | Localinvocationid -> [27l]
              | Localinvocationindex -> [29l]
              | Meshviewcountnv -> [5280l]
              | Meshviewindicesnv -> [5281l]
              | Numenqueuedsubgroups -> [39l]
              | Numsubgroups -> [38l]
              | Numworkgroups -> [24l]
              | Objectraydirectionkhr -> [5324l]
              | Objectrayoriginkhr -> [5323l]
              | Objecttoworldkhr -> [5330l]
              | Patchvertices -> [14l]
              | Pointcoord -> [16l]
              | Pointsize -> [1l]
              | Position -> [0l]
              | Positionperviewnv -> [5261l]
              | Primitivecountnv -> [5275l]
              | Primitiveid -> [7l]
              | Primitiveindicesnv -> [5276l]
              | Primitivelineindicesext -> [5295l]
              | Primitivepointindicesext -> [5294l]
              | Primitiveshadingratekhr -> [4432l]
              | Primitivetriangleindicesext -> [5296l]
              | Raygeometryindexkhr -> [5352l]
              | Raytmaxkhr -> [5326l]
              | Raytminkhr -> [5325l]
              | Remainingrecursionlevelsamdx -> [5021l]
              | Sampleid -> [18l]
              | Samplemask -> [20l]
              | Sampleposition -> [19l]
              | Secondarypositionnv -> [5257l]
              | Secondaryviewportmasknv -> [5258l]
              | Shaderindexamdx -> [5073l]
              | Shadingratekhr -> [4444l]
              | Smcountnv -> [5375l]
              | Smidnv -> [5377l]
              | Subgroupeqmask -> [4416l]
              | Subgroupgemask -> [4417l]
              | Subgroupgtmask -> [4418l]
              | Subgroupid -> [40l]
              | Subgrouplemask -> [4419l]
              | Subgrouplocalinvocationid -> [41l]
              | Subgroupltmask -> [4420l]
              | Subgroupmaxsize -> [37l]
              | Subgroupsize -> [36l]
              | Taskcountnv -> [5274l]
              | Tesscoord -> [13l]
              | Tesslevelinner -> [12l]
              | Tesslevelouter -> [11l]
              | Tileapronsizeqcom -> [4494l]
              | Tiledimensionqcom -> [4493l]
              | Tileoffsetqcom -> [4492l]
              | Vertexid -> [5l]
              | Vertexindex -> [42l]
              | Viewindex -> [4440l]
              | Viewportindex -> [10l]
              | Viewportmasknv -> [5253l]
              | Viewportmaskperviewnv -> [5262l]
              | Warpidarm -> [4163l]
              | Warpidnv -> [5376l]
              | Warpmaxidarm -> [4164l]
              | Warpspersmnv -> [5374l]
              | Workdim -> [30l]
              | Workgroupid -> [26l]
              | Workgroupsize -> [25l]
              | Worldraydirectionkhr -> [5322l]
              | Worldrayoriginkhr -> [5321l]
              | Worldtoobjectkhr -> [5331l]
            let any_required_version =
              function
              | Barycoordkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Barycoordnoperspamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Barycoordnoperspcentroidamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Barycoordnoperspkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Barycoordnoperspsampleamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Barycoordpullmodelamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Barycoordsmoothamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Barycoordsmoothcentroidamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Barycoordsmoothsampleamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Baseinstance ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Basevertex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Clipdistance ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Clipdistanceperviewnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Clusteridnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Corecountarm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Coreidarm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Coremaxidarm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Culldistance ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Culldistanceperviewnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cullmaskkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cullprimitiveext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Currentraytimenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Deviceindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Drawindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Enqueuedworkgroupsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragcoord ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragdepth ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fraginvocationcountext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragsizeext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragstencilrefext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Frontfacing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fullycoveredext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Globalinvocationid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Globallinearid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Globaloffset ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Globalsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Helperinvocation ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitislssnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitisspherenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitkindbackfacingmicrotrianglenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitkindfrontfacingmicrotrianglenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitkindkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitlsspositionsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitlssradiinv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitmicrotrianglevertexbarycentricsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitmicrotrianglevertexpositionsnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitspherepositionnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitsphereradiusnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hittnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hittrianglevertexpositionskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Incomingrayflagskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Instancecustomindexkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Instanceid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Instanceindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Invocationid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Launchidkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Launchsizekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Layer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Layerperviewnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Localinvocationid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Localinvocationindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Meshviewcountnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Meshviewindicesnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Numenqueuedsubgroups ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Numsubgroups ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Numworkgroups ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Objectraydirectionkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Objectrayoriginkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Objecttoworldkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Patchvertices ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pointcoord ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pointsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Position ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Positionperviewnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Primitivecountnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Primitiveid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Primitiveindicesnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Primitivelineindicesext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Primitivepointindicesext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Primitiveshadingratekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Primitivetriangleindicesext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raygeometryindexkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytmaxkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raytminkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Remainingrecursionlevelsamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampleid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Samplemask ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampleposition ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Secondarypositionnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Secondaryviewportmasknv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderindexamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shadingratekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Smcountnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Smidnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupeqmask ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupgemask ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupgtmask ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgrouplemask ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgrouplocalinvocationid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupltmask ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupmaxsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Taskcountnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tesscoord ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tesslevelinner ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tesslevelouter ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileapronsizeqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tiledimensionqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileoffsetqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vertexid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vertexindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Viewindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Viewportindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Viewportmasknv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Viewportmaskperviewnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Warpidarm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Warpidnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Warpmaxidarm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Warpspersmnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workdim ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workgroupid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workgroupsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Worldraydirectionkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Worldrayoriginkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Worldtoobjectkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Barycoordkhr ->
                  [Requirements.Extension.Spv_nv_fragment_shader_barycentric;
                  Requirements.Extension.Spv_khr_fragment_shader_barycentric]
                    |> Requirements.Extension.Set.of_list
              | Barycoordnoperspamd ->
                  [Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                    |> Requirements.Extension.Set.of_list
              | Barycoordnoperspcentroidamd ->
                  [Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                    |> Requirements.Extension.Set.of_list
              | Barycoordnoperspkhr ->
                  [Requirements.Extension.Spv_nv_fragment_shader_barycentric;
                  Requirements.Extension.Spv_khr_fragment_shader_barycentric]
                    |> Requirements.Extension.Set.of_list
              | Barycoordnoperspsampleamd ->
                  [Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                    |> Requirements.Extension.Set.of_list
              | Barycoordpullmodelamd ->
                  [Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                    |> Requirements.Extension.Set.of_list
              | Barycoordsmoothamd ->
                  [Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                    |> Requirements.Extension.Set.of_list
              | Barycoordsmoothcentroidamd ->
                  [Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                    |> Requirements.Extension.Set.of_list
              | Barycoordsmoothsampleamd ->
                  [Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                    |> Requirements.Extension.Set.of_list
              | Baseinstance ->
                  [Requirements.Extension.Spv_khr_shader_draw_parameters] |>
                    Requirements.Extension.Set.of_list
              | Basevertex ->
                  [Requirements.Extension.Spv_khr_shader_draw_parameters] |>
                    Requirements.Extension.Set.of_list
              | Clipdistance -> [] |> Requirements.Extension.Set.of_list
              | Clipdistanceperviewnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Clusteridnv ->
                  [Requirements.Extension.Spv_nv_cluster_acceleration_structure]
                    |> Requirements.Extension.Set.of_list
              | Corecountarm -> [] |> Requirements.Extension.Set.of_list
              | Coreidarm -> [] |> Requirements.Extension.Set.of_list
              | Coremaxidarm -> [] |> Requirements.Extension.Set.of_list
              | Culldistance -> [] |> Requirements.Extension.Set.of_list
              | Culldistanceperviewnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Cullmaskkhr ->
                  [Requirements.Extension.Spv_khr_ray_cull_mask] |>
                    Requirements.Extension.Set.of_list
              | Cullprimitiveext ->
                  [Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Currentraytimenv ->
                  [Requirements.Extension.Spv_nv_ray_tracing_motion_blur] |>
                    Requirements.Extension.Set.of_list
              | Deviceindex ->
                  [Requirements.Extension.Spv_khr_device_group] |>
                    Requirements.Extension.Set.of_list
              | Drawindex ->
                  [Requirements.Extension.Spv_khr_shader_draw_parameters;
                  Requirements.Extension.Spv_nv_mesh_shader;
                  Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Enqueuedworkgroupsize ->
                  [] |> Requirements.Extension.Set.of_list
              | Fragcoord -> [] |> Requirements.Extension.Set.of_list
              | Fragdepth -> [] |> Requirements.Extension.Set.of_list
              | Fraginvocationcountext ->
                  [Requirements.Extension.Spv_ext_fragment_invocation_density;
                  Requirements.Extension.Spv_nv_shading_rate] |>
                    Requirements.Extension.Set.of_list
              | Fragsizeext ->
                  [Requirements.Extension.Spv_ext_fragment_invocation_density;
                  Requirements.Extension.Spv_nv_shading_rate] |>
                    Requirements.Extension.Set.of_list
              | Fragstencilrefext ->
                  [Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Frontfacing -> [] |> Requirements.Extension.Set.of_list
              | Fullycoveredext ->
                  [Requirements.Extension.Spv_ext_fragment_fully_covered] |>
                    Requirements.Extension.Set.of_list
              | Globalinvocationid ->
                  [] |> Requirements.Extension.Set.of_list
              | Globallinearid -> [] |> Requirements.Extension.Set.of_list
              | Globaloffset -> [] |> Requirements.Extension.Set.of_list
              | Globalsize -> [] |> Requirements.Extension.Set.of_list
              | Helperinvocation -> [] |> Requirements.Extension.Set.of_list
              | Hitislssnv ->
                  [Requirements.Extension.Spv_nv_linear_swept_spheres] |>
                    Requirements.Extension.Set.of_list
              | Hitisspherenv ->
                  [Requirements.Extension.Spv_nv_linear_swept_spheres] |>
                    Requirements.Extension.Set.of_list
              | Hitkindbackfacingmicrotrianglenv ->
                  [] |> Requirements.Extension.Set.of_list
              | Hitkindfrontfacingmicrotrianglenv ->
                  [] |> Requirements.Extension.Set.of_list
              | Hitkindkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Hitlsspositionsnv ->
                  [Requirements.Extension.Spv_nv_linear_swept_spheres] |>
                    Requirements.Extension.Set.of_list
              | Hitlssradiinv ->
                  [Requirements.Extension.Spv_nv_linear_swept_spheres] |>
                    Requirements.Extension.Set.of_list
              | Hitmicrotrianglevertexbarycentricsnv ->
                  [] |> Requirements.Extension.Set.of_list
              | Hitmicrotrianglevertexpositionsnv ->
                  [] |> Requirements.Extension.Set.of_list
              | Hitspherepositionnv ->
                  [Requirements.Extension.Spv_nv_linear_swept_spheres] |>
                    Requirements.Extension.Set.of_list
              | Hitsphereradiusnv ->
                  [Requirements.Extension.Spv_nv_linear_swept_spheres] |>
                    Requirements.Extension.Set.of_list
              | Hittnv ->
                  [Requirements.Extension.Spv_nv_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Hittrianglevertexpositionskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Incomingrayflagskhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Instancecustomindexkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Instanceid -> [] |> Requirements.Extension.Set.of_list
              | Instanceindex -> [] |> Requirements.Extension.Set.of_list
              | Invocationid -> [] |> Requirements.Extension.Set.of_list
              | Launchidkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Launchsizekhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Layer -> [] |> Requirements.Extension.Set.of_list
              | Layerperviewnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Localinvocationid -> [] |> Requirements.Extension.Set.of_list
              | Localinvocationindex ->
                  [] |> Requirements.Extension.Set.of_list
              | Meshviewcountnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Meshviewindicesnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Numenqueuedsubgroups ->
                  [] |> Requirements.Extension.Set.of_list
              | Numsubgroups -> [] |> Requirements.Extension.Set.of_list
              | Numworkgroups -> [] |> Requirements.Extension.Set.of_list
              | Objectraydirectionkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Objectrayoriginkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Objecttoworldkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Patchvertices -> [] |> Requirements.Extension.Set.of_list
              | Pointcoord -> [] |> Requirements.Extension.Set.of_list
              | Pointsize -> [] |> Requirements.Extension.Set.of_list
              | Position -> [] |> Requirements.Extension.Set.of_list
              | Positionperviewnv ->
                  [Requirements.Extension.Spv_nvx_multiview_per_view_attributes;
                  Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Primitivecountnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Primitiveid -> [] |> Requirements.Extension.Set.of_list
              | Primitiveindicesnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Primitivelineindicesext ->
                  [Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Primitivepointindicesext ->
                  [Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Primitiveshadingratekhr ->
                  [Requirements.Extension.Spv_khr_fragment_shading_rate] |>
                    Requirements.Extension.Set.of_list
              | Primitivetriangleindicesext ->
                  [Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Raygeometryindexkhr ->
                  [Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Raytmaxkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Raytminkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Remainingrecursionlevelsamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Sampleid -> [] |> Requirements.Extension.Set.of_list
              | Samplemask -> [] |> Requirements.Extension.Set.of_list
              | Sampleposition -> [] |> Requirements.Extension.Set.of_list
              | Secondarypositionnv ->
                  [Requirements.Extension.Spv_nv_stereo_view_rendering] |>
                    Requirements.Extension.Set.of_list
              | Secondaryviewportmasknv ->
                  [Requirements.Extension.Spv_nv_stereo_view_rendering] |>
                    Requirements.Extension.Set.of_list
              | Shaderindexamdx -> [] |> Requirements.Extension.Set.of_list
              | Shadingratekhr ->
                  [Requirements.Extension.Spv_khr_fragment_shading_rate] |>
                    Requirements.Extension.Set.of_list
              | Smcountnv ->
                  [Requirements.Extension.Spv_nv_shader_sm_builtins] |>
                    Requirements.Extension.Set.of_list
              | Smidnv ->
                  [Requirements.Extension.Spv_nv_shader_sm_builtins] |>
                    Requirements.Extension.Set.of_list
              | Subgroupeqmask ->
                  [Requirements.Extension.Spv_khr_shader_ballot] |>
                    Requirements.Extension.Set.of_list
              | Subgroupgemask ->
                  [Requirements.Extension.Spv_khr_shader_ballot] |>
                    Requirements.Extension.Set.of_list
              | Subgroupgtmask ->
                  [Requirements.Extension.Spv_khr_shader_ballot] |>
                    Requirements.Extension.Set.of_list
              | Subgroupid -> [] |> Requirements.Extension.Set.of_list
              | Subgrouplemask ->
                  [Requirements.Extension.Spv_khr_shader_ballot] |>
                    Requirements.Extension.Set.of_list
              | Subgrouplocalinvocationid ->
                  [] |> Requirements.Extension.Set.of_list
              | Subgroupltmask ->
                  [Requirements.Extension.Spv_khr_shader_ballot] |>
                    Requirements.Extension.Set.of_list
              | Subgroupmaxsize -> [] |> Requirements.Extension.Set.of_list
              | Subgroupsize -> [] |> Requirements.Extension.Set.of_list
              | Taskcountnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Tesscoord -> [] |> Requirements.Extension.Set.of_list
              | Tesslevelinner -> [] |> Requirements.Extension.Set.of_list
              | Tesslevelouter -> [] |> Requirements.Extension.Set.of_list
              | Tileapronsizeqcom -> [] |> Requirements.Extension.Set.of_list
              | Tiledimensionqcom -> [] |> Requirements.Extension.Set.of_list
              | Tileoffsetqcom -> [] |> Requirements.Extension.Set.of_list
              | Vertexid -> [] |> Requirements.Extension.Set.of_list
              | Vertexindex -> [] |> Requirements.Extension.Set.of_list
              | Viewindex ->
                  [Requirements.Extension.Spv_khr_multiview] |>
                    Requirements.Extension.Set.of_list
              | Viewportindex -> [] |> Requirements.Extension.Set.of_list
              | Viewportmasknv ->
                  [Requirements.Extension.Spv_nv_viewport_array2;
                  Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Viewportmaskperviewnv ->
                  [Requirements.Extension.Spv_nvx_multiview_per_view_attributes;
                  Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Warpidarm -> [] |> Requirements.Extension.Set.of_list
              | Warpidnv ->
                  [Requirements.Extension.Spv_nv_shader_sm_builtins] |>
                    Requirements.Extension.Set.of_list
              | Warpmaxidarm -> [] |> Requirements.Extension.Set.of_list
              | Warpspersmnv ->
                  [Requirements.Extension.Spv_nv_shader_sm_builtins] |>
                    Requirements.Extension.Set.of_list
              | Workdim -> [] |> Requirements.Extension.Set.of_list
              | Workgroupid -> [] |> Requirements.Extension.Set.of_list
              | Workgroupsize -> [] |> Requirements.Extension.Set.of_list
              | Worldraydirectionkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Worldrayoriginkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Worldtoobjectkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Barycoordkhr ->
                  [Capability.Fragmentbarycentrickhr] |>
                    Capability.Set.of_list
              | Barycoordnoperspamd -> [] |> Capability.Set.of_list
              | Barycoordnoperspcentroidamd -> [] |> Capability.Set.of_list
              | Barycoordnoperspkhr ->
                  [Capability.Fragmentbarycentrickhr] |>
                    Capability.Set.of_list
              | Barycoordnoperspsampleamd -> [] |> Capability.Set.of_list
              | Barycoordpullmodelamd -> [] |> Capability.Set.of_list
              | Barycoordsmoothamd -> [] |> Capability.Set.of_list
              | Barycoordsmoothcentroidamd -> [] |> Capability.Set.of_list
              | Barycoordsmoothsampleamd -> [] |> Capability.Set.of_list
              | Baseinstance ->
                  [Capability.Drawparameters] |> Capability.Set.of_list
              | Basevertex ->
                  [Capability.Drawparameters] |> Capability.Set.of_list
              | Clipdistance ->
                  [Capability.Clipdistance] |> Capability.Set.of_list
              | Clipdistanceperviewnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Clusteridnv ->
                  [Capability.Raytracingclusteraccelerationstructurenv] |>
                    Capability.Set.of_list
              | Corecountarm ->
                  [Capability.Corebuiltinsarm] |> Capability.Set.of_list
              | Coreidarm ->
                  [Capability.Corebuiltinsarm] |> Capability.Set.of_list
              | Coremaxidarm ->
                  [Capability.Corebuiltinsarm] |> Capability.Set.of_list
              | Culldistance ->
                  [Capability.Culldistance] |> Capability.Set.of_list
              | Culldistanceperviewnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Cullmaskkhr ->
                  [Capability.Raycullmaskkhr] |> Capability.Set.of_list
              | Cullprimitiveext ->
                  [Capability.Meshshadingext] |> Capability.Set.of_list
              | Currentraytimenv ->
                  [Capability.Raytracingmotionblurnv] |>
                    Capability.Set.of_list
              | Deviceindex ->
                  [Capability.Devicegroup] |> Capability.Set.of_list
              | Drawindex ->
                  [Capability.Drawparameters;
                  Capability.Meshshadingnv;
                  Capability.Meshshadingext] |> Capability.Set.of_list
              | Enqueuedworkgroupsize ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Fragcoord -> [Capability.Shader] |> Capability.Set.of_list
              | Fragdepth -> [Capability.Shader] |> Capability.Set.of_list
              | Fraginvocationcountext ->
                  [Capability.Fragmentdensityext] |> Capability.Set.of_list
              | Fragsizeext ->
                  [Capability.Fragmentdensityext] |> Capability.Set.of_list
              | Fragstencilrefext ->
                  [Capability.Stencilexportext] |> Capability.Set.of_list
              | Frontfacing -> [Capability.Shader] |> Capability.Set.of_list
              | Fullycoveredext ->
                  [Capability.Fragmentfullycoveredext] |>
                    Capability.Set.of_list
              | Globalinvocationid -> [] |> Capability.Set.of_list
              | Globallinearid ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Globaloffset -> [Capability.Kernel] |> Capability.Set.of_list
              | Globalsize -> [Capability.Kernel] |> Capability.Set.of_list
              | Helperinvocation ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Hitislssnv ->
                  [Capability.Raytracinglinearsweptspheresgeometrynv] |>
                    Capability.Set.of_list
              | Hitisspherenv ->
                  [Capability.Raytracingspheresgeometrynv] |>
                    Capability.Set.of_list
              | Hitkindbackfacingmicrotrianglenv ->
                  [Capability.Raytracingdisplacementmicromapnv] |>
                    Capability.Set.of_list
              | Hitkindfrontfacingmicrotrianglenv ->
                  [Capability.Raytracingdisplacementmicromapnv] |>
                    Capability.Set.of_list
              | Hitkindkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Hitlsspositionsnv ->
                  [Capability.Raytracinglinearsweptspheresgeometrynv] |>
                    Capability.Set.of_list
              | Hitlssradiinv ->
                  [Capability.Raytracinglinearsweptspheresgeometrynv] |>
                    Capability.Set.of_list
              | Hitmicrotrianglevertexbarycentricsnv ->
                  [Capability.Raytracingdisplacementmicromapnv] |>
                    Capability.Set.of_list
              | Hitmicrotrianglevertexpositionsnv ->
                  [Capability.Raytracingdisplacementmicromapnv] |>
                    Capability.Set.of_list
              | Hitspherepositionnv ->
                  [Capability.Raytracingspheresgeometrynv] |>
                    Capability.Set.of_list
              | Hitsphereradiusnv ->
                  [Capability.Raytracingspheresgeometrynv] |>
                    Capability.Set.of_list
              | Hittnv -> [Capability.Raytracingnv] |> Capability.Set.of_list
              | Hittrianglevertexpositionskhr ->
                  [Capability.Raytracingpositionfetchkhr] |>
                    Capability.Set.of_list
              | Incomingrayflagskhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Instancecustomindexkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Instanceid -> [Capability.Shader] |> Capability.Set.of_list
              | Instanceindex ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Invocationid ->
                  [Capability.Geometry; Capability.Tessellation] |>
                    Capability.Set.of_list
              | Launchidkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Launchsizekhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Layer ->
                  [Capability.Geometry;
                  Capability.Shaderlayer;
                  Capability.Shaderviewportindexlayerext;
                  Capability.Meshshadingnv;
                  Capability.Meshshadingext] |> Capability.Set.of_list
              | Layerperviewnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Localinvocationid -> [] |> Capability.Set.of_list
              | Localinvocationindex -> [] |> Capability.Set.of_list
              | Meshviewcountnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Meshviewindicesnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Numenqueuedsubgroups ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Numsubgroups ->
                  [Capability.Kernel; Capability.Groupnonuniform] |>
                    Capability.Set.of_list
              | Numworkgroups -> [] |> Capability.Set.of_list
              | Objectraydirectionkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Objectrayoriginkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Objecttoworldkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Patchvertices ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Pointcoord -> [Capability.Shader] |> Capability.Set.of_list
              | Pointsize -> [Capability.Shader] |> Capability.Set.of_list
              | Position -> [Capability.Shader] |> Capability.Set.of_list
              | Positionperviewnv ->
                  [Capability.Perviewattributesnv; Capability.Meshshadingnv]
                    |> Capability.Set.of_list
              | Primitivecountnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Primitiveid ->
                  [Capability.Geometry;
                  Capability.Tessellation;
                  Capability.Raytracingnv;
                  Capability.Raytracingkhr;
                  Capability.Meshshadingnv;
                  Capability.Meshshadingext] |> Capability.Set.of_list
              | Primitiveindicesnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Primitivelineindicesext ->
                  [Capability.Meshshadingext] |> Capability.Set.of_list
              | Primitivepointindicesext ->
                  [Capability.Meshshadingext] |> Capability.Set.of_list
              | Primitiveshadingratekhr ->
                  [Capability.Fragmentshadingratekhr] |>
                    Capability.Set.of_list
              | Primitivetriangleindicesext ->
                  [Capability.Meshshadingext] |> Capability.Set.of_list
              | Raygeometryindexkhr ->
                  [Capability.Raytracingkhr] |> Capability.Set.of_list
              | Raytmaxkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Raytminkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Remainingrecursionlevelsamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Sampleid ->
                  [Capability.Samplerateshading] |> Capability.Set.of_list
              | Samplemask -> [Capability.Shader] |> Capability.Set.of_list
              | Sampleposition ->
                  [Capability.Samplerateshading] |> Capability.Set.of_list
              | Secondarypositionnv ->
                  [Capability.Shaderstereoviewnv] |> Capability.Set.of_list
              | Secondaryviewportmasknv ->
                  [Capability.Shaderstereoviewnv] |> Capability.Set.of_list
              | Shaderindexamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Shadingratekhr ->
                  [Capability.Fragmentshadingratekhr] |>
                    Capability.Set.of_list
              | Smcountnv ->
                  [Capability.Shadersmbuiltinsnv] |> Capability.Set.of_list
              | Smidnv ->
                  [Capability.Shadersmbuiltinsnv] |> Capability.Set.of_list
              | Subgroupeqmask ->
                  [Capability.Subgroupballotkhr;
                  Capability.Groupnonuniformballot] |> Capability.Set.of_list
              | Subgroupgemask ->
                  [Capability.Subgroupballotkhr;
                  Capability.Groupnonuniformballot] |> Capability.Set.of_list
              | Subgroupgtmask ->
                  [Capability.Subgroupballotkhr;
                  Capability.Groupnonuniformballot] |> Capability.Set.of_list
              | Subgroupid ->
                  [Capability.Kernel; Capability.Groupnonuniform] |>
                    Capability.Set.of_list
              | Subgrouplemask ->
                  [Capability.Subgroupballotkhr;
                  Capability.Groupnonuniformballot] |> Capability.Set.of_list
              | Subgrouplocalinvocationid ->
                  [Capability.Kernel;
                  Capability.Groupnonuniform;
                  Capability.Subgroupballotkhr] |> Capability.Set.of_list
              | Subgroupltmask ->
                  [Capability.Subgroupballotkhr;
                  Capability.Groupnonuniformballot] |> Capability.Set.of_list
              | Subgroupmaxsize ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Subgroupsize ->
                  [Capability.Kernel;
                  Capability.Groupnonuniform;
                  Capability.Subgroupballotkhr] |> Capability.Set.of_list
              | Taskcountnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Tesscoord ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Tesslevelinner ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Tesslevelouter ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Tileapronsizeqcom ->
                  [Capability.Tileshadingqcom] |> Capability.Set.of_list
              | Tiledimensionqcom ->
                  [Capability.Tileshadingqcom] |> Capability.Set.of_list
              | Tileoffsetqcom ->
                  [Capability.Tileshadingqcom] |> Capability.Set.of_list
              | Vertexid -> [Capability.Shader] |> Capability.Set.of_list
              | Vertexindex -> [Capability.Shader] |> Capability.Set.of_list
              | Viewindex -> [Capability.Multiview] |> Capability.Set.of_list
              | Viewportindex ->
                  [Capability.Multiviewport;
                  Capability.Shaderviewportindex;
                  Capability.Shaderviewportindexlayerext;
                  Capability.Meshshadingnv;
                  Capability.Meshshadingext] |> Capability.Set.of_list
              | Viewportmasknv ->
                  [Capability.Shaderviewportmasknv; Capability.Meshshadingnv]
                    |> Capability.Set.of_list
              | Viewportmaskperviewnv ->
                  [Capability.Perviewattributesnv; Capability.Meshshadingnv]
                    |> Capability.Set.of_list
              | Warpidarm ->
                  [Capability.Corebuiltinsarm] |> Capability.Set.of_list
              | Warpidnv ->
                  [Capability.Shadersmbuiltinsnv] |> Capability.Set.of_list
              | Warpmaxidarm ->
                  [Capability.Corebuiltinsarm] |> Capability.Set.of_list
              | Warpspersmnv ->
                  [Capability.Shadersmbuiltinsnv] |> Capability.Set.of_list
              | Workdim -> [Capability.Kernel] |> Capability.Set.of_list
              | Workgroupid -> [] |> Capability.Set.of_list
              | Workgroupsize -> [] |> Capability.Set.of_list
              | Worldraydirectionkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Worldrayoriginkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Worldtoobjectkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
          end
        module Componenttype =
          struct
            type t =
              | Float16nv 
              | Float32nv 
              | Float64nv 
              | Floate4m3nv 
              | Floate5m2nv 
              | Signedint16nv 
              | Signedint32nv 
              | Signedint64nv 
              | Signedint8nv 
              | Signedint8packednv 
              | Unsignedint16nv 
              | Unsignedint32nv 
              | Unsignedint64nv 
              | Unsignedint8nv 
              | Unsignedint8packednv [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Float16nv -> [0l]
              | Float32nv -> [1l]
              | Float64nv -> [2l]
              | Floate4m3nv -> [1000491002l]
              | Floate5m2nv -> [1000491003l]
              | Signedint16nv -> [4l]
              | Signedint32nv -> [5l]
              | Signedint64nv -> [6l]
              | Signedint8nv -> [3l]
              | Signedint8packednv -> [1000491000l]
              | Unsignedint16nv -> [8l]
              | Unsignedint32nv -> [9l]
              | Unsignedint64nv -> [10l]
              | Unsignedint8nv -> [7l]
              | Unsignedint8packednv -> [1000491001l]
            let any_required_version =
              function
              | Float16nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float32nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float64nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Floate4m3nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Floate5m2nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedint16nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedint32nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedint64nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedint8nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedint8packednv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint16nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint32nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint64nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint8nv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint8packednv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Float16nv -> [] |> Requirements.Extension.Set.of_list
              | Float32nv -> [] |> Requirements.Extension.Set.of_list
              | Float64nv -> [] |> Requirements.Extension.Set.of_list
              | Floate4m3nv -> [] |> Requirements.Extension.Set.of_list
              | Floate5m2nv -> [] |> Requirements.Extension.Set.of_list
              | Signedint16nv -> [] |> Requirements.Extension.Set.of_list
              | Signedint32nv -> [] |> Requirements.Extension.Set.of_list
              | Signedint64nv -> [] |> Requirements.Extension.Set.of_list
              | Signedint8nv -> [] |> Requirements.Extension.Set.of_list
              | Signedint8packednv ->
                  [] |> Requirements.Extension.Set.of_list
              | Unsignedint16nv -> [] |> Requirements.Extension.Set.of_list
              | Unsignedint32nv -> [] |> Requirements.Extension.Set.of_list
              | Unsignedint64nv -> [] |> Requirements.Extension.Set.of_list
              | Unsignedint8nv -> [] |> Requirements.Extension.Set.of_list
              | Unsignedint8packednv ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Float16nv -> [] |> Capability.Set.of_list
              | Float32nv -> [] |> Capability.Set.of_list
              | Float64nv -> [] |> Capability.Set.of_list
              | Floate4m3nv -> [] |> Capability.Set.of_list
              | Floate5m2nv -> [] |> Capability.Set.of_list
              | Signedint16nv -> [] |> Capability.Set.of_list
              | Signedint32nv -> [] |> Capability.Set.of_list
              | Signedint64nv -> [] |> Capability.Set.of_list
              | Signedint8nv -> [] |> Capability.Set.of_list
              | Signedint8packednv -> [] |> Capability.Set.of_list
              | Unsignedint16nv -> [] |> Capability.Set.of_list
              | Unsignedint32nv -> [] |> Capability.Set.of_list
              | Unsignedint64nv -> [] |> Capability.Set.of_list
              | Unsignedint8nv -> [] |> Capability.Set.of_list
              | Unsignedint8packednv -> [] |> Capability.Set.of_list
          end
        module Cooperativematrixlayout =
          struct
            type t =
              | Columnblockedinterleavedarm 
              | Columnmajorkhr 
              | Rowblockedinterleavedarm 
              | Rowmajorkhr [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Columnblockedinterleavedarm -> [4203l]
              | Columnmajorkhr -> [1l]
              | Rowblockedinterleavedarm -> [4202l]
              | Rowmajorkhr -> [0l]
            let any_required_version =
              function
              | Columnblockedinterleavedarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Columnmajorkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rowblockedinterleavedarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rowmajorkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Columnblockedinterleavedarm ->
                  [] |> Requirements.Extension.Set.of_list
              | Columnmajorkhr -> [] |> Requirements.Extension.Set.of_list
              | Rowblockedinterleavedarm ->
                  [] |> Requirements.Extension.Set.of_list
              | Rowmajorkhr -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Columnblockedinterleavedarm ->
                  [Capability.Cooperativematrixlayoutsarm] |>
                    Capability.Set.of_list
              | Columnmajorkhr -> [] |> Capability.Set.of_list
              | Rowblockedinterleavedarm ->
                  [Capability.Cooperativematrixlayoutsarm] |>
                    Capability.Set.of_list
              | Rowmajorkhr -> [] |> Capability.Set.of_list
          end
        module Cooperativematrixoperands =
          struct
            type t =
              | Matrixasignedcomponentskhr 
              | Matrixbsignedcomponentskhr 
              | Matrixcsignedcomponentskhr 
              | Matrixresultsignedcomponentskhr 
              | Nonekhr 
              | Saturatingaccumulationkhr [@@deriving
                                            compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Matrixasignedcomponentskhr -> [1l]
              | Matrixbsignedcomponentskhr -> [2l]
              | Matrixcsignedcomponentskhr -> [4l]
              | Matrixresultsignedcomponentskhr -> [8l]
              | Nonekhr -> [0l]
              | Saturatingaccumulationkhr -> [16l]
            let any_required_version =
              function
              | Matrixasignedcomponentskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixbsignedcomponentskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixcsignedcomponentskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixresultsignedcomponentskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Saturatingaccumulationkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Matrixasignedcomponentskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixbsignedcomponentskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixcsignedcomponentskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixresultsignedcomponentskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Nonekhr -> [] |> Requirements.Extension.Set.of_list
              | Saturatingaccumulationkhr ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Matrixasignedcomponentskhr -> [] |> Capability.Set.of_list
              | Matrixbsignedcomponentskhr -> [] |> Capability.Set.of_list
              | Matrixcsignedcomponentskhr -> [] |> Capability.Set.of_list
              | Matrixresultsignedcomponentskhr ->
                  [] |> Capability.Set.of_list
              | Nonekhr -> [] |> Capability.Set.of_list
              | Saturatingaccumulationkhr -> [] |> Capability.Set.of_list
          end
        module Cooperativematrixreduce =
          struct
            type t =
              | Column 
              | Row 
              | V2x2 [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function | Column -> [2l] | Row -> [1l] | V2x2 -> [4l]
            let any_required_version =
              function
              | Column ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Row ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | V2x2 ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Column -> [] |> Requirements.Extension.Set.of_list
              | Row -> [] |> Requirements.Extension.Set.of_list
              | V2x2 -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Column -> [] |> Capability.Set.of_list
              | Row -> [] |> Capability.Set.of_list
              | V2x2 -> [] |> Capability.Set.of_list
          end
        module Cooperativematrixuse =
          struct
            type t =
              | Matrixaccumulatorkhr 
              | Matrixakhr 
              | Matrixbkhr [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Matrixaccumulatorkhr -> [2l]
              | Matrixakhr -> [0l]
              | Matrixbkhr -> [1l]
            let any_required_version =
              function
              | Matrixaccumulatorkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixakhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixbkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Matrixaccumulatorkhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixakhr -> [] |> Requirements.Extension.Set.of_list
              | Matrixbkhr -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Matrixaccumulatorkhr -> [] |> Capability.Set.of_list
              | Matrixakhr -> [] |> Capability.Set.of_list
              | Matrixbkhr -> [] |> Capability.Set.of_list
          end
        module Cooperativevectormatrixlayout =
          struct
            type t =
              | Columnmajornv 
              | Inferencingoptimalnv 
              | Rowmajornv 
              | Trainingoptimalnv [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Columnmajornv -> [1l]
              | Inferencingoptimalnv -> [2l]
              | Rowmajornv -> [0l]
              | Trainingoptimalnv -> [3l]
            let any_required_version =
              function
              | Columnmajornv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inferencingoptimalnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rowmajornv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Trainingoptimalnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Columnmajornv -> [] |> Requirements.Extension.Set.of_list
              | Inferencingoptimalnv ->
                  [] |> Requirements.Extension.Set.of_list
              | Rowmajornv -> [] |> Requirements.Extension.Set.of_list
              | Trainingoptimalnv -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Columnmajornv -> [] |> Capability.Set.of_list
              | Inferencingoptimalnv -> [] |> Capability.Set.of_list
              | Rowmajornv -> [] |> Capability.Set.of_list
              | Trainingoptimalnv -> [] |> Capability.Set.of_list
          end
        module Decoration =
          struct
            type t =
              | Aliased 
              | Aliasedpointer 
              | Aliasscopeintel 
              | Alignment 
              | Alignmentid 
              | Arraystride 
              | Bankbitsaltera 
              | Bankwidthaltera 
              | Binding 
              | Bindlessimagenv 
              | Bindlesssamplernv 
              | Block 
              | Blockmatchsamplerqcom 
              | Blockmatchtextureqcom 
              | Boundimagenv 
              | Boundsamplernv 
              | Bufferblock 
              | Bufferlocationaltera 
              | Builtin 
              | Burstcoalescealtera 
              | Cachecontrolloadintel 
              | Cachecontrolstoreintel 
              | Cachesizealtera 
              | Centroid 
              | Clobberintel 
              | Coherent 
              | Colmajor 
              | Component 
              | Conditionalintel 
              | Conduitkernelargumentaltera 
              | Constant 
              | Counterbuffer 
              | Cpacked 
              | Descriptorset 
              | Dontstaticallycoalescealtera 
              | Doublepumpaltera 
              | Explicitinterpamd 
              | Flat 
              | Forcepow2depthaltera 
              | Fpfastmathmode 
              | Fpmaxerrordecorationintel 
              | Fproundingmode 
              | Funcparamattr 
              | Funcparamiokindintel 
              | Functiondenormmodeintel 
              | Functionfloatingpointmodeintel 
              | Functionroundingmodeintel 
              | Fuseloopsinfunctionaltera 
              | Globalvariableoffsetintel 
              | Glslpacked 
              | Glslshared 
              | Hitobjectshaderrecordbufferext 
              | Hitobjectshaderrecordbuffernv 
              | Hostaccessintel 
              | Implementinregistermapaltera 
              | Index 
              | Initiationintervalaltera 
              | Initmodealtera 
              | Inputattachmentindex 
              | Invariant 
              | Iopipestoragealtera 
              | Latencycontrolconstraintaltera 
              | Latencycontrollabelaltera 
              | Linkageattributes 
              | Location 
              | Mathopdspmodealtera 
              | Matrixstride 
              | Maxbyteoffset 
              | Maxbyteoffsetid 
              | Maxconcurrencyaltera 
              | Maxprivatecopiesaltera 
              | Maxreplicatesaltera 
              | Mediablockiointel 
              | Memoryaltera 
              | Mergealtera 
              | Mmhostinterfaceaddresswidthaltera 
              | Mmhostinterfacedatawidthaltera 
              | Mmhostinterfacelatencyaltera 
              | Mmhostinterfacemaxburstaltera 
              | Mmhostinterfacereadwritemodealtera 
              | Mmhostinterfacewaitrequestaltera 
              | Noaliasintel 
              | Nocontraction 
              | Nodemaxpayloadsamdx 
              | Nodesharespayloadlimitswithamdx 
              | Nonreadable 
              | Nonuniform 
              | Nonwritable 
              | Noperspective 
              | Nosignedwrap 
              | Nounsignedwrap 
              | Numbanksaltera 
              | Offset 
              | Overridecoveragenv 
              | Passthroughnv 
              | Patch 
              | Payloaddispatchindirectamdx 
              | Payloadnodearraysizeamdx 
              | Payloadnodebaseindexamdx 
              | Payloadnodenameamdx 
              | Payloadnodesparsearrayamdx 
              | Perprimitiveext 
              | Pertasknv 
              | Pervertexkhr 
              | Perviewnv 
              | Pipelineenablealtera 
              | Prefetchaltera 
              | Referencedindirectlyintel 
              | Registeraltera 
              | Registermapkernelargumentaltera 
              | Relaxedprecision 
              | Restrict 
              | Restrictpointer 
              | Rowmajor 
              | Sample 
              | Saturatedconversion 
              | Saturatedtolargestfloat8normalconversionext 
              | Secondaryviewportrelativenv 
              | Sideeffectsintel 
              | Simpledualportaltera 
              | Simtcallintel 
              | Singleelementvectorintel 
              | Singlepumpaltera 
              | Specid 
              | Stablekernelargumentaltera 
              | Stackcallintel 
              | Stallenablealtera 
              | Stallfreealtera 
              | Stream 
              | Stridesizealtera 
              | Trackfinishwritingamdx 
              | Truedualportaltera 
              | Uniform 
              | Uniformid 
              | Usersemantic 
              | Usertypegoogle 
              | Vectorcomputecallablefunctionintel 
              | Vectorcomputefunctionintel 
              | Vectorcomputevariableintel 
              | Viewportrelativenv 
              | Volatile 
              | Weighttextureqcom 
              | Wordsizealtera 
              | Xfbbuffer 
              | Xfbstride [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Aliased -> [20l]
              | Aliasedpointer -> [5356l]
              | Aliasscopeintel -> [5914l]
              | Alignment -> [44l]
              | Alignmentid -> [46l]
              | Arraystride -> [6l]
              | Bankbitsaltera -> [5835l]
              | Bankwidthaltera -> [5828l]
              | Binding -> [33l]
              | Bindlessimagenv -> [5399l]
              | Bindlesssamplernv -> [5398l]
              | Block -> [2l]
              | Blockmatchsamplerqcom -> [4499l]
              | Blockmatchtextureqcom -> [4488l]
              | Boundimagenv -> [5401l]
              | Boundsamplernv -> [5400l]
              | Bufferblock -> [3l]
              | Bufferlocationaltera -> [5921l]
              | Builtin -> [11l]
              | Burstcoalescealtera -> [5899l]
              | Cachecontrolloadintel -> [6442l]
              | Cachecontrolstoreintel -> [6443l]
              | Cachesizealtera -> [5900l]
              | Centroid -> [16l]
              | Clobberintel -> [5607l]
              | Coherent -> [23l]
              | Colmajor -> [5l]
              | Component -> [31l]
              | Conditionalintel -> [6247l]
              | Conduitkernelargumentaltera -> [6175l]
              | Constant -> [22l]
              | Counterbuffer -> [5634l]
              | Cpacked -> [10l]
              | Descriptorset -> [34l]
              | Dontstaticallycoalescealtera -> [5901l]
              | Doublepumpaltera -> [5831l]
              | Explicitinterpamd -> [4999l]
              | Flat -> [14l]
              | Forcepow2depthaltera -> [5836l]
              | Fpfastmathmode -> [40l]
              | Fpmaxerrordecorationintel -> [6170l]
              | Fproundingmode -> [39l]
              | Funcparamattr -> [38l]
              | Funcparamiokindintel -> [5625l]
              | Functiondenormmodeintel -> [5823l]
              | Functionfloatingpointmodeintel -> [6080l]
              | Functionroundingmodeintel -> [5822l]
              | Fuseloopsinfunctionaltera -> [5907l]
              | Globalvariableoffsetintel -> [5628l]
              | Glslpacked -> [9l]
              | Glslshared -> [8l]
              | Hitobjectshaderrecordbufferext -> [5389l]
              | Hitobjectshaderrecordbuffernv -> [5386l]
              | Hostaccessintel -> [6188l]
              | Implementinregistermapaltera -> [6191l]
              | Index -> [32l]
              | Initiationintervalaltera -> [5917l]
              | Initmodealtera -> [6190l]
              | Inputattachmentindex -> [43l]
              | Invariant -> [18l]
              | Iopipestoragealtera -> [5944l]
              | Latencycontrolconstraintaltera -> [6173l]
              | Latencycontrollabelaltera -> [6172l]
              | Linkageattributes -> [41l]
              | Location -> [30l]
              | Mathopdspmodealtera -> [5909l]
              | Matrixstride -> [7l]
              | Maxbyteoffset -> [45l]
              | Maxbyteoffsetid -> [47l]
              | Maxconcurrencyaltera -> [5918l]
              | Maxprivatecopiesaltera -> [5829l]
              | Maxreplicatesaltera -> [5832l]
              | Mediablockiointel -> [6140l]
              | Memoryaltera -> [5826l]
              | Mergealtera -> [5834l]
              | Mmhostinterfaceaddresswidthaltera -> [6177l]
              | Mmhostinterfacedatawidthaltera -> [6178l]
              | Mmhostinterfacelatencyaltera -> [6179l]
              | Mmhostinterfacemaxburstaltera -> [6181l]
              | Mmhostinterfacereadwritemodealtera -> [6180l]
              | Mmhostinterfacewaitrequestaltera -> [6182l]
              | Noaliasintel -> [5915l]
              | Nocontraction -> [42l]
              | Nodemaxpayloadsamdx -> [5020l]
              | Nodesharespayloadlimitswithamdx -> [5019l]
              | Nonreadable -> [25l]
              | Nonuniform -> [5300l]
              | Nonwritable -> [24l]
              | Noperspective -> [13l]
              | Nosignedwrap -> [4469l]
              | Nounsignedwrap -> [4470l]
              | Numbanksaltera -> [5827l]
              | Offset -> [35l]
              | Overridecoveragenv -> [5248l]
              | Passthroughnv -> [5250l]
              | Patch -> [15l]
              | Payloaddispatchindirectamdx -> [5105l]
              | Payloadnodearraysizeamdx -> [5100l]
              | Payloadnodebaseindexamdx -> [5098l]
              | Payloadnodenameamdx -> [5091l]
              | Payloadnodesparsearrayamdx -> [5099l]
              | Perprimitiveext -> [5271l]
              | Pertasknv -> [5273l]
              | Pervertexkhr -> [5285l]
              | Perviewnv -> [5272l]
              | Pipelineenablealtera -> [5919l]
              | Prefetchaltera -> [5902l]
              | Referencedindirectlyintel -> [5602l]
              | Registeraltera -> [5825l]
              | Registermapkernelargumentaltera -> [6176l]
              | Relaxedprecision -> [0l]
              | Restrict -> [19l]
              | Restrictpointer -> [5355l]
              | Rowmajor -> [4l]
              | Sample -> [17l]
              | Saturatedconversion -> [28l]
              | Saturatedtolargestfloat8normalconversionext -> [4216l]
              | Secondaryviewportrelativenv -> [5256l]
              | Sideeffectsintel -> [5608l]
              | Simpledualportaltera -> [5833l]
              | Simtcallintel -> [5599l]
              | Singleelementvectorintel -> [6085l]
              | Singlepumpaltera -> [5830l]
              | Specid -> [1l]
              | Stablekernelargumentaltera -> [6183l]
              | Stackcallintel -> [5627l]
              | Stallenablealtera -> [5905l]
              | Stallfreealtera -> [6151l]
              | Stream -> [29l]
              | Stridesizealtera -> [5883l]
              | Trackfinishwritingamdx -> [5078l]
              | Truedualportaltera -> [5885l]
              | Uniform -> [26l]
              | Uniformid -> [27l]
              | Usersemantic -> [5635l]
              | Usertypegoogle -> [5636l]
              | Vectorcomputecallablefunctionintel -> [6087l]
              | Vectorcomputefunctionintel -> [5626l]
              | Vectorcomputevariableintel -> [5624l]
              | Viewportrelativenv -> [5252l]
              | Volatile -> [21l]
              | Weighttextureqcom -> [4487l]
              | Wordsizealtera -> [5884l]
              | Xfbbuffer -> [36l]
              | Xfbstride -> [37l]
            let any_required_version =
              function
              | Aliased ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Aliasedpointer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Aliasscopeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Alignment ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Alignmentid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_2)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Arraystride ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bankbitsaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bankwidthaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Binding ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bindlessimagenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bindlesssamplernv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Block ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Blockmatchsamplerqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Blockmatchtextureqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Boundimagenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Boundsamplernv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bufferblock ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:(Some V1_3))
                    |> Requirements.Version.Set.of_list
              | Bufferlocationaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Builtin ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Burstcoalescealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cachecontrolloadintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cachecontrolstoreintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cachesizealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Centroid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Clobberintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Coherent ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Colmajor ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Component ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Conditionalintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Conduitkernelargumentaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Constant ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Counterbuffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cpacked ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Descriptorset ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dontstaticallycoalescealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Doublepumpaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Explicitinterpamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Flat ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Forcepow2depthaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpfastmathmode ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpmaxerrordecorationintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fproundingmode ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Funcparamattr ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Funcparamiokindintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Functiondenormmodeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Functionfloatingpointmodeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Functionroundingmodeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fuseloopsinfunctionaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Globalvariableoffsetintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Glslpacked ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Glslshared ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitobjectshaderrecordbufferext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitobjectshaderrecordbuffernv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hostaccessintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Implementinregistermapaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Index ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Initiationintervalaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Initmodealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inputattachmentindex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Invariant ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Iopipestoragealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Latencycontrolconstraintaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Latencycontrollabelaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Linkageattributes ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Location ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mathopdspmodealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixstride ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxbyteoffset ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxbyteoffsetid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_2)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxconcurrencyaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxprivatecopiesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxreplicatesaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mediablockiointel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Memoryaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mergealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mmhostinterfaceaddresswidthaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mmhostinterfacedatawidthaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mmhostinterfacelatencyaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mmhostinterfacemaxburstaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mmhostinterfacereadwritemodealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Mmhostinterfacewaitrequestaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noaliasintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nocontraction ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nodemaxpayloadsamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nodesharespayloadlimitswithamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonreadable ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonuniform ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonwritable ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noperspective ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nosignedwrap ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nounsignedwrap ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Numbanksaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Offset ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Overridecoveragenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Passthroughnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Patch ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Payloaddispatchindirectamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Payloadnodearraysizeamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Payloadnodebaseindexamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Payloadnodenameamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Payloadnodesparsearrayamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Perprimitiveext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pertasknv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pervertexkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Perviewnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pipelineenablealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Prefetchaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Referencedindirectlyintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Registeraltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Registermapkernelargumentaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Relaxedprecision ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Restrict ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Restrictpointer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rowmajor ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sample ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Saturatedconversion ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Saturatedtolargestfloat8normalconversionext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Secondaryviewportrelativenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sideeffectsintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Simpledualportaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Simtcallintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Singleelementvectorintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Singlepumpaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Specid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stablekernelargumentaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stackcallintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stallenablealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stallfreealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stream ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stridesizealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Trackfinishwritingamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Truedualportaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniform ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Usersemantic ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Usertypegoogle ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vectorcomputecallablefunctionintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vectorcomputefunctionintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vectorcomputevariableintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Viewportrelativenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Volatile ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Weighttextureqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Wordsizealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Xfbbuffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Xfbstride ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Aliased -> [] |> Requirements.Extension.Set.of_list
              | Aliasedpointer ->
                  [Requirements.Extension.Spv_ext_physical_storage_buffer;
                  Requirements.Extension.Spv_khr_physical_storage_buffer] |>
                    Requirements.Extension.Set.of_list
              | Aliasscopeintel -> [] |> Requirements.Extension.Set.of_list
              | Alignment -> [] |> Requirements.Extension.Set.of_list
              | Alignmentid -> [] |> Requirements.Extension.Set.of_list
              | Arraystride -> [] |> Requirements.Extension.Set.of_list
              | Bankbitsaltera -> [] |> Requirements.Extension.Set.of_list
              | Bankwidthaltera -> [] |> Requirements.Extension.Set.of_list
              | Binding -> [] |> Requirements.Extension.Set.of_list
              | Bindlessimagenv -> [] |> Requirements.Extension.Set.of_list
              | Bindlesssamplernv -> [] |> Requirements.Extension.Set.of_list
              | Block -> [] |> Requirements.Extension.Set.of_list
              | Blockmatchsamplerqcom ->
                  [Requirements.Extension.Spv_qcom_image_processing2] |>
                    Requirements.Extension.Set.of_list
              | Blockmatchtextureqcom ->
                  [Requirements.Extension.Spv_qcom_image_processing] |>
                    Requirements.Extension.Set.of_list
              | Boundimagenv -> [] |> Requirements.Extension.Set.of_list
              | Boundsamplernv -> [] |> Requirements.Extension.Set.of_list
              | Bufferblock -> [] |> Requirements.Extension.Set.of_list
              | Bufferlocationaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Builtin -> [] |> Requirements.Extension.Set.of_list
              | Burstcoalescealtera ->
                  [] |> Requirements.Extension.Set.of_list
              | Cachecontrolloadintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Cachecontrolstoreintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Cachesizealtera -> [] |> Requirements.Extension.Set.of_list
              | Centroid -> [] |> Requirements.Extension.Set.of_list
              | Clobberintel -> [] |> Requirements.Extension.Set.of_list
              | Coherent -> [] |> Requirements.Extension.Set.of_list
              | Colmajor -> [] |> Requirements.Extension.Set.of_list
              | Component -> [] |> Requirements.Extension.Set.of_list
              | Conditionalintel -> [] |> Requirements.Extension.Set.of_list
              | Conduitkernelargumentaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Constant -> [] |> Requirements.Extension.Set.of_list
              | Counterbuffer ->
                  [Requirements.Extension.Spv_google_hlsl_functionality1] |>
                    Requirements.Extension.Set.of_list
              | Cpacked -> [] |> Requirements.Extension.Set.of_list
              | Descriptorset -> [] |> Requirements.Extension.Set.of_list
              | Dontstaticallycoalescealtera ->
                  [] |> Requirements.Extension.Set.of_list
              | Doublepumpaltera -> [] |> Requirements.Extension.Set.of_list
              | Explicitinterpamd ->
                  [Requirements.Extension.Spv_amd_shader_explicit_vertex_parameter]
                    |> Requirements.Extension.Set.of_list
              | Flat -> [] |> Requirements.Extension.Set.of_list
              | Forcepow2depthaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Fpfastmathmode -> [] |> Requirements.Extension.Set.of_list
              | Fpmaxerrordecorationintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Fproundingmode -> [] |> Requirements.Extension.Set.of_list
              | Funcparamattr -> [] |> Requirements.Extension.Set.of_list
              | Funcparamiokindintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Functiondenormmodeintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Functionfloatingpointmodeintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Functionroundingmodeintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Fuseloopsinfunctionaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Globalvariableoffsetintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Glslpacked -> [] |> Requirements.Extension.Set.of_list
              | Glslshared -> [] |> Requirements.Extension.Set.of_list
              | Hitobjectshaderrecordbufferext ->
                  [] |> Requirements.Extension.Set.of_list
              | Hitobjectshaderrecordbuffernv ->
                  [] |> Requirements.Extension.Set.of_list
              | Hostaccessintel -> [] |> Requirements.Extension.Set.of_list
              | Implementinregistermapaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Index -> [] |> Requirements.Extension.Set.of_list
              | Initiationintervalaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Initmodealtera -> [] |> Requirements.Extension.Set.of_list
              | Inputattachmentindex ->
                  [] |> Requirements.Extension.Set.of_list
              | Invariant -> [] |> Requirements.Extension.Set.of_list
              | Iopipestoragealtera ->
                  [] |> Requirements.Extension.Set.of_list
              | Latencycontrolconstraintaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Latencycontrollabelaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Linkageattributes -> [] |> Requirements.Extension.Set.of_list
              | Location -> [] |> Requirements.Extension.Set.of_list
              | Mathopdspmodealtera ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixstride -> [] |> Requirements.Extension.Set.of_list
              | Maxbyteoffset -> [] |> Requirements.Extension.Set.of_list
              | Maxbyteoffsetid -> [] |> Requirements.Extension.Set.of_list
              | Maxconcurrencyaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Maxprivatecopiesaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Maxreplicatesaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Mediablockiointel -> [] |> Requirements.Extension.Set.of_list
              | Memoryaltera -> [] |> Requirements.Extension.Set.of_list
              | Mergealtera -> [] |> Requirements.Extension.Set.of_list
              | Mmhostinterfaceaddresswidthaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Mmhostinterfacedatawidthaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Mmhostinterfacelatencyaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Mmhostinterfacemaxburstaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Mmhostinterfacereadwritemodealtera ->
                  [] |> Requirements.Extension.Set.of_list
              | Mmhostinterfacewaitrequestaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Noaliasintel -> [] |> Requirements.Extension.Set.of_list
              | Nocontraction -> [] |> Requirements.Extension.Set.of_list
              | Nodemaxpayloadsamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Nodesharespayloadlimitswithamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Nonreadable -> [] |> Requirements.Extension.Set.of_list
              | Nonuniform ->
                  [Requirements.Extension.Spv_ext_descriptor_indexing] |>
                    Requirements.Extension.Set.of_list
              | Nonwritable -> [] |> Requirements.Extension.Set.of_list
              | Noperspective -> [] |> Requirements.Extension.Set.of_list
              | Nosignedwrap ->
                  [Requirements.Extension.Spv_khr_no_integer_wrap_decoration]
                    |> Requirements.Extension.Set.of_list
              | Nounsignedwrap ->
                  [Requirements.Extension.Spv_khr_no_integer_wrap_decoration]
                    |> Requirements.Extension.Set.of_list
              | Numbanksaltera -> [] |> Requirements.Extension.Set.of_list
              | Offset -> [] |> Requirements.Extension.Set.of_list
              | Overridecoveragenv ->
                  [Requirements.Extension.Spv_nv_sample_mask_override_coverage]
                    |> Requirements.Extension.Set.of_list
              | Passthroughnv ->
                  [Requirements.Extension.Spv_nv_geometry_shader_passthrough]
                    |> Requirements.Extension.Set.of_list
              | Patch -> [] |> Requirements.Extension.Set.of_list
              | Payloaddispatchindirectamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Payloadnodearraysizeamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Payloadnodebaseindexamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Payloadnodenameamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Payloadnodesparsearrayamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Perprimitiveext ->
                  [Requirements.Extension.Spv_nv_mesh_shader;
                  Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Pertasknv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Pervertexkhr ->
                  [Requirements.Extension.Spv_nv_fragment_shader_barycentric;
                  Requirements.Extension.Spv_khr_fragment_shader_barycentric]
                    |> Requirements.Extension.Set.of_list
              | Perviewnv ->
                  [Requirements.Extension.Spv_nv_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Pipelineenablealtera ->
                  [] |> Requirements.Extension.Set.of_list
              | Prefetchaltera -> [] |> Requirements.Extension.Set.of_list
              | Referencedindirectlyintel ->
                  [Requirements.Extension.Spv_intel_function_pointers] |>
                    Requirements.Extension.Set.of_list
              | Registeraltera -> [] |> Requirements.Extension.Set.of_list
              | Registermapkernelargumentaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Relaxedprecision -> [] |> Requirements.Extension.Set.of_list
              | Restrict -> [] |> Requirements.Extension.Set.of_list
              | Restrictpointer ->
                  [Requirements.Extension.Spv_ext_physical_storage_buffer;
                  Requirements.Extension.Spv_khr_physical_storage_buffer] |>
                    Requirements.Extension.Set.of_list
              | Rowmajor -> [] |> Requirements.Extension.Set.of_list
              | Sample -> [] |> Requirements.Extension.Set.of_list
              | Saturatedconversion ->
                  [] |> Requirements.Extension.Set.of_list
              | Saturatedtolargestfloat8normalconversionext ->
                  [] |> Requirements.Extension.Set.of_list
              | Secondaryviewportrelativenv ->
                  [Requirements.Extension.Spv_nv_stereo_view_rendering] |>
                    Requirements.Extension.Set.of_list
              | Sideeffectsintel -> [] |> Requirements.Extension.Set.of_list
              | Simpledualportaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Simtcallintel -> [] |> Requirements.Extension.Set.of_list
              | Singleelementvectorintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Singlepumpaltera -> [] |> Requirements.Extension.Set.of_list
              | Specid -> [] |> Requirements.Extension.Set.of_list
              | Stablekernelargumentaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Stackcallintel -> [] |> Requirements.Extension.Set.of_list
              | Stallenablealtera -> [] |> Requirements.Extension.Set.of_list
              | Stallfreealtera -> [] |> Requirements.Extension.Set.of_list
              | Stream -> [] |> Requirements.Extension.Set.of_list
              | Stridesizealtera -> [] |> Requirements.Extension.Set.of_list
              | Trackfinishwritingamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Truedualportaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Uniform -> [] |> Requirements.Extension.Set.of_list
              | Uniformid -> [] |> Requirements.Extension.Set.of_list
              | Usersemantic ->
                  [Requirements.Extension.Spv_google_hlsl_functionality1] |>
                    Requirements.Extension.Set.of_list
              | Usertypegoogle ->
                  [Requirements.Extension.Spv_google_user_type] |>
                    Requirements.Extension.Set.of_list
              | Vectorcomputecallablefunctionintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Vectorcomputefunctionintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Vectorcomputevariableintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Viewportrelativenv ->
                  [] |> Requirements.Extension.Set.of_list
              | Volatile -> [] |> Requirements.Extension.Set.of_list
              | Weighttextureqcom ->
                  [Requirements.Extension.Spv_qcom_image_processing] |>
                    Requirements.Extension.Set.of_list
              | Wordsizealtera -> [] |> Requirements.Extension.Set.of_list
              | Xfbbuffer -> [] |> Requirements.Extension.Set.of_list
              | Xfbstride -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Aliased -> [] |> Capability.Set.of_list
              | Aliasedpointer ->
                  [Capability.Physicalstoragebufferaddresses] |>
                    Capability.Set.of_list
              | Aliasscopeintel ->
                  [Capability.Memoryaccessaliasingintel] |>
                    Capability.Set.of_list
              | Alignment -> [Capability.Kernel] |> Capability.Set.of_list
              | Alignmentid -> [Capability.Kernel] |> Capability.Set.of_list
              | Arraystride -> [Capability.Shader] |> Capability.Set.of_list
              | Bankbitsaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Bankwidthaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Binding -> [Capability.Shader] |> Capability.Set.of_list
              | Bindlessimagenv ->
                  [Capability.Bindlesstexturenv] |> Capability.Set.of_list
              | Bindlesssamplernv ->
                  [Capability.Bindlesstexturenv] |> Capability.Set.of_list
              | Block -> [Capability.Shader] |> Capability.Set.of_list
              | Blockmatchsamplerqcom -> [] |> Capability.Set.of_list
              | Blockmatchtextureqcom -> [] |> Capability.Set.of_list
              | Boundimagenv ->
                  [Capability.Bindlesstexturenv] |> Capability.Set.of_list
              | Boundsamplernv ->
                  [Capability.Bindlesstexturenv] |> Capability.Set.of_list
              | Bufferblock -> [Capability.Shader] |> Capability.Set.of_list
              | Bufferlocationaltera ->
                  [Capability.Fpgabufferlocationaltera] |>
                    Capability.Set.of_list
              | Builtin -> [] |> Capability.Set.of_list
              | Burstcoalescealtera ->
                  [Capability.Fpgamemoryaccessesaltera] |>
                    Capability.Set.of_list
              | Cachecontrolloadintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Cachecontrolstoreintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Cachesizealtera ->
                  [Capability.Fpgamemoryaccessesaltera] |>
                    Capability.Set.of_list
              | Centroid -> [Capability.Shader] |> Capability.Set.of_list
              | Clobberintel ->
                  [Capability.Asmintel] |> Capability.Set.of_list
              | Coherent -> [] |> Capability.Set.of_list
              | Colmajor -> [Capability.Matrix] |> Capability.Set.of_list
              | Component -> [Capability.Shader] |> Capability.Set.of_list
              | Conditionalintel ->
                  [Capability.Specconditionalintel] |> Capability.Set.of_list
              | Conduitkernelargumentaltera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Constant -> [Capability.Kernel] |> Capability.Set.of_list
              | Counterbuffer -> [] |> Capability.Set.of_list
              | Cpacked -> [Capability.Kernel] |> Capability.Set.of_list
              | Descriptorset ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Dontstaticallycoalescealtera ->
                  [Capability.Fpgamemoryaccessesaltera] |>
                    Capability.Set.of_list
              | Doublepumpaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Explicitinterpamd -> [] |> Capability.Set.of_list
              | Flat -> [Capability.Shader] |> Capability.Set.of_list
              | Forcepow2depthaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Fpfastmathmode ->
                  [Capability.Kernel; Capability.Floatcontrols2] |>
                    Capability.Set.of_list
              | Fpmaxerrordecorationintel ->
                  [Capability.Fpmaxerrorintel] |> Capability.Set.of_list
              | Fproundingmode -> [] |> Capability.Set.of_list
              | Funcparamattr ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Funcparamiokindintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Functiondenormmodeintel ->
                  [Capability.Functionfloatcontrolintel] |>
                    Capability.Set.of_list
              | Functionfloatingpointmodeintel ->
                  [Capability.Functionfloatcontrolintel] |>
                    Capability.Set.of_list
              | Functionroundingmodeintel ->
                  [Capability.Functionfloatcontrolintel] |>
                    Capability.Set.of_list
              | Fuseloopsinfunctionaltera ->
                  [Capability.Loopfusealtera] |> Capability.Set.of_list
              | Globalvariableoffsetintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Glslpacked -> [Capability.Shader] |> Capability.Set.of_list
              | Glslshared -> [Capability.Shader] |> Capability.Set.of_list
              | Hitobjectshaderrecordbufferext ->
                  [Capability.Shaderinvocationreorderext] |>
                    Capability.Set.of_list
              | Hitobjectshaderrecordbuffernv ->
                  [Capability.Shaderinvocationreordernv] |>
                    Capability.Set.of_list
              | Hostaccessintel ->
                  [Capability.Globalvariablehostaccessintel] |>
                    Capability.Set.of_list
              | Implementinregistermapaltera ->
                  [Capability.Globalvariablefpgadecorationsaltera] |>
                    Capability.Set.of_list
              | Index -> [Capability.Shader] |> Capability.Set.of_list
              | Initiationintervalaltera ->
                  [Capability.Fpgainvocationpipeliningattributesaltera] |>
                    Capability.Set.of_list
              | Initmodealtera ->
                  [Capability.Globalvariablefpgadecorationsaltera] |>
                    Capability.Set.of_list
              | Inputattachmentindex ->
                  [Capability.Inputattachment] |> Capability.Set.of_list
              | Invariant -> [Capability.Shader] |> Capability.Set.of_list
              | Iopipestoragealtera ->
                  [Capability.Iopipesaltera] |> Capability.Set.of_list
              | Latencycontrolconstraintaltera ->
                  [Capability.Fpgalatencycontrolaltera] |>
                    Capability.Set.of_list
              | Latencycontrollabelaltera ->
                  [Capability.Fpgalatencycontrolaltera] |>
                    Capability.Set.of_list
              | Linkageattributes ->
                  [Capability.Linkage] |> Capability.Set.of_list
              | Location -> [Capability.Shader] |> Capability.Set.of_list
              | Mathopdspmodealtera ->
                  [Capability.Fpgadspcontrolaltera] |> Capability.Set.of_list
              | Matrixstride -> [Capability.Matrix] |> Capability.Set.of_list
              | Maxbyteoffset ->
                  [Capability.Addresses] |> Capability.Set.of_list
              | Maxbyteoffsetid ->
                  [Capability.Addresses] |> Capability.Set.of_list
              | Maxconcurrencyaltera ->
                  [Capability.Fpgainvocationpipeliningattributesaltera] |>
                    Capability.Set.of_list
              | Maxprivatecopiesaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Maxreplicatesaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Mediablockiointel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Memoryaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Mergealtera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Mmhostinterfaceaddresswidthaltera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Mmhostinterfacedatawidthaltera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Mmhostinterfacelatencyaltera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Mmhostinterfacemaxburstaltera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Mmhostinterfacereadwritemodealtera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Mmhostinterfacewaitrequestaltera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Noaliasintel ->
                  [Capability.Memoryaccessaliasingintel] |>
                    Capability.Set.of_list
              | Nocontraction ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Nodemaxpayloadsamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Nodesharespayloadlimitswithamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Nonreadable -> [] |> Capability.Set.of_list
              | Nonuniform ->
                  [Capability.Shadernonuniform] |> Capability.Set.of_list
              | Nonwritable -> [] |> Capability.Set.of_list
              | Noperspective ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Nosignedwrap -> [] |> Capability.Set.of_list
              | Nounsignedwrap -> [] |> Capability.Set.of_list
              | Numbanksaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Offset -> [Capability.Shader] |> Capability.Set.of_list
              | Overridecoveragenv ->
                  [Capability.Samplemaskoverridecoveragenv] |>
                    Capability.Set.of_list
              | Passthroughnv ->
                  [Capability.Geometryshaderpassthroughnv] |>
                    Capability.Set.of_list
              | Patch -> [Capability.Tessellation] |> Capability.Set.of_list
              | Payloaddispatchindirectamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Payloadnodearraysizeamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Payloadnodebaseindexamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Payloadnodenameamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Payloadnodesparsearrayamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Perprimitiveext ->
                  [Capability.Meshshadingnv; Capability.Meshshadingext] |>
                    Capability.Set.of_list
              | Pertasknv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Pervertexkhr ->
                  [Capability.Fragmentbarycentrickhr] |>
                    Capability.Set.of_list
              | Perviewnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Pipelineenablealtera ->
                  [Capability.Fpgainvocationpipeliningattributesaltera] |>
                    Capability.Set.of_list
              | Prefetchaltera ->
                  [Capability.Fpgamemoryaccessesaltera] |>
                    Capability.Set.of_list
              | Referencedindirectlyintel ->
                  [Capability.Indirectreferencesintel] |>
                    Capability.Set.of_list
              | Registeraltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Registermapkernelargumentaltera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Relaxedprecision ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Restrict -> [] |> Capability.Set.of_list
              | Restrictpointer ->
                  [Capability.Physicalstoragebufferaddresses] |>
                    Capability.Set.of_list
              | Rowmajor -> [Capability.Matrix] |> Capability.Set.of_list
              | Sample ->
                  [Capability.Samplerateshading] |> Capability.Set.of_list
              | Saturatedconversion ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Saturatedtolargestfloat8normalconversionext ->
                  [Capability.Float8ext] |> Capability.Set.of_list
              | Secondaryviewportrelativenv ->
                  [Capability.Shaderstereoviewnv] |> Capability.Set.of_list
              | Sideeffectsintel ->
                  [Capability.Asmintel] |> Capability.Set.of_list
              | Simpledualportaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Simtcallintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Singleelementvectorintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Singlepumpaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Specid ->
                  [Capability.Shader; Capability.Kernel] |>
                    Capability.Set.of_list
              | Stablekernelargumentaltera ->
                  [Capability.Fpgaargumentinterfacesaltera] |>
                    Capability.Set.of_list
              | Stackcallintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Stallenablealtera ->
                  [Capability.Fpgaclusterattributesaltera] |>
                    Capability.Set.of_list
              | Stallfreealtera ->
                  [Capability.Fpgaclusterattributesv2altera] |>
                    Capability.Set.of_list
              | Stream ->
                  [Capability.Geometrystreams] |> Capability.Set.of_list
              | Stridesizealtera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Trackfinishwritingamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Truedualportaltera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Uniform ->
                  [Capability.Shader; Capability.Uniformdecoration] |>
                    Capability.Set.of_list
              | Uniformid ->
                  [Capability.Shader; Capability.Uniformdecoration] |>
                    Capability.Set.of_list
              | Usersemantic -> [] |> Capability.Set.of_list
              | Usertypegoogle -> [] |> Capability.Set.of_list
              | Vectorcomputecallablefunctionintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Vectorcomputefunctionintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Vectorcomputevariableintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Viewportrelativenv ->
                  [Capability.Shaderviewportmasknv] |> Capability.Set.of_list
              | Volatile -> [] |> Capability.Set.of_list
              | Weighttextureqcom -> [] |> Capability.Set.of_list
              | Wordsizealtera ->
                  [Capability.Fpgamemoryattributesaltera] |>
                    Capability.Set.of_list
              | Xfbbuffer ->
                  [Capability.Transformfeedback] |> Capability.Set.of_list
              | Xfbstride ->
                  [Capability.Transformfeedback] |> Capability.Set.of_list
          end
        module Dim =
          struct
            type t =
              | Buffer 
              | Cube 
              | Rect 
              | Subpassdata 
              | Tileimagedataext 
              | V1d 
              | V2d 
              | V3d [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Buffer -> [5l]
              | Cube -> [3l]
              | Rect -> [4l]
              | Subpassdata -> [6l]
              | Tileimagedataext -> [4173l]
              | V1d -> [0l]
              | V2d -> [1l]
              | V3d -> [2l]
            let any_required_version =
              function
              | Buffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cube ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rect ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subpassdata ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileimagedataext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | V1d ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | V2d ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | V3d ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Buffer -> [] |> Requirements.Extension.Set.of_list
              | Cube -> [] |> Requirements.Extension.Set.of_list
              | Rect -> [] |> Requirements.Extension.Set.of_list
              | Subpassdata -> [] |> Requirements.Extension.Set.of_list
              | Tileimagedataext -> [] |> Requirements.Extension.Set.of_list
              | V1d -> [] |> Requirements.Extension.Set.of_list
              | V2d -> [] |> Requirements.Extension.Set.of_list
              | V3d -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Buffer ->
                  [Capability.Sampledbuffer] |> Capability.Set.of_list
              | Cube -> [Capability.Shader] |> Capability.Set.of_list
              | Rect -> [Capability.Sampledrect] |> Capability.Set.of_list
              | Subpassdata ->
                  [Capability.Inputattachment] |> Capability.Set.of_list
              | Tileimagedataext ->
                  [Capability.Tileimagecolorreadaccessext] |>
                    Capability.Set.of_list
              | V1d -> [Capability.Sampled1d] |> Capability.Set.of_list
              | V2d -> [] |> Capability.Set.of_list
              | V3d -> [] |> Capability.Set.of_list
          end
        module Executionmode =
          struct
            type t =
              | Coalescingamdx 
              | Contractionoff 
              | Denormflushtozero 
              | Denormpreserve 
              | Depthgreater 
              | Depthless 
              | Depthreplacing 
              | Depthunchanged 
              | Derivativegrouplinearkhr 
              | Derivativegroupquadskhr 
              | Earlyandlatefragmenttestsamd 
              | Earlyfragmenttests 
              | Finalizer 
              | Floatingpointmodealtintel 
              | Floatingpointmodeieeeintel 
              | Fpfastmathdefault 
              | Initializer 
              | Inputlines 
              | Inputlinesadjacency 
              | Inputpoints 
              | Inputtrianglesadjacency 
              | Invocations 
              | Isapientryamdx 
              | Isolines 
              | Localsize 
              | Localsizehint 
              | Localsizehintid 
              | Localsizeid 
              | Maximallyreconvergeskhr 
              | Maximumregistersidintel 
              | Maximumregistersintel 
              | Maxnoderecursionamdx 
              | Maxnumworkgroupsamdx 
              | Maxworkdimintel 
              | Maxworkgroupsizeintel 
              | Namedbarriercountintel 
              | Namedmaximumregistersintel 
              | Noglobaloffsetintel 
              | Noncoherentcolorattachmentreadext 
              | Noncoherentdepthattachmentreadext 
              | Noncoherentstencilattachmentreadext 
              | Noncoherenttileattachmentreadqcom 
              | Numsimdworkitemsintel 
              | Originlowerleft 
              | Originupperleft 
              | Outputlinesext 
              | Outputlinestrip 
              | Outputpoints 
              | Outputprimitivesext 
              | Outputtrianglesext 
              | Outputtrianglestrip 
              | Outputvertices 
              | Pixelcenterinteger 
              | Pixelinterlockorderedext 
              | Pixelinterlockunorderedext 
              | Pointmode 
              | Postdepthcoverage 
              | Quadderivativeskhr 
              | Quads 
              | Registermapinterfaceintel 
              | Requirefullquadskhr 
              | Roundingmoderte 
              | Roundingmodertnintel 
              | Roundingmodertpintel 
              | Roundingmodertz 
              | Sampleinterlockorderedext 
              | Sampleinterlockunorderedext 
              | Schedulertargetfmaxmhzintel 
              | Shader64bitindexingext 
              | Shaderindexamdx 
              | Shadingrateinterlockorderedext 
              | Shadingrateinterlockunorderedext 
              | Sharedlocalmemorysizeintel 
              | Sharesinputwithamdx 
              | Signedzeroinfnanpreserve 
              | Spacingequal 
              | Spacingfractionaleven 
              | Spacingfractionalodd 
              | Staticnumworkgroupsamdx 
              | Stencilrefgreaterbackamd 
              | Stencilrefgreaterfrontamd 
              | Stencilreflessbackamd 
              | Stencilreflessfrontamd 
              | Stencilrefreplacingext 
              | Stencilrefunchangedbackamd 
              | Stencilrefunchangedfrontamd 
              | Streaminginterfaceintel 
              | Subgroupsize 
              | Subgroupsperworkgroup 
              | Subgroupsperworkgroupid 
              | Subgroupuniformcontrolflowkhr 
              | Tileshadingrateqcom 
              | Triangles 
              | Vectypehint 
              | Vertexorderccw 
              | Vertexordercw 
              | Xfb [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Coalescingamdx -> [5069l]
              | Contractionoff -> [31l]
              | Denormflushtozero -> [4460l]
              | Denormpreserve -> [4459l]
              | Depthgreater -> [14l]
              | Depthless -> [15l]
              | Depthreplacing -> [12l]
              | Depthunchanged -> [16l]
              | Derivativegrouplinearkhr -> [5290l]
              | Derivativegroupquadskhr -> [5289l]
              | Earlyandlatefragmenttestsamd -> [5017l]
              | Earlyfragmenttests -> [9l]
              | Finalizer -> [34l]
              | Floatingpointmodealtintel -> [5622l]
              | Floatingpointmodeieeeintel -> [5623l]
              | Fpfastmathdefault -> [6028l]
              | Initializer -> [33l]
              | Inputlines -> [20l]
              | Inputlinesadjacency -> [21l]
              | Inputpoints -> [19l]
              | Inputtrianglesadjacency -> [23l]
              | Invocations -> [0l]
              | Isapientryamdx -> [5070l]
              | Isolines -> [25l]
              | Localsize -> [17l]
              | Localsizehint -> [18l]
              | Localsizehintid -> [39l]
              | Localsizeid -> [38l]
              | Maximallyreconvergeskhr -> [6023l]
              | Maximumregistersidintel -> [6462l]
              | Maximumregistersintel -> [6461l]
              | Maxnoderecursionamdx -> [5071l]
              | Maxnumworkgroupsamdx -> [5077l]
              | Maxworkdimintel -> [5894l]
              | Maxworkgroupsizeintel -> [5893l]
              | Namedbarriercountintel -> [6417l]
              | Namedmaximumregistersintel -> [6463l]
              | Noglobaloffsetintel -> [5895l]
              | Noncoherentcolorattachmentreadext -> [4169l]
              | Noncoherentdepthattachmentreadext -> [4170l]
              | Noncoherentstencilattachmentreadext -> [4171l]
              | Noncoherenttileattachmentreadqcom -> [4489l]
              | Numsimdworkitemsintel -> [5896l]
              | Originlowerleft -> [8l]
              | Originupperleft -> [7l]
              | Outputlinesext -> [5269l]
              | Outputlinestrip -> [28l]
              | Outputpoints -> [27l]
              | Outputprimitivesext -> [5270l]
              | Outputtrianglesext -> [5298l]
              | Outputtrianglestrip -> [29l]
              | Outputvertices -> [26l]
              | Pixelcenterinteger -> [6l]
              | Pixelinterlockorderedext -> [5366l]
              | Pixelinterlockunorderedext -> [5367l]
              | Pointmode -> [10l]
              | Postdepthcoverage -> [4446l]
              | Quadderivativeskhr -> [5088l]
              | Quads -> [24l]
              | Registermapinterfaceintel -> [6160l]
              | Requirefullquadskhr -> [5089l]
              | Roundingmoderte -> [4462l]
              | Roundingmodertnintel -> [5621l]
              | Roundingmodertpintel -> [5620l]
              | Roundingmodertz -> [4463l]
              | Sampleinterlockorderedext -> [5368l]
              | Sampleinterlockunorderedext -> [5369l]
              | Schedulertargetfmaxmhzintel -> [5903l]
              | Shader64bitindexingext -> [5427l]
              | Shaderindexamdx -> [5073l]
              | Shadingrateinterlockorderedext -> [5370l]
              | Shadingrateinterlockunorderedext -> [5371l]
              | Sharedlocalmemorysizeintel -> [5618l]
              | Sharesinputwithamdx -> [5102l]
              | Signedzeroinfnanpreserve -> [4461l]
              | Spacingequal -> [1l]
              | Spacingfractionaleven -> [2l]
              | Spacingfractionalodd -> [3l]
              | Staticnumworkgroupsamdx -> [5072l]
              | Stencilrefgreaterbackamd -> [5083l]
              | Stencilrefgreaterfrontamd -> [5080l]
              | Stencilreflessbackamd -> [5084l]
              | Stencilreflessfrontamd -> [5081l]
              | Stencilrefreplacingext -> [5027l]
              | Stencilrefunchangedbackamd -> [5082l]
              | Stencilrefunchangedfrontamd -> [5079l]
              | Streaminginterfaceintel -> [6154l]
              | Subgroupsize -> [35l]
              | Subgroupsperworkgroup -> [36l]
              | Subgroupsperworkgroupid -> [37l]
              | Subgroupuniformcontrolflowkhr -> [4421l]
              | Tileshadingrateqcom -> [4490l]
              | Triangles -> [22l]
              | Vectypehint -> [30l]
              | Vertexorderccw -> [5l]
              | Vertexordercw -> [4l]
              | Xfb -> [11l]
            let any_required_version =
              function
              | Coalescingamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Contractionoff ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Denormflushtozero ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Denormpreserve ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Depthgreater ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Depthless ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Depthreplacing ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Depthunchanged ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Derivativegrouplinearkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Derivativegroupquadskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Earlyandlatefragmenttestsamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Earlyfragmenttests ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Finalizer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Floatingpointmodealtintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Floatingpointmodeieeeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fpfastmathdefault ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Initializer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inputlines ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inputlinesadjacency ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inputpoints ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inputtrianglesadjacency ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Invocations ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Isapientryamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Isolines ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Localsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Localsizehint ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Localsizehintid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_2)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Localsizeid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_2)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maximallyreconvergeskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maximumregistersidintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maximumregistersintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxnoderecursionamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxnumworkgroupsamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxworkdimintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxworkgroupsizeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Namedbarriercountintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Namedmaximumregistersintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noglobaloffsetintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noncoherentcolorattachmentreadext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noncoherentdepthattachmentreadext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noncoherentstencilattachmentreadext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noncoherenttileattachmentreadqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Numsimdworkitemsintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Originlowerleft ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Originupperleft ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outputlinesext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outputlinestrip ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outputpoints ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outputprimitivesext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outputtrianglesext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outputtrianglestrip ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outputvertices ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pixelcenterinteger ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pixelinterlockorderedext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pixelinterlockunorderedext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pointmode ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Postdepthcoverage ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Quadderivativeskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Quads ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Registermapinterfaceintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Requirefullquadskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Roundingmoderte ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Roundingmodertnintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Roundingmodertpintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Roundingmodertz ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampleinterlockorderedext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sampleinterlockunorderedext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Schedulertargetfmaxmhzintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shader64bitindexingext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderindexamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shadingrateinterlockorderedext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shadingrateinterlockunorderedext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sharedlocalmemorysizeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sharesinputwithamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedzeroinfnanpreserve ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Spacingequal ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Spacingfractionaleven ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Spacingfractionalodd ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Staticnumworkgroupsamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stencilrefgreaterbackamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stencilrefgreaterfrontamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stencilreflessbackamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stencilreflessfrontamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stencilrefreplacingext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stencilrefunchangedbackamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Stencilrefunchangedfrontamd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Streaminginterfaceintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupsize ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupsperworkgroup ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupsperworkgroupid ->
                  (Requirements.Version.valid_versions ~required:(Some V1_2)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupuniformcontrolflowkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileshadingrateqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Triangles ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vectypehint ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vertexorderccw ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vertexordercw ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Xfb ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Coalescingamdx -> [] |> Requirements.Extension.Set.of_list
              | Contractionoff -> [] |> Requirements.Extension.Set.of_list
              | Denormflushtozero ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Denormpreserve ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Depthgreater -> [] |> Requirements.Extension.Set.of_list
              | Depthless -> [] |> Requirements.Extension.Set.of_list
              | Depthreplacing -> [] |> Requirements.Extension.Set.of_list
              | Depthunchanged -> [] |> Requirements.Extension.Set.of_list
              | Derivativegrouplinearkhr ->
                  [Requirements.Extension.Spv_nv_compute_shader_derivatives;
                  Requirements.Extension.Spv_khr_compute_shader_derivatives]
                    |> Requirements.Extension.Set.of_list
              | Derivativegroupquadskhr ->
                  [Requirements.Extension.Spv_nv_compute_shader_derivatives;
                  Requirements.Extension.Spv_khr_compute_shader_derivatives]
                    |> Requirements.Extension.Set.of_list
              | Earlyandlatefragmenttestsamd ->
                  [Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests]
                    |> Requirements.Extension.Set.of_list
              | Earlyfragmenttests ->
                  [] |> Requirements.Extension.Set.of_list
              | Finalizer -> [] |> Requirements.Extension.Set.of_list
              | Floatingpointmodealtintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Floatingpointmodeieeeintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Fpfastmathdefault -> [] |> Requirements.Extension.Set.of_list
              | Initializer -> [] |> Requirements.Extension.Set.of_list
              | Inputlines -> [] |> Requirements.Extension.Set.of_list
              | Inputlinesadjacency ->
                  [] |> Requirements.Extension.Set.of_list
              | Inputpoints -> [] |> Requirements.Extension.Set.of_list
              | Inputtrianglesadjacency ->
                  [] |> Requirements.Extension.Set.of_list
              | Invocations -> [] |> Requirements.Extension.Set.of_list
              | Isapientryamdx -> [] |> Requirements.Extension.Set.of_list
              | Isolines -> [] |> Requirements.Extension.Set.of_list
              | Localsize -> [] |> Requirements.Extension.Set.of_list
              | Localsizehint -> [] |> Requirements.Extension.Set.of_list
              | Localsizehintid -> [] |> Requirements.Extension.Set.of_list
              | Localsizeid -> [] |> Requirements.Extension.Set.of_list
              | Maximallyreconvergeskhr ->
                  [Requirements.Extension.Spv_khr_maximal_reconvergence] |>
                    Requirements.Extension.Set.of_list
              | Maximumregistersidintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Maximumregistersintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Maxnoderecursionamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Maxnumworkgroupsamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Maxworkdimintel ->
                  [Requirements.Extension.Spv_intel_kernel_attributes] |>
                    Requirements.Extension.Set.of_list
              | Maxworkgroupsizeintel ->
                  [Requirements.Extension.Spv_intel_kernel_attributes] |>
                    Requirements.Extension.Set.of_list
              | Namedbarriercountintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Namedmaximumregistersintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Noglobaloffsetintel ->
                  [Requirements.Extension.Spv_intel_kernel_attributes] |>
                    Requirements.Extension.Set.of_list
              | Noncoherentcolorattachmentreadext ->
                  [] |> Requirements.Extension.Set.of_list
              | Noncoherentdepthattachmentreadext ->
                  [] |> Requirements.Extension.Set.of_list
              | Noncoherentstencilattachmentreadext ->
                  [] |> Requirements.Extension.Set.of_list
              | Noncoherenttileattachmentreadqcom ->
                  [] |> Requirements.Extension.Set.of_list
              | Numsimdworkitemsintel ->
                  [Requirements.Extension.Spv_intel_kernel_attributes] |>
                    Requirements.Extension.Set.of_list
              | Originlowerleft -> [] |> Requirements.Extension.Set.of_list
              | Originupperleft -> [] |> Requirements.Extension.Set.of_list
              | Outputlinesext ->
                  [Requirements.Extension.Spv_nv_mesh_shader;
                  Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Outputlinestrip -> [] |> Requirements.Extension.Set.of_list
              | Outputpoints -> [] |> Requirements.Extension.Set.of_list
              | Outputprimitivesext ->
                  [Requirements.Extension.Spv_nv_mesh_shader;
                  Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Outputtrianglesext ->
                  [Requirements.Extension.Spv_nv_mesh_shader;
                  Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Outputtrianglestrip ->
                  [] |> Requirements.Extension.Set.of_list
              | Outputvertices -> [] |> Requirements.Extension.Set.of_list
              | Pixelcenterinteger ->
                  [] |> Requirements.Extension.Set.of_list
              | Pixelinterlockorderedext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Pixelinterlockunorderedext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Pointmode -> [] |> Requirements.Extension.Set.of_list
              | Postdepthcoverage ->
                  [Requirements.Extension.Spv_khr_post_depth_coverage] |>
                    Requirements.Extension.Set.of_list
              | Quadderivativeskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Quads -> [] |> Requirements.Extension.Set.of_list
              | Registermapinterfaceintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Requirefullquadskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Roundingmoderte ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Roundingmodertnintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Roundingmodertpintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Roundingmodertz ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Sampleinterlockorderedext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Sampleinterlockunorderedext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Schedulertargetfmaxmhzintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Shader64bitindexingext ->
                  [] |> Requirements.Extension.Set.of_list
              | Shaderindexamdx -> [] |> Requirements.Extension.Set.of_list
              | Shadingrateinterlockorderedext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Shadingrateinterlockunorderedext ->
                  [Requirements.Extension.Spv_ext_fragment_shader_interlock]
                    |> Requirements.Extension.Set.of_list
              | Sharedlocalmemorysizeintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Sharesinputwithamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Signedzeroinfnanpreserve ->
                  [Requirements.Extension.Spv_khr_float_controls] |>
                    Requirements.Extension.Set.of_list
              | Spacingequal -> [] |> Requirements.Extension.Set.of_list
              | Spacingfractionaleven ->
                  [] |> Requirements.Extension.Set.of_list
              | Spacingfractionalodd ->
                  [] |> Requirements.Extension.Set.of_list
              | Staticnumworkgroupsamdx ->
                  [] |> Requirements.Extension.Set.of_list
              | Stencilrefgreaterbackamd ->
                  [Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                  Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Stencilrefgreaterfrontamd ->
                  [Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                  Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Stencilreflessbackamd ->
                  [Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                  Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Stencilreflessfrontamd ->
                  [Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                  Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Stencilrefreplacingext ->
                  [Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Stencilrefunchangedbackamd ->
                  [Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                  Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Stencilrefunchangedfrontamd ->
                  [Requirements.Extension.Spv_amd_shader_early_and_late_fragment_tests;
                  Requirements.Extension.Spv_ext_shader_stencil_export] |>
                    Requirements.Extension.Set.of_list
              | Streaminginterfaceintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Subgroupsize -> [] |> Requirements.Extension.Set.of_list
              | Subgroupsperworkgroup ->
                  [] |> Requirements.Extension.Set.of_list
              | Subgroupsperworkgroupid ->
                  [] |> Requirements.Extension.Set.of_list
              | Subgroupuniformcontrolflowkhr ->
                  [Requirements.Extension.Spv_khr_subgroup_uniform_control_flow]
                    |> Requirements.Extension.Set.of_list
              | Tileshadingrateqcom ->
                  [] |> Requirements.Extension.Set.of_list
              | Triangles -> [] |> Requirements.Extension.Set.of_list
              | Vectypehint -> [] |> Requirements.Extension.Set.of_list
              | Vertexorderccw -> [] |> Requirements.Extension.Set.of_list
              | Vertexordercw -> [] |> Requirements.Extension.Set.of_list
              | Xfb -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Coalescingamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Contractionoff ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Denormflushtozero ->
                  [Capability.Denormflushtozero] |> Capability.Set.of_list
              | Denormpreserve ->
                  [Capability.Denormpreserve] |> Capability.Set.of_list
              | Depthgreater -> [Capability.Shader] |> Capability.Set.of_list
              | Depthless -> [Capability.Shader] |> Capability.Set.of_list
              | Depthreplacing ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Depthunchanged ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Derivativegrouplinearkhr ->
                  [Capability.Computederivativegrouplinearkhr] |>
                    Capability.Set.of_list
              | Derivativegroupquadskhr ->
                  [Capability.Computederivativegroupquadskhr] |>
                    Capability.Set.of_list
              | Earlyandlatefragmenttestsamd ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Earlyfragmenttests ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Finalizer -> [Capability.Kernel] |> Capability.Set.of_list
              | Floatingpointmodealtintel ->
                  [Capability.Roundtoinfinityintel] |> Capability.Set.of_list
              | Floatingpointmodeieeeintel ->
                  [Capability.Roundtoinfinityintel] |> Capability.Set.of_list
              | Fpfastmathdefault ->
                  [Capability.Floatcontrols2] |> Capability.Set.of_list
              | Initializer -> [Capability.Kernel] |> Capability.Set.of_list
              | Inputlines -> [Capability.Geometry] |> Capability.Set.of_list
              | Inputlinesadjacency ->
                  [Capability.Geometry] |> Capability.Set.of_list
              | Inputpoints ->
                  [Capability.Geometry] |> Capability.Set.of_list
              | Inputtrianglesadjacency ->
                  [Capability.Geometry] |> Capability.Set.of_list
              | Invocations ->
                  [Capability.Geometry] |> Capability.Set.of_list
              | Isapientryamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Isolines ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Localsize -> [] |> Capability.Set.of_list
              | Localsizehint ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Localsizehintid ->
                  [Capability.Kernel] |> Capability.Set.of_list
              | Localsizeid -> [] |> Capability.Set.of_list
              | Maximallyreconvergeskhr ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Maximumregistersidintel ->
                  [Capability.Registerlimitsintel] |> Capability.Set.of_list
              | Maximumregistersintel ->
                  [Capability.Registerlimitsintel] |> Capability.Set.of_list
              | Maxnoderecursionamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Maxnumworkgroupsamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Maxworkdimintel ->
                  [Capability.Kernelattributesintel] |>
                    Capability.Set.of_list
              | Maxworkgroupsizeintel ->
                  [Capability.Kernelattributesintel] |>
                    Capability.Set.of_list
              | Namedbarriercountintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Namedmaximumregistersintel ->
                  [Capability.Registerlimitsintel] |> Capability.Set.of_list
              | Noglobaloffsetintel ->
                  [Capability.Kernelattributesintel] |>
                    Capability.Set.of_list
              | Noncoherentcolorattachmentreadext ->
                  [Capability.Tileimagecolorreadaccessext] |>
                    Capability.Set.of_list
              | Noncoherentdepthattachmentreadext ->
                  [Capability.Tileimagedepthreadaccessext] |>
                    Capability.Set.of_list
              | Noncoherentstencilattachmentreadext ->
                  [Capability.Tileimagestencilreadaccessext] |>
                    Capability.Set.of_list
              | Noncoherenttileattachmentreadqcom ->
                  [Capability.Tileshadingqcom] |> Capability.Set.of_list
              | Numsimdworkitemsintel ->
                  [Capability.Fpgakernelattributesintel] |>
                    Capability.Set.of_list
              | Originlowerleft ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Originupperleft ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Outputlinesext ->
                  [Capability.Meshshadingnv; Capability.Meshshadingext] |>
                    Capability.Set.of_list
              | Outputlinestrip ->
                  [Capability.Geometry] |> Capability.Set.of_list
              | Outputpoints ->
                  [Capability.Geometry;
                  Capability.Meshshadingnv;
                  Capability.Meshshadingext] |> Capability.Set.of_list
              | Outputprimitivesext ->
                  [Capability.Meshshadingnv; Capability.Meshshadingext] |>
                    Capability.Set.of_list
              | Outputtrianglesext ->
                  [Capability.Meshshadingnv; Capability.Meshshadingext] |>
                    Capability.Set.of_list
              | Outputtrianglestrip ->
                  [Capability.Geometry] |> Capability.Set.of_list
              | Outputvertices ->
                  [Capability.Geometry;
                  Capability.Tessellation;
                  Capability.Meshshadingnv;
                  Capability.Meshshadingext] |> Capability.Set.of_list
              | Pixelcenterinteger ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Pixelinterlockorderedext ->
                  [Capability.Fragmentshaderpixelinterlockext] |>
                    Capability.Set.of_list
              | Pixelinterlockunorderedext ->
                  [Capability.Fragmentshaderpixelinterlockext] |>
                    Capability.Set.of_list
              | Pointmode ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Postdepthcoverage ->
                  [Capability.Samplemaskpostdepthcoverage] |>
                    Capability.Set.of_list
              | Quadderivativeskhr ->
                  [Capability.Quadcontrolkhr] |> Capability.Set.of_list
              | Quads -> [Capability.Tessellation] |> Capability.Set.of_list
              | Registermapinterfaceintel ->
                  [Capability.Fpgakernelattributesv2intel] |>
                    Capability.Set.of_list
              | Requirefullquadskhr ->
                  [Capability.Quadcontrolkhr] |> Capability.Set.of_list
              | Roundingmoderte ->
                  [Capability.Roundingmoderte] |> Capability.Set.of_list
              | Roundingmodertnintel ->
                  [Capability.Roundtoinfinityintel] |> Capability.Set.of_list
              | Roundingmodertpintel ->
                  [Capability.Roundtoinfinityintel] |> Capability.Set.of_list
              | Roundingmodertz ->
                  [Capability.Roundingmodertz] |> Capability.Set.of_list
              | Sampleinterlockorderedext ->
                  [Capability.Fragmentshadersampleinterlockext] |>
                    Capability.Set.of_list
              | Sampleinterlockunorderedext ->
                  [Capability.Fragmentshadersampleinterlockext] |>
                    Capability.Set.of_list
              | Schedulertargetfmaxmhzintel ->
                  [Capability.Fpgakernelattributesintel] |>
                    Capability.Set.of_list
              | Shader64bitindexingext ->
                  [Capability.Shader64bitindexingext] |>
                    Capability.Set.of_list
              | Shaderindexamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Shadingrateinterlockorderedext ->
                  [Capability.Fragmentshadershadingrateinterlockext] |>
                    Capability.Set.of_list
              | Shadingrateinterlockunorderedext ->
                  [Capability.Fragmentshadershadingrateinterlockext] |>
                    Capability.Set.of_list
              | Sharedlocalmemorysizeintel ->
                  [Capability.Vectorcomputeintel] |> Capability.Set.of_list
              | Sharesinputwithamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Signedzeroinfnanpreserve ->
                  [Capability.Signedzeroinfnanpreserve] |>
                    Capability.Set.of_list
              | Spacingequal ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Spacingfractionaleven ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Spacingfractionalodd ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Staticnumworkgroupsamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Stencilrefgreaterbackamd ->
                  [Capability.Stencilexportext] |> Capability.Set.of_list
              | Stencilrefgreaterfrontamd ->
                  [Capability.Stencilexportext] |> Capability.Set.of_list
              | Stencilreflessbackamd ->
                  [Capability.Stencilexportext] |> Capability.Set.of_list
              | Stencilreflessfrontamd ->
                  [Capability.Stencilexportext] |> Capability.Set.of_list
              | Stencilrefreplacingext ->
                  [Capability.Stencilexportext] |> Capability.Set.of_list
              | Stencilrefunchangedbackamd ->
                  [Capability.Stencilexportext] |> Capability.Set.of_list
              | Stencilrefunchangedfrontamd ->
                  [Capability.Stencilexportext] |> Capability.Set.of_list
              | Streaminginterfaceintel ->
                  [Capability.Fpgakernelattributesintel] |>
                    Capability.Set.of_list
              | Subgroupsize ->
                  [Capability.Subgroupdispatch] |> Capability.Set.of_list
              | Subgroupsperworkgroup ->
                  [Capability.Subgroupdispatch] |> Capability.Set.of_list
              | Subgroupsperworkgroupid ->
                  [Capability.Subgroupdispatch] |> Capability.Set.of_list
              | Subgroupuniformcontrolflowkhr ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Tileshadingrateqcom ->
                  [Capability.Tileshadingqcom] |> Capability.Set.of_list
              | Triangles ->
                  [Capability.Geometry; Capability.Tessellation] |>
                    Capability.Set.of_list
              | Vectypehint -> [Capability.Kernel] |> Capability.Set.of_list
              | Vertexorderccw ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Vertexordercw ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Xfb ->
                  [Capability.Transformfeedback] |> Capability.Set.of_list
          end
        module Executionmodel =
          struct
            type t =
              | Anyhitkhr 
              | Callablekhr 
              | Closesthitkhr 
              | Fragment 
              | Geometry 
              | Glcompute 
              | Intersectionkhr 
              | Kernel 
              | Meshext 
              | Meshnv 
              | Misskhr 
              | Raygenerationkhr 
              | Taskext 
              | Tasknv 
              | Tessellationcontrol 
              | Tessellationevaluation 
              | Vertex [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Anyhitkhr -> [5315l]
              | Callablekhr -> [5318l]
              | Closesthitkhr -> [5316l]
              | Fragment -> [4l]
              | Geometry -> [3l]
              | Glcompute -> [5l]
              | Intersectionkhr -> [5314l]
              | Kernel -> [6l]
              | Meshext -> [5365l]
              | Meshnv -> [5268l]
              | Misskhr -> [5317l]
              | Raygenerationkhr -> [5313l]
              | Taskext -> [5364l]
              | Tasknv -> [5267l]
              | Tessellationcontrol -> [1l]
              | Tessellationevaluation -> [2l]
              | Vertex -> [0l]
            let any_required_version =
              function
              | Anyhitkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Callablekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Closesthitkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fragment ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Geometry ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Glcompute ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Intersectionkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Kernel ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Meshext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Meshnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Misskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raygenerationkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Taskext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tasknv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tessellationcontrol ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tessellationevaluation ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vertex ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Anyhitkhr -> [] |> Requirements.Extension.Set.of_list
              | Callablekhr -> [] |> Requirements.Extension.Set.of_list
              | Closesthitkhr -> [] |> Requirements.Extension.Set.of_list
              | Fragment -> [] |> Requirements.Extension.Set.of_list
              | Geometry -> [] |> Requirements.Extension.Set.of_list
              | Glcompute -> [] |> Requirements.Extension.Set.of_list
              | Intersectionkhr -> [] |> Requirements.Extension.Set.of_list
              | Kernel -> [] |> Requirements.Extension.Set.of_list
              | Meshext -> [] |> Requirements.Extension.Set.of_list
              | Meshnv -> [] |> Requirements.Extension.Set.of_list
              | Misskhr -> [] |> Requirements.Extension.Set.of_list
              | Raygenerationkhr -> [] |> Requirements.Extension.Set.of_list
              | Taskext -> [] |> Requirements.Extension.Set.of_list
              | Tasknv -> [] |> Requirements.Extension.Set.of_list
              | Tessellationcontrol ->
                  [] |> Requirements.Extension.Set.of_list
              | Tessellationevaluation ->
                  [] |> Requirements.Extension.Set.of_list
              | Vertex -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Anyhitkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Callablekhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Closesthitkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Fragment -> [Capability.Shader] |> Capability.Set.of_list
              | Geometry -> [Capability.Geometry] |> Capability.Set.of_list
              | Glcompute -> [Capability.Shader] |> Capability.Set.of_list
              | Intersectionkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Kernel -> [Capability.Kernel] |> Capability.Set.of_list
              | Meshext ->
                  [Capability.Meshshadingext] |> Capability.Set.of_list
              | Meshnv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Misskhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Raygenerationkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Taskext ->
                  [Capability.Meshshadingext] |> Capability.Set.of_list
              | Tasknv ->
                  [Capability.Meshshadingnv] |> Capability.Set.of_list
              | Tessellationcontrol ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Tessellationevaluation ->
                  [Capability.Tessellation] |> Capability.Set.of_list
              | Vertex -> [Capability.Shader] |> Capability.Set.of_list
          end
        module Fpdenormmode =
          struct
            type t =
              | Flushtozero 
              | Preserve [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Flushtozero -> [1l] | Preserve -> [0l]
            let any_required_version =
              function
              | Flushtozero ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Preserve ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Flushtozero -> [] |> Requirements.Extension.Set.of_list
              | Preserve -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Flushtozero ->
                  [Capability.Functionfloatcontrolintel] |>
                    Capability.Set.of_list
              | Preserve ->
                  [Capability.Functionfloatcontrolintel] |>
                    Capability.Set.of_list
          end
        module Fpencoding =
          struct
            type t =
              | Bfloat16khr 
              | Float8e4m3ext 
              | Float8e5m2ext [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Bfloat16khr -> [0l]
              | Float8e4m3ext -> [4214l]
              | Float8e5m2ext -> [4215l]
            let any_required_version =
              function
              | Bfloat16khr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float8e4m3ext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Float8e5m2ext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Bfloat16khr -> [] |> Requirements.Extension.Set.of_list
              | Float8e4m3ext -> [] |> Requirements.Extension.Set.of_list
              | Float8e5m2ext -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Bfloat16khr ->
                  [Capability.Bfloat16typekhr] |> Capability.Set.of_list
              | Float8e4m3ext ->
                  [Capability.Float8ext] |> Capability.Set.of_list
              | Float8e5m2ext ->
                  [Capability.Float8ext] |> Capability.Set.of_list
          end
        module Fpfastmathmode =
          struct
            type t =
              | Allowcontract 
              | Allowreassoc 
              | Allowrecip 
              | Allowtransform 
              | Fast 
              | None 
              | Notinf 
              | Notnan 
              | Nsz [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Allowcontract -> [65536l]
              | Allowreassoc -> [131072l]
              | Allowrecip -> [8l]
              | Allowtransform -> [262144l]
              | Fast -> [16l]
              | None -> [0l]
              | Notinf -> [2l]
              | Notnan -> [1l]
              | Nsz -> [4l]
            let any_required_version =
              function
              | Allowcontract ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Allowreassoc ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Allowrecip ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Allowtransform ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Fast ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Notinf ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Notnan ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nsz ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Allowcontract -> [] |> Requirements.Extension.Set.of_list
              | Allowreassoc -> [] |> Requirements.Extension.Set.of_list
              | Allowrecip -> [] |> Requirements.Extension.Set.of_list
              | Allowtransform -> [] |> Requirements.Extension.Set.of_list
              | Fast -> [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
              | Notinf -> [] |> Requirements.Extension.Set.of_list
              | Notnan -> [] |> Requirements.Extension.Set.of_list
              | Nsz -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Allowcontract ->
                  [Capability.Floatcontrols2; Capability.Fpfastmathmodeintel]
                    |> Capability.Set.of_list
              | Allowreassoc ->
                  [Capability.Floatcontrols2; Capability.Fpfastmathmodeintel]
                    |> Capability.Set.of_list
              | Allowrecip -> [] |> Capability.Set.of_list
              | Allowtransform ->
                  [Capability.Floatcontrols2] |> Capability.Set.of_list
              | Fast -> [] |> Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
              | Notinf -> [] |> Capability.Set.of_list
              | Notnan -> [] |> Capability.Set.of_list
              | Nsz -> [] |> Capability.Set.of_list
          end
        module Fpoperationmode =
          struct
            type t =
              | Alt 
              | Ieee [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Alt -> [1l] | Ieee -> [0l]
            let any_required_version =
              function
              | Alt ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Ieee ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Alt -> [] |> Requirements.Extension.Set.of_list
              | Ieee -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Alt ->
                  [Capability.Functionfloatcontrolintel] |>
                    Capability.Set.of_list
              | Ieee ->
                  [Capability.Functionfloatcontrolintel] |>
                    Capability.Set.of_list
          end
        module Fproundingmode =
          struct
            type t =
              | Rte 
              | Rtn 
              | Rtp 
              | Rtz [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rte -> [0l]
              | Rtn -> [3l]
              | Rtp -> [2l]
              | Rtz -> [1l]
            let any_required_version =
              function
              | Rte ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rtn ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rtp ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rtz ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Rte -> [] |> Requirements.Extension.Set.of_list
              | Rtn -> [] |> Requirements.Extension.Set.of_list
              | Rtp -> [] |> Requirements.Extension.Set.of_list
              | Rtz -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Rte -> [] |> Capability.Set.of_list
              | Rtn -> [] |> Capability.Set.of_list
              | Rtp -> [] |> Capability.Set.of_list
              | Rtz -> [] |> Capability.Set.of_list
          end
        module Fragmentshadingrate =
          struct
            type t =
              | Horizontal2pixels 
              | Horizontal4pixels 
              | Vertical2pixels 
              | Vertical4pixels [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Horizontal2pixels -> [4l]
              | Horizontal4pixels -> [8l]
              | Vertical2pixels -> [1l]
              | Vertical4pixels -> [2l]
            let any_required_version =
              function
              | Horizontal2pixels ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Horizontal4pixels ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vertical2pixels ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vertical4pixels ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Horizontal2pixels -> [] |> Requirements.Extension.Set.of_list
              | Horizontal4pixels -> [] |> Requirements.Extension.Set.of_list
              | Vertical2pixels -> [] |> Requirements.Extension.Set.of_list
              | Vertical4pixels -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Horizontal2pixels ->
                  [Capability.Fragmentshadingratekhr] |>
                    Capability.Set.of_list
              | Horizontal4pixels ->
                  [Capability.Fragmentshadingratekhr] |>
                    Capability.Set.of_list
              | Vertical2pixels ->
                  [Capability.Fragmentshadingratekhr] |>
                    Capability.Set.of_list
              | Vertical4pixels ->
                  [Capability.Fragmentshadingratekhr] |>
                    Capability.Set.of_list
          end
        module Functioncontrol =
          struct
            type t =
              | Const 
              | Dontinline 
              | Inline 
              | None 
              | Optnoneext 
              | Pure [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Const -> [8l]
              | Dontinline -> [2l]
              | Inline -> [1l]
              | None -> [0l]
              | Optnoneext -> [65536l]
              | Pure -> [4l]
            let any_required_version =
              function
              | Const ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dontinline ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inline ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Optnoneext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pure ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Const -> [] |> Requirements.Extension.Set.of_list
              | Dontinline -> [] |> Requirements.Extension.Set.of_list
              | Inline -> [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
              | Optnoneext -> [] |> Requirements.Extension.Set.of_list
              | Pure -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Const -> [] |> Capability.Set.of_list
              | Dontinline -> [] |> Capability.Set.of_list
              | Inline -> [] |> Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
              | Optnoneext ->
                  [Capability.Optnoneext] |> Capability.Set.of_list
              | Pure -> [] |> Capability.Set.of_list
          end
        module Functionparameterattribute =
          struct
            type t =
              | Byval 
              | Noalias 
              | Nocapture 
              | Noreadwrite 
              | Nowrite 
              | Runtimealignedaltera 
              | Sext 
              | Sret 
              | Zext [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Byval -> [2l]
              | Noalias -> [4l]
              | Nocapture -> [5l]
              | Noreadwrite -> [7l]
              | Nowrite -> [6l]
              | Runtimealignedaltera -> [5940l]
              | Sext -> [1l]
              | Sret -> [3l]
              | Zext -> [0l]
            let any_required_version =
              function
              | Byval ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noalias ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nocapture ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noreadwrite ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nowrite ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Runtimealignedaltera ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sret ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Zext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Byval -> [] |> Requirements.Extension.Set.of_list
              | Noalias -> [] |> Requirements.Extension.Set.of_list
              | Nocapture -> [] |> Requirements.Extension.Set.of_list
              | Noreadwrite -> [] |> Requirements.Extension.Set.of_list
              | Nowrite -> [] |> Requirements.Extension.Set.of_list
              | Runtimealignedaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Sext -> [] |> Requirements.Extension.Set.of_list
              | Sret -> [] |> Requirements.Extension.Set.of_list
              | Zext -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Byval -> [Capability.Kernel] |> Capability.Set.of_list
              | Noalias -> [Capability.Kernel] |> Capability.Set.of_list
              | Nocapture -> [Capability.Kernel] |> Capability.Set.of_list
              | Noreadwrite -> [Capability.Kernel] |> Capability.Set.of_list
              | Nowrite -> [Capability.Kernel] |> Capability.Set.of_list
              | Runtimealignedaltera ->
                  [Capability.Runtimealignedattributealtera] |>
                    Capability.Set.of_list
              | Sext -> [Capability.Kernel] |> Capability.Set.of_list
              | Sret -> [Capability.Kernel] |> Capability.Set.of_list
              | Zext -> [Capability.Kernel] |> Capability.Set.of_list
          end
        module Groupoperation =
          struct
            type t =
              | Clusteredreduce 
              | Exclusivescan 
              | Inclusivescan 
              | Partitionedexclusivescannv 
              | Partitionedinclusivescannv 
              | Partitionedreducenv 
              | Reduce [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Clusteredreduce -> [3l]
              | Exclusivescan -> [2l]
              | Inclusivescan -> [1l]
              | Partitionedexclusivescannv -> [8l]
              | Partitionedinclusivescannv -> [7l]
              | Partitionedreducenv -> [6l]
              | Reduce -> [0l]
            let any_required_version =
              function
              | Clusteredreduce ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Exclusivescan ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Inclusivescan ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Partitionedexclusivescannv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Partitionedinclusivescannv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Partitionedreducenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Reduce ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Clusteredreduce -> [] |> Requirements.Extension.Set.of_list
              | Exclusivescan -> [] |> Requirements.Extension.Set.of_list
              | Inclusivescan -> [] |> Requirements.Extension.Set.of_list
              | Partitionedexclusivescannv ->
                  [Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                    |> Requirements.Extension.Set.of_list
              | Partitionedinclusivescannv ->
                  [Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                    |> Requirements.Extension.Set.of_list
              | Partitionedreducenv ->
                  [Requirements.Extension.Spv_nv_shader_subgroup_partitioned]
                    |> Requirements.Extension.Set.of_list
              | Reduce -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Clusteredreduce ->
                  [Capability.Groupnonuniformclustered] |>
                    Capability.Set.of_list
              | Exclusivescan ->
                  [Capability.Kernel;
                  Capability.Groupnonuniformarithmetic;
                  Capability.Groupnonuniformballot] |> Capability.Set.of_list
              | Inclusivescan ->
                  [Capability.Kernel;
                  Capability.Groupnonuniformarithmetic;
                  Capability.Groupnonuniformballot] |> Capability.Set.of_list
              | Partitionedexclusivescannv ->
                  [Capability.Groupnonuniformpartitionednv] |>
                    Capability.Set.of_list
              | Partitionedinclusivescannv ->
                  [Capability.Groupnonuniformpartitionednv] |>
                    Capability.Set.of_list
              | Partitionedreducenv ->
                  [Capability.Groupnonuniformpartitionednv] |>
                    Capability.Set.of_list
              | Reduce ->
                  [Capability.Kernel;
                  Capability.Groupnonuniformarithmetic;
                  Capability.Groupnonuniformballot] |> Capability.Set.of_list
          end
        module Hostaccessqualifier =
          struct
            type t =
              | Noneintel 
              | Readintel 
              | Readwriteintel 
              | Writeintel [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Noneintel -> [0l]
              | Readintel -> [1l]
              | Readwriteintel -> [3l]
              | Writeintel -> [2l]
            let any_required_version =
              function
              | Noneintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Readintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Readwriteintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Writeintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Noneintel -> [] |> Requirements.Extension.Set.of_list
              | Readintel -> [] |> Requirements.Extension.Set.of_list
              | Readwriteintel -> [] |> Requirements.Extension.Set.of_list
              | Writeintel -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Noneintel ->
                  [Capability.Globalvariablehostaccessintel] |>
                    Capability.Set.of_list
              | Readintel ->
                  [Capability.Globalvariablehostaccessintel] |>
                    Capability.Set.of_list
              | Readwriteintel ->
                  [Capability.Globalvariablehostaccessintel] |>
                    Capability.Set.of_list
              | Writeintel ->
                  [Capability.Globalvariablehostaccessintel] |>
                    Capability.Set.of_list
          end
        module Idmemorysemantics =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc =
              Some
                "Reference to an <id> representing a 32-bit integer that is a mask from the MemorySemantics operand kind"
            let value t = [t]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Idref =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc = Some "Reference to an <id>"
            let value t = [t]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Idresult =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc =
              Some
                "Definition of an <id> representing the result of the enclosing instruction"
            let value t = [t]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Idresulttype =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc =
              Some
                "Reference to an <id> representing the result's type of the enclosing instruction"
            let value t = [t]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Idscope =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Id
            let doc =
              Some
                "Reference to an <id> representing a 32-bit integer that is a mask from the Scope operand kind"
            let value t = [t]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Imagechanneldatatype =
          struct
            type t =
              | Float 
              | Halffloat 
              | Signedint16 
              | Signedint32 
              | Signedint8 
              | Snormint16 
              | Snormint8 
              | Unormint101010 
              | Unormint101010_2 
              | Unormint10x6ext 
              | Unormint12x4ext 
              | Unormint14x2ext 
              | Unormint16 
              | Unormint24 
              | Unormint2_101010ext 
              | Unormint8 
              | Unormshort555 
              | Unormshort565 
              | Unsignedint10x6ext 
              | Unsignedint12x4ext 
              | Unsignedint14x2ext 
              | Unsignedint16 
              | Unsignedint32 
              | Unsignedint8 
              | Unsignedintraw10ext 
              | Unsignedintraw12ext [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Float -> [14l]
              | Halffloat -> [13l]
              | Signedint16 -> [8l]
              | Signedint32 -> [9l]
              | Signedint8 -> [7l]
              | Snormint16 -> [1l]
              | Snormint8 -> [0l]
              | Unormint101010 -> [6l]
              | Unormint101010_2 -> [16l]
              | Unormint10x6ext -> [17l]
              | Unormint12x4ext -> [25l]
              | Unormint14x2ext -> [26l]
              | Unormint16 -> [3l]
              | Unormint24 -> [15l]
              | Unormint2_101010ext -> [21l]
              | Unormint8 -> [2l]
              | Unormshort555 -> [5l]
              | Unormshort565 -> [4l]
              | Unsignedint10x6ext -> [22l]
              | Unsignedint12x4ext -> [23l]
              | Unsignedint14x2ext -> [24l]
              | Unsignedint16 -> [11l]
              | Unsignedint32 -> [12l]
              | Unsignedint8 -> [10l]
              | Unsignedintraw10ext -> [19l]
              | Unsignedintraw12ext -> [20l]
            let any_required_version =
              function
              | Float ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Halffloat ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedint16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedint32 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signedint8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Snormint16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Snormint8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint101010 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint101010_2 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint10x6ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint12x4ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint14x2ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint24 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint2_101010ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormint8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormshort555 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unormshort565 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint10x6ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint12x4ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint14x2ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint32 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedint8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedintraw10ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unsignedintraw12ext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Float -> [] |> Requirements.Extension.Set.of_list
              | Halffloat -> [] |> Requirements.Extension.Set.of_list
              | Signedint16 -> [] |> Requirements.Extension.Set.of_list
              | Signedint32 -> [] |> Requirements.Extension.Set.of_list
              | Signedint8 -> [] |> Requirements.Extension.Set.of_list
              | Snormint16 -> [] |> Requirements.Extension.Set.of_list
              | Snormint8 -> [] |> Requirements.Extension.Set.of_list
              | Unormint101010 -> [] |> Requirements.Extension.Set.of_list
              | Unormint101010_2 -> [] |> Requirements.Extension.Set.of_list
              | Unormint10x6ext -> [] |> Requirements.Extension.Set.of_list
              | Unormint12x4ext -> [] |> Requirements.Extension.Set.of_list
              | Unormint14x2ext -> [] |> Requirements.Extension.Set.of_list
              | Unormint16 -> [] |> Requirements.Extension.Set.of_list
              | Unormint24 -> [] |> Requirements.Extension.Set.of_list
              | Unormint2_101010ext ->
                  [] |> Requirements.Extension.Set.of_list
              | Unormint8 -> [] |> Requirements.Extension.Set.of_list
              | Unormshort555 -> [] |> Requirements.Extension.Set.of_list
              | Unormshort565 -> [] |> Requirements.Extension.Set.of_list
              | Unsignedint10x6ext ->
                  [] |> Requirements.Extension.Set.of_list
              | Unsignedint12x4ext ->
                  [] |> Requirements.Extension.Set.of_list
              | Unsignedint14x2ext ->
                  [] |> Requirements.Extension.Set.of_list
              | Unsignedint16 -> [] |> Requirements.Extension.Set.of_list
              | Unsignedint32 -> [] |> Requirements.Extension.Set.of_list
              | Unsignedint8 -> [] |> Requirements.Extension.Set.of_list
              | Unsignedintraw10ext ->
                  [] |> Requirements.Extension.Set.of_list
              | Unsignedintraw12ext ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Float -> [] |> Capability.Set.of_list
              | Halffloat -> [] |> Capability.Set.of_list
              | Signedint16 -> [] |> Capability.Set.of_list
              | Signedint32 -> [] |> Capability.Set.of_list
              | Signedint8 -> [] |> Capability.Set.of_list
              | Snormint16 -> [] |> Capability.Set.of_list
              | Snormint8 -> [] |> Capability.Set.of_list
              | Unormint101010 -> [] |> Capability.Set.of_list
              | Unormint101010_2 -> [] |> Capability.Set.of_list
              | Unormint10x6ext -> [] |> Capability.Set.of_list
              | Unormint12x4ext -> [] |> Capability.Set.of_list
              | Unormint14x2ext -> [] |> Capability.Set.of_list
              | Unormint16 -> [] |> Capability.Set.of_list
              | Unormint24 -> [] |> Capability.Set.of_list
              | Unormint2_101010ext -> [] |> Capability.Set.of_list
              | Unormint8 -> [] |> Capability.Set.of_list
              | Unormshort555 -> [] |> Capability.Set.of_list
              | Unormshort565 -> [] |> Capability.Set.of_list
              | Unsignedint10x6ext -> [] |> Capability.Set.of_list
              | Unsignedint12x4ext -> [] |> Capability.Set.of_list
              | Unsignedint14x2ext -> [] |> Capability.Set.of_list
              | Unsignedint16 -> [] |> Capability.Set.of_list
              | Unsignedint32 -> [] |> Capability.Set.of_list
              | Unsignedint8 -> [] |> Capability.Set.of_list
              | Unsignedintraw10ext -> [] |> Capability.Set.of_list
              | Unsignedintraw12ext -> [] |> Capability.Set.of_list
          end
        module Imagechannelorder =
          struct
            type t =
              | A 
              | Abgr 
              | Argb 
              | Bgra 
              | Depth 
              | Depthstencil 
              | Intensity 
              | Luminance 
              | R 
              | Ra 
              | Rg 
              | Rgb 
              | Rgba 
              | Rgbx 
              | Rgx 
              | Rx 
              | Sbgra 
              | Srgb 
              | Srgba 
              | Srgbx [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | A -> [1l]
              | Abgr -> [19l]
              | Argb -> [7l]
              | Bgra -> [6l]
              | Depth -> [13l]
              | Depthstencil -> [14l]
              | Intensity -> [8l]
              | Luminance -> [9l]
              | R -> [0l]
              | Ra -> [3l]
              | Rg -> [2l]
              | Rgb -> [4l]
              | Rgba -> [5l]
              | Rgbx -> [12l]
              | Rgx -> [11l]
              | Rx -> [10l]
              | Sbgra -> [18l]
              | Srgb -> [15l]
              | Srgba -> [17l]
              | Srgbx -> [16l]
            let any_required_version =
              function
              | A ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Abgr ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Argb ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Bgra ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Depth ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Depthstencil ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Intensity ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Luminance ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Ra ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgb ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgbx ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgx ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rx ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sbgra ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Srgb ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Srgba ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Srgbx ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | A -> [] |> Requirements.Extension.Set.of_list
              | Abgr -> [] |> Requirements.Extension.Set.of_list
              | Argb -> [] |> Requirements.Extension.Set.of_list
              | Bgra -> [] |> Requirements.Extension.Set.of_list
              | Depth -> [] |> Requirements.Extension.Set.of_list
              | Depthstencil -> [] |> Requirements.Extension.Set.of_list
              | Intensity -> [] |> Requirements.Extension.Set.of_list
              | Luminance -> [] |> Requirements.Extension.Set.of_list
              | R -> [] |> Requirements.Extension.Set.of_list
              | Ra -> [] |> Requirements.Extension.Set.of_list
              | Rg -> [] |> Requirements.Extension.Set.of_list
              | Rgb -> [] |> Requirements.Extension.Set.of_list
              | Rgba -> [] |> Requirements.Extension.Set.of_list
              | Rgbx -> [] |> Requirements.Extension.Set.of_list
              | Rgx -> [] |> Requirements.Extension.Set.of_list
              | Rx -> [] |> Requirements.Extension.Set.of_list
              | Sbgra -> [] |> Requirements.Extension.Set.of_list
              | Srgb -> [] |> Requirements.Extension.Set.of_list
              | Srgba -> [] |> Requirements.Extension.Set.of_list
              | Srgbx -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | A -> [] |> Capability.Set.of_list
              | Abgr -> [] |> Capability.Set.of_list
              | Argb -> [] |> Capability.Set.of_list
              | Bgra -> [] |> Capability.Set.of_list
              | Depth -> [] |> Capability.Set.of_list
              | Depthstencil -> [] |> Capability.Set.of_list
              | Intensity -> [] |> Capability.Set.of_list
              | Luminance -> [] |> Capability.Set.of_list
              | R -> [] |> Capability.Set.of_list
              | Ra -> [] |> Capability.Set.of_list
              | Rg -> [] |> Capability.Set.of_list
              | Rgb -> [] |> Capability.Set.of_list
              | Rgba -> [] |> Capability.Set.of_list
              | Rgbx -> [] |> Capability.Set.of_list
              | Rgx -> [] |> Capability.Set.of_list
              | Rx -> [] |> Capability.Set.of_list
              | Sbgra -> [] |> Capability.Set.of_list
              | Srgb -> [] |> Capability.Set.of_list
              | Srgba -> [] |> Capability.Set.of_list
              | Srgbx -> [] |> Capability.Set.of_list
          end
        module Imageformat =
          struct
            type t =
              | R11fg11fb10f 
              | R16 
              | R16f 
              | R16i 
              | R16snorm 
              | R16ui 
              | R32f 
              | R32i 
              | R32ui 
              | R64i 
              | R64ui 
              | R8 
              | R8i 
              | R8snorm 
              | R8ui 
              | Rg16 
              | Rg16f 
              | Rg16i 
              | Rg16snorm 
              | Rg16ui 
              | Rg32f 
              | Rg32i 
              | Rg32ui 
              | Rg8 
              | Rg8i 
              | Rg8snorm 
              | Rg8ui 
              | Rgb10a2 
              | Rgb10a2ui 
              | Rgba16 
              | Rgba16f 
              | Rgba16i 
              | Rgba16snorm 
              | Rgba16ui 
              | Rgba32f 
              | Rgba32i 
              | Rgba32ui 
              | Rgba8 
              | Rgba8i 
              | Rgba8snorm 
              | Rgba8ui 
              | Unknown [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | R11fg11fb10f -> [8l]
              | R16 -> [14l]
              | R16f -> [9l]
              | R16i -> [28l]
              | R16snorm -> [19l]
              | R16ui -> [38l]
              | R32f -> [3l]
              | R32i -> [24l]
              | R32ui -> [33l]
              | R64i -> [41l]
              | R64ui -> [40l]
              | R8 -> [15l]
              | R8i -> [29l]
              | R8snorm -> [20l]
              | R8ui -> [39l]
              | Rg16 -> [12l]
              | Rg16f -> [7l]
              | Rg16i -> [26l]
              | Rg16snorm -> [17l]
              | Rg16ui -> [36l]
              | Rg32f -> [6l]
              | Rg32i -> [25l]
              | Rg32ui -> [35l]
              | Rg8 -> [13l]
              | Rg8i -> [27l]
              | Rg8snorm -> [18l]
              | Rg8ui -> [37l]
              | Rgb10a2 -> [11l]
              | Rgb10a2ui -> [34l]
              | Rgba16 -> [10l]
              | Rgba16f -> [2l]
              | Rgba16i -> [22l]
              | Rgba16snorm -> [16l]
              | Rgba16ui -> [31l]
              | Rgba32f -> [1l]
              | Rgba32i -> [21l]
              | Rgba32ui -> [30l]
              | Rgba8 -> [4l]
              | Rgba8i -> [23l]
              | Rgba8snorm -> [5l]
              | Rgba8ui -> [32l]
              | Unknown -> [0l]
            let any_required_version =
              function
              | R11fg11fb10f ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R16f ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R16i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R16snorm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R16ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R32f ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R32i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R32ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R64i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R64ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R8i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R8snorm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | R8ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg16f ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg16i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg16snorm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg16ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg32f ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg32i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg32ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg8i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg8snorm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rg8ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgb10a2 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgb10a2ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba16 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba16f ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba16i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba16snorm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba16ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba32f ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba32i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba32ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba8 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba8i ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba8snorm ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rgba8ui ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unknown ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | R11fg11fb10f -> [] |> Requirements.Extension.Set.of_list
              | R16 -> [] |> Requirements.Extension.Set.of_list
              | R16f -> [] |> Requirements.Extension.Set.of_list
              | R16i -> [] |> Requirements.Extension.Set.of_list
              | R16snorm -> [] |> Requirements.Extension.Set.of_list
              | R16ui -> [] |> Requirements.Extension.Set.of_list
              | R32f -> [] |> Requirements.Extension.Set.of_list
              | R32i -> [] |> Requirements.Extension.Set.of_list
              | R32ui -> [] |> Requirements.Extension.Set.of_list
              | R64i -> [] |> Requirements.Extension.Set.of_list
              | R64ui -> [] |> Requirements.Extension.Set.of_list
              | R8 -> [] |> Requirements.Extension.Set.of_list
              | R8i -> [] |> Requirements.Extension.Set.of_list
              | R8snorm -> [] |> Requirements.Extension.Set.of_list
              | R8ui -> [] |> Requirements.Extension.Set.of_list
              | Rg16 -> [] |> Requirements.Extension.Set.of_list
              | Rg16f -> [] |> Requirements.Extension.Set.of_list
              | Rg16i -> [] |> Requirements.Extension.Set.of_list
              | Rg16snorm -> [] |> Requirements.Extension.Set.of_list
              | Rg16ui -> [] |> Requirements.Extension.Set.of_list
              | Rg32f -> [] |> Requirements.Extension.Set.of_list
              | Rg32i -> [] |> Requirements.Extension.Set.of_list
              | Rg32ui -> [] |> Requirements.Extension.Set.of_list
              | Rg8 -> [] |> Requirements.Extension.Set.of_list
              | Rg8i -> [] |> Requirements.Extension.Set.of_list
              | Rg8snorm -> [] |> Requirements.Extension.Set.of_list
              | Rg8ui -> [] |> Requirements.Extension.Set.of_list
              | Rgb10a2 -> [] |> Requirements.Extension.Set.of_list
              | Rgb10a2ui -> [] |> Requirements.Extension.Set.of_list
              | Rgba16 -> [] |> Requirements.Extension.Set.of_list
              | Rgba16f -> [] |> Requirements.Extension.Set.of_list
              | Rgba16i -> [] |> Requirements.Extension.Set.of_list
              | Rgba16snorm -> [] |> Requirements.Extension.Set.of_list
              | Rgba16ui -> [] |> Requirements.Extension.Set.of_list
              | Rgba32f -> [] |> Requirements.Extension.Set.of_list
              | Rgba32i -> [] |> Requirements.Extension.Set.of_list
              | Rgba32ui -> [] |> Requirements.Extension.Set.of_list
              | Rgba8 -> [] |> Requirements.Extension.Set.of_list
              | Rgba8i -> [] |> Requirements.Extension.Set.of_list
              | Rgba8snorm -> [] |> Requirements.Extension.Set.of_list
              | Rgba8ui -> [] |> Requirements.Extension.Set.of_list
              | Unknown -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | R11fg11fb10f ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R16 ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R16f ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R16i ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R16snorm ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R16ui ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R32f -> [Capability.Shader] |> Capability.Set.of_list
              | R32i -> [Capability.Shader] |> Capability.Set.of_list
              | R32ui -> [Capability.Shader] |> Capability.Set.of_list
              | R64i -> [Capability.Int64imageext] |> Capability.Set.of_list
              | R64ui -> [Capability.Int64imageext] |> Capability.Set.of_list
              | R8 ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R8i ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R8snorm ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | R8ui ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg16 ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg16f ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg16i ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg16snorm ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg16ui ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg32f ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg32i ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg32ui ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg8 ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg8i ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg8snorm ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rg8ui ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rgb10a2 ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rgb10a2ui ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rgba16 ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rgba16f -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba16i -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba16snorm ->
                  [Capability.Storageimageextendedformats] |>
                    Capability.Set.of_list
              | Rgba16ui -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba32f -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba32i -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba32ui -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba8 -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba8i -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba8snorm -> [Capability.Shader] |> Capability.Set.of_list
              | Rgba8ui -> [Capability.Shader] |> Capability.Set.of_list
              | Unknown -> [] |> Capability.Set.of_list
          end
        module Imageoperands =
          struct
            type t =
              | Bias 
              | Constoffset 
              | Constoffsets 
              | Grad 
              | Lod 
              | Maketexelavailable 
              | Maketexelvisible 
              | Minlod 
              | None 
              | Nonprivatetexel 
              | Nontemporal 
              | Offset 
              | Offsets 
              | Sample 
              | Signextend 
              | Volatiletexel 
              | Zeroextend [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Bias -> [1l]
              | Constoffset -> [8l]
              | Constoffsets -> [32l]
              | Grad -> [4l]
              | Lod -> [2l]
              | Maketexelavailable -> [256l]
              | Maketexelvisible -> [512l]
              | Minlod -> [128l]
              | None -> [0l]
              | Nonprivatetexel -> [1024l]
              | Nontemporal -> [16384l]
              | Offset -> [16l]
              | Offsets -> [65536l]
              | Sample -> [64l]
              | Signextend -> [4096l]
              | Volatiletexel -> [2048l]
              | Zeroextend -> [8192l]
            let any_required_version =
              function
              | Bias ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Constoffset ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Constoffsets ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Grad ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Lod ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maketexelavailable ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maketexelvisible ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Minlod ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonprivatetexel ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nontemporal ->
                  (Requirements.Version.valid_versions ~required:(Some V1_6)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Offset ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Offsets ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sample ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Signextend ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Volatiletexel ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Zeroextend ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Bias -> [] |> Requirements.Extension.Set.of_list
              | Constoffset -> [] |> Requirements.Extension.Set.of_list
              | Constoffsets -> [] |> Requirements.Extension.Set.of_list
              | Grad -> [] |> Requirements.Extension.Set.of_list
              | Lod -> [] |> Requirements.Extension.Set.of_list
              | Maketexelavailable ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Maketexelvisible ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Minlod -> [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
              | Nonprivatetexel ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Nontemporal -> [] |> Requirements.Extension.Set.of_list
              | Offset -> [] |> Requirements.Extension.Set.of_list
              | Offsets -> [] |> Requirements.Extension.Set.of_list
              | Sample -> [] |> Requirements.Extension.Set.of_list
              | Signextend -> [] |> Requirements.Extension.Set.of_list
              | Volatiletexel ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Zeroextend -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Bias -> [Capability.Shader] |> Capability.Set.of_list
              | Constoffset -> [] |> Capability.Set.of_list
              | Constoffsets ->
                  [Capability.Imagegatherextended] |> Capability.Set.of_list
              | Grad -> [] |> Capability.Set.of_list
              | Lod -> [] |> Capability.Set.of_list
              | Maketexelavailable ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Maketexelvisible ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Minlod -> [Capability.Minlod] |> Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
              | Nonprivatetexel ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Nontemporal -> [] |> Capability.Set.of_list
              | Offset ->
                  [Capability.Imagegatherextended] |> Capability.Set.of_list
              | Offsets -> [] |> Capability.Set.of_list
              | Sample -> [] |> Capability.Set.of_list
              | Signextend -> [] |> Capability.Set.of_list
              | Volatiletexel ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Zeroextend -> [] |> Capability.Set.of_list
          end
        module Initializationmodequalifier =
          struct
            type t =
              | Initondevicereprogramaltera 
              | Initondeviceresetaltera [@@deriving
                                          compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Initondevicereprogramaltera -> [0l]
              | Initondeviceresetaltera -> [1l]
            let any_required_version =
              function
              | Initondevicereprogramaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Initondeviceresetaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Initondevicereprogramaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Initondeviceresetaltera ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Initondevicereprogramaltera ->
                  [Capability.Globalvariablefpgadecorationsaltera] |>
                    Capability.Set.of_list
              | Initondeviceresetaltera ->
                  [Capability.Globalvariablefpgadecorationsaltera] |>
                    Capability.Set.of_list
          end
        module Kernelenqueueflags =
          struct
            type t =
              | Nowait 
              | Waitkernel 
              | Waitworkgroup [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Nowait -> [0l]
              | Waitkernel -> [1l]
              | Waitworkgroup -> [2l]
            let any_required_version =
              function
              | Nowait ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Waitkernel ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Waitworkgroup ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Nowait -> [] |> Requirements.Extension.Set.of_list
              | Waitkernel -> [] |> Requirements.Extension.Set.of_list
              | Waitworkgroup -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Nowait -> [Capability.Kernel] |> Capability.Set.of_list
              | Waitkernel -> [Capability.Kernel] |> Capability.Set.of_list
              | Waitworkgroup ->
                  [Capability.Kernel] |> Capability.Set.of_list
          end
        module Kernelprofilinginfo =
          struct
            type t =
              | Cmdexectime 
              | None [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value = function | Cmdexectime -> [1l] | None -> [0l]
            let any_required_version =
              function
              | Cmdexectime ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Cmdexectime -> [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Cmdexectime -> [Capability.Kernel] |> Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
          end
        module Linkagetype =
          struct
            type t =
              | Export 
              | Import 
              | Linkonceodr [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Export -> [0l]
              | Import -> [1l]
              | Linkonceodr -> [2l]
            let any_required_version =
              function
              | Export ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Import ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Linkonceodr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Export -> [] |> Requirements.Extension.Set.of_list
              | Import -> [] |> Requirements.Extension.Set.of_list
              | Linkonceodr ->
                  [Requirements.Extension.Spv_khr_linkonce_odr] |>
                    Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Export -> [Capability.Linkage] |> Capability.Set.of_list
              | Import -> [Capability.Linkage] |> Capability.Set.of_list
              | Linkonceodr -> [Capability.Linkage] |> Capability.Set.of_list
          end
        module Literalcontextdependentnumber =
          struct
            type t =
              | I32 of int32 
              | I64 of int64 [@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc =
              Some
                "A literal number whose size and format are determined by a previous operand in the enclosing instruction"
            let value =
              function
              | I32 int32 -> [int32]
              | I64 int64 ->
                  let low = Int64.to_int32_trunc int64 in
                  let high =
                    Int64.to_int32_trunc (Int64.shift_right_logical int64 32) in
                  [low; high]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Literalextinstinteger =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc =
              Some
                "A 32-bit unsigned integer indicating which instruction to use and determining the layout of following operands (for OpExtInst)"
            let value t = [t]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Literalfloat =
          struct
            type t =
              | F32 of float 
              | F64 of float [@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc = Some "A float consuming one word"
            let value =
              function
              | F32 float -> [Int32.bits_of_float float]
              | F64 float ->
                  let int64 = Int64.bits_of_float float in
                  let low = Int64.to_int32_trunc int64 in
                  let high =
                    Int64.to_int32_trunc (Int64.shift_right_logical int64 32) in
                  [low; high]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Literalinteger =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc = Some "An integer consuming one or more words"
            let value t = [t]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Literalspecconstantopinteger =
          struct
            type t = int32[@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc =
              Some
                "An opcode indicating the operation to be performed and determining the layout of following operands (for OpSpecConstantOp)"
            let value t = [t]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Literalstring =
          struct
            type t = string[@@deriving compare, sexp_of]
            let category = Category.Literal
            let doc =
              Some
                "A null-terminated stream of characters consuming an integral number of words"
            let value t =
              let bytes = Bytes.of_string (t ^ "\000") in
              let int32_size = 4 in
              let output_size =
                ((Bytes.length bytes) + (int32_size - 1)) / int32_size in
              List.init output_size
                ~f:(fun idx ->
                      EndianBytes.LittleEndian.get_int32 bytes (idx * 4))
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Loadcachecontrol =
          struct
            type t =
              | Cachedintel 
              | Constcachedintel 
              | Invalidateafterreadintel 
              | Streamingintel 
              | Uncachedintel [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Cachedintel -> [1l]
              | Constcachedintel -> [4l]
              | Invalidateafterreadintel -> [3l]
              | Streamingintel -> [2l]
              | Uncachedintel -> [0l]
            let any_required_version =
              function
              | Cachedintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Constcachedintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Invalidateafterreadintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Streamingintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uncachedintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Cachedintel -> [] |> Requirements.Extension.Set.of_list
              | Constcachedintel -> [] |> Requirements.Extension.Set.of_list
              | Invalidateafterreadintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Streamingintel -> [] |> Requirements.Extension.Set.of_list
              | Uncachedintel -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Cachedintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Constcachedintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Invalidateafterreadintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Streamingintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Uncachedintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
          end
        module Loopcontrol =
          struct
            type t =
              | Dependencyarrayaltera 
              | Dependencyinfinite 
              | Dependencylength 
              | Dontunroll 
              | Initiationintervalaltera 
              | Iterationmultiple 
              | Loopcoalescealtera 
              | Loopcountaltera 
              | Maxconcurrencyaltera 
              | Maxinterleavingaltera 
              | Maxiterations 
              | Maxreinvocationdelayaltera 
              | Miniterations 
              | Nofusionaltera 
              | None 
              | Partialcount 
              | Peelcount 
              | Pipelineenablealtera 
              | Speculatediterationsaltera 
              | Unroll [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Dependencyarrayaltera -> [262144l]
              | Dependencyinfinite -> [4l]
              | Dependencylength -> [8l]
              | Dontunroll -> [2l]
              | Initiationintervalaltera -> [65536l]
              | Iterationmultiple -> [64l]
              | Loopcoalescealtera -> [1048576l]
              | Loopcountaltera -> [16777216l]
              | Maxconcurrencyaltera -> [131072l]
              | Maxinterleavingaltera -> [2097152l]
              | Maxiterations -> [32l]
              | Maxreinvocationdelayaltera -> [33554432l]
              | Miniterations -> [16l]
              | Nofusionaltera -> [8388608l]
              | None -> [0l]
              | Partialcount -> [256l]
              | Peelcount -> [128l]
              | Pipelineenablealtera -> [524288l]
              | Speculatediterationsaltera -> [4194304l]
              | Unroll -> [1l]
            let any_required_version =
              function
              | Dependencyarrayaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dependencyinfinite ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dependencylength ->
                  (Requirements.Version.valid_versions ~required:(Some V1_1)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Dontunroll ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Initiationintervalaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Iterationmultiple ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Loopcoalescealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Loopcountaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxconcurrencyaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxinterleavingaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxiterations ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Maxreinvocationdelayaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Miniterations ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nofusionaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Partialcount ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Peelcount ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pipelineenablealtera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Speculatediterationsaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unroll ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Dependencyarrayaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Dependencyinfinite ->
                  [] |> Requirements.Extension.Set.of_list
              | Dependencylength -> [] |> Requirements.Extension.Set.of_list
              | Dontunroll -> [] |> Requirements.Extension.Set.of_list
              | Initiationintervalaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Iterationmultiple -> [] |> Requirements.Extension.Set.of_list
              | Loopcoalescealtera ->
                  [] |> Requirements.Extension.Set.of_list
              | Loopcountaltera -> [] |> Requirements.Extension.Set.of_list
              | Maxconcurrencyaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Maxinterleavingaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Maxiterations -> [] |> Requirements.Extension.Set.of_list
              | Maxreinvocationdelayaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Miniterations -> [] |> Requirements.Extension.Set.of_list
              | Nofusionaltera -> [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
              | Partialcount -> [] |> Requirements.Extension.Set.of_list
              | Peelcount -> [] |> Requirements.Extension.Set.of_list
              | Pipelineenablealtera ->
                  [] |> Requirements.Extension.Set.of_list
              | Speculatediterationsaltera ->
                  [] |> Requirements.Extension.Set.of_list
              | Unroll -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Dependencyarrayaltera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Dependencyinfinite -> [] |> Capability.Set.of_list
              | Dependencylength -> [] |> Capability.Set.of_list
              | Dontunroll -> [] |> Capability.Set.of_list
              | Initiationintervalaltera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Iterationmultiple -> [] |> Capability.Set.of_list
              | Loopcoalescealtera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Loopcountaltera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Maxconcurrencyaltera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Maxinterleavingaltera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Maxiterations -> [] |> Capability.Set.of_list
              | Maxreinvocationdelayaltera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Miniterations -> [] |> Capability.Set.of_list
              | Nofusionaltera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
              | Partialcount -> [] |> Capability.Set.of_list
              | Peelcount -> [] |> Capability.Set.of_list
              | Pipelineenablealtera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Speculatediterationsaltera ->
                  [Capability.Fpgaloopcontrolsaltera] |>
                    Capability.Set.of_list
              | Unroll -> [] |> Capability.Set.of_list
          end
        module Matrixmultiplyaccumulateoperands =
          struct
            type t =
              | Matrixapackedbfloat16intel 
              | Matrixapackedfloat16intel 
              | Matrixapackedint4intel 
              | Matrixapackedint8intel 
              | Matrixasignedcomponentsintel 
              | Matrixatf32intel 
              | Matrixbpackedbfloat16intel 
              | Matrixbpackedfloat16intel 
              | Matrixbpackedint4intel 
              | Matrixbpackedint8intel 
              | Matrixbsignedcomponentsintel 
              | Matrixbtf32intel 
              | Matrixcbfloat16intel 
              | Matrixresultbfloat16intel 
              | None [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Matrixapackedbfloat16intel -> [4096l]
              | Matrixapackedfloat16intel -> [1024l]
              | Matrixapackedint4intel -> [64l]
              | Matrixapackedint8intel -> [16l]
              | Matrixasignedcomponentsintel -> [1l]
              | Matrixatf32intel -> [256l]
              | Matrixbpackedbfloat16intel -> [8192l]
              | Matrixbpackedfloat16intel -> [2048l]
              | Matrixbpackedint4intel -> [128l]
              | Matrixbpackedint8intel -> [32l]
              | Matrixbsignedcomponentsintel -> [2l]
              | Matrixbtf32intel -> [512l]
              | Matrixcbfloat16intel -> [4l]
              | Matrixresultbfloat16intel -> [8l]
              | None -> [0l]
            let any_required_version =
              function
              | Matrixapackedbfloat16intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixapackedfloat16intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixapackedint4intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixapackedint8intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixasignedcomponentsintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixatf32intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixbpackedbfloat16intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixbpackedfloat16intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixbpackedint4intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixbpackedint8intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixbsignedcomponentsintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixbtf32intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixcbfloat16intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Matrixresultbfloat16intel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Matrixapackedbfloat16intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixapackedfloat16intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixapackedint4intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixapackedint8intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixasignedcomponentsintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixatf32intel -> [] |> Requirements.Extension.Set.of_list
              | Matrixbpackedbfloat16intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixbpackedfloat16intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixbpackedint4intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixbpackedint8intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixbsignedcomponentsintel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixbtf32intel -> [] |> Requirements.Extension.Set.of_list
              | Matrixcbfloat16intel ->
                  [] |> Requirements.Extension.Set.of_list
              | Matrixresultbfloat16intel ->
                  [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Matrixapackedbfloat16intel -> [] |> Capability.Set.of_list
              | Matrixapackedfloat16intel -> [] |> Capability.Set.of_list
              | Matrixapackedint4intel -> [] |> Capability.Set.of_list
              | Matrixapackedint8intel -> [] |> Capability.Set.of_list
              | Matrixasignedcomponentsintel -> [] |> Capability.Set.of_list
              | Matrixatf32intel -> [] |> Capability.Set.of_list
              | Matrixbpackedbfloat16intel -> [] |> Capability.Set.of_list
              | Matrixbpackedfloat16intel -> [] |> Capability.Set.of_list
              | Matrixbpackedint4intel -> [] |> Capability.Set.of_list
              | Matrixbpackedint8intel -> [] |> Capability.Set.of_list
              | Matrixbsignedcomponentsintel -> [] |> Capability.Set.of_list
              | Matrixbtf32intel -> [] |> Capability.Set.of_list
              | Matrixcbfloat16intel -> [] |> Capability.Set.of_list
              | Matrixresultbfloat16intel -> [] |> Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
          end
        module Memoryaccess =
          struct
            type t =
              | Aliasscopeintelmask 
              | Aligned 
              | Makepointeravailable 
              | Makepointervisible 
              | Noaliasintelmask 
              | None 
              | Nonprivatepointer 
              | Nontemporal 
              | Volatile [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Aliasscopeintelmask -> [65536l]
              | Aligned -> [2l]
              | Makepointeravailable -> [8l]
              | Makepointervisible -> [16l]
              | Noaliasintelmask -> [131072l]
              | None -> [0l]
              | Nonprivatepointer -> [32l]
              | Nontemporal -> [4l]
              | Volatile -> [1l]
            let any_required_version =
              function
              | Aliasscopeintelmask ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Aligned ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Makepointeravailable ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Makepointervisible ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noaliasintelmask ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonprivatepointer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nontemporal ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Volatile ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Aliasscopeintelmask ->
                  [Requirements.Extension.Spv_intel_memory_access_aliasing]
                    |> Requirements.Extension.Set.of_list
              | Aligned -> [] |> Requirements.Extension.Set.of_list
              | Makepointeravailable ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Makepointervisible ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Noaliasintelmask ->
                  [Requirements.Extension.Spv_intel_memory_access_aliasing]
                    |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
              | Nonprivatepointer ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Nontemporal -> [] |> Requirements.Extension.Set.of_list
              | Volatile -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Aliasscopeintelmask ->
                  [Capability.Memoryaccessaliasingintel] |>
                    Capability.Set.of_list
              | Aligned -> [] |> Capability.Set.of_list
              | Makepointeravailable ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Makepointervisible ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Noaliasintelmask ->
                  [Capability.Memoryaccessaliasingintel] |>
                    Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
              | Nonprivatepointer ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Nontemporal -> [] |> Capability.Set.of_list
              | Volatile -> [] |> Capability.Set.of_list
          end
        module Memorymodel =
          struct
            type t =
              | Glsl450 
              | Opencl 
              | Simple 
              | Vulkan [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Glsl450 -> [1l]
              | Opencl -> [2l]
              | Simple -> [0l]
              | Vulkan -> [3l]
            let any_required_version =
              function
              | Glsl450 ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Opencl ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Simple ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Vulkan ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Glsl450 -> [] |> Requirements.Extension.Set.of_list
              | Opencl -> [] |> Requirements.Extension.Set.of_list
              | Simple -> [] |> Requirements.Extension.Set.of_list
              | Vulkan ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Glsl450 -> [Capability.Shader] |> Capability.Set.of_list
              | Opencl -> [Capability.Kernel] |> Capability.Set.of_list
              | Simple -> [Capability.Shader] |> Capability.Set.of_list
              | Vulkan ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
          end
        module Memorysemantics =
          struct
            type t =
              | Acquire 
              | Acquirerelease 
              | Atomiccountermemory 
              | Crossworkgroupmemory 
              | Imagememory 
              | Makeavailable 
              | Makevisible 
              | Outputmemory 
              | Relaxed 
              | Release 
              | Sequentiallyconsistent 
              | Subgroupmemory 
              | Uniformmemory 
              | Volatile 
              | Workgroupmemory [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Acquire -> [2l]
              | Acquirerelease -> [8l]
              | Atomiccountermemory -> [1024l]
              | Crossworkgroupmemory -> [512l]
              | Imagememory -> [2048l]
              | Makeavailable -> [8192l]
              | Makevisible -> [16384l]
              | Outputmemory -> [4096l]
              | Relaxed -> [0l]
              | Release -> [4l]
              | Sequentiallyconsistent -> [16l]
              | Subgroupmemory -> [128l]
              | Uniformmemory -> [64l]
              | Volatile -> [32768l]
              | Workgroupmemory -> [256l]
            let any_required_version =
              function
              | Acquire ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Acquirerelease ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Atomiccountermemory ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Crossworkgroupmemory ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Imagememory ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Makeavailable ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Makevisible ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outputmemory ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Relaxed ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Release ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sequentiallyconsistent ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroupmemory ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformmemory ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Volatile ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workgroupmemory ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Acquire -> [] |> Requirements.Extension.Set.of_list
              | Acquirerelease -> [] |> Requirements.Extension.Set.of_list
              | Atomiccountermemory ->
                  [] |> Requirements.Extension.Set.of_list
              | Crossworkgroupmemory ->
                  [] |> Requirements.Extension.Set.of_list
              | Imagememory -> [] |> Requirements.Extension.Set.of_list
              | Makeavailable ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Makevisible ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Outputmemory ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Relaxed -> [] |> Requirements.Extension.Set.of_list
              | Release -> [] |> Requirements.Extension.Set.of_list
              | Sequentiallyconsistent ->
                  [] |> Requirements.Extension.Set.of_list
              | Subgroupmemory -> [] |> Requirements.Extension.Set.of_list
              | Uniformmemory -> [] |> Requirements.Extension.Set.of_list
              | Volatile ->
                  [Requirements.Extension.Spv_khr_vulkan_memory_model] |>
                    Requirements.Extension.Set.of_list
              | Workgroupmemory -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Acquire -> [] |> Capability.Set.of_list
              | Acquirerelease -> [] |> Capability.Set.of_list
              | Atomiccountermemory ->
                  [Capability.Atomicstorage] |> Capability.Set.of_list
              | Crossworkgroupmemory -> [] |> Capability.Set.of_list
              | Imagememory -> [] |> Capability.Set.of_list
              | Makeavailable ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Makevisible ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Outputmemory ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Relaxed -> [] |> Capability.Set.of_list
              | Release -> [] |> Capability.Set.of_list
              | Sequentiallyconsistent -> [] |> Capability.Set.of_list
              | Subgroupmemory -> [] |> Capability.Set.of_list
              | Uniformmemory ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Volatile ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Workgroupmemory -> [] |> Capability.Set.of_list
          end
        module Namedmaximumnumberofregisters =
          struct
            type t =
              | Autointel [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Autointel -> [0l]
            let any_required_version =
              function
              | Autointel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Autointel -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Autointel ->
                  [Capability.Registerlimitsintel] |> Capability.Set.of_list
          end
        module Overflowmodes =
          struct
            type t =
              | Sat 
              | Sat_sym 
              | Sat_zero 
              | Wrap [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Sat -> [1l]
              | Sat_sym -> [3l]
              | Sat_zero -> [2l]
              | Wrap -> [0l]
            let any_required_version =
              function
              | Sat ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sat_sym ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sat_zero ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Wrap ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Sat -> [] |> Requirements.Extension.Set.of_list
              | Sat_sym -> [] |> Requirements.Extension.Set.of_list
              | Sat_zero -> [] |> Requirements.Extension.Set.of_list
              | Wrap -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Sat ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Sat_sym ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Sat_zero ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Wrap ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
          end
        module Packedvectorformat =
          struct
            type t =
              | Packedvectorformat4x8bit [@@deriving
                                           compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Packedvectorformat4x8bit -> [0l]
            let any_required_version =
              function
              | Packedvectorformat4x8bit ->
                  (Requirements.Version.valid_versions ~required:(Some V1_6)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Packedvectorformat4x8bit ->
                  [Requirements.Extension.Spv_khr_integer_dot_product] |>
                    Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Packedvectorformat4x8bit -> [] |> Capability.Set.of_list
          end
        module Pairidrefidref =
          struct
            type t = (Idref.t * Idref.t)[@@deriving compare, sexp_of]
            let category = Category.Composite
            let doc = None
            let value (idref0, idref1) = [idref0; idref1]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Pairidrefliteralinteger =
          struct
            type t = (Idref.t * Literalinteger.t)[@@deriving
                                                   compare, sexp_of]
            let category = Category.Composite
            let doc = None
            let value (idref0, literalinteger1) = [idref0; literalinteger1]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Pairliteralintegeridref =
          struct
            type t = (Literalinteger.t * Idref.t)[@@deriving
                                                   compare, sexp_of]
            let category = Category.Composite
            let doc = None
            let value (literalinteger0, idref1) = [literalinteger0; idref1]
            let any_required_version = []
            let any_required_extension = []
            let any_required_capability = []
          end
        module Quantizationmodes =
          struct
            type t =
              | Rnd 
              | Rnd_conv 
              | Rnd_conv_odd 
              | Rnd_inf 
              | Rnd_min_inf 
              | Rnd_zero 
              | Trn 
              | Trn_zero [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rnd -> [2l]
              | Rnd_conv -> [6l]
              | Rnd_conv_odd -> [7l]
              | Rnd_inf -> [4l]
              | Rnd_min_inf -> [5l]
              | Rnd_zero -> [3l]
              | Trn -> [0l]
              | Trn_zero -> [1l]
            let any_required_version =
              function
              | Rnd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rnd_conv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rnd_conv_odd ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rnd_inf ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rnd_min_inf ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rnd_zero ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Trn ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Trn_zero ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Rnd -> [] |> Requirements.Extension.Set.of_list
              | Rnd_conv -> [] |> Requirements.Extension.Set.of_list
              | Rnd_conv_odd -> [] |> Requirements.Extension.Set.of_list
              | Rnd_inf -> [] |> Requirements.Extension.Set.of_list
              | Rnd_min_inf -> [] |> Requirements.Extension.Set.of_list
              | Rnd_zero -> [] |> Requirements.Extension.Set.of_list
              | Trn -> [] |> Requirements.Extension.Set.of_list
              | Trn_zero -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Rnd ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Rnd_conv ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Rnd_conv_odd ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Rnd_inf ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Rnd_min_inf ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Rnd_zero ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Trn ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
              | Trn_zero ->
                  [Capability.Arbitraryprecisionfixedpointaltera] |>
                    Capability.Set.of_list
          end
        module Rawaccesschainoperands =
          struct
            type t =
              | None 
              | Robustnesspercomponentnv 
              | Robustnessperelementnv [@@deriving
                                         compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | None -> [0l]
              | Robustnesspercomponentnv -> [1l]
              | Robustnessperelementnv -> [2l]
            let any_required_version =
              function
              | None ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Robustnesspercomponentnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Robustnessperelementnv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | None -> [] |> Requirements.Extension.Set.of_list
              | Robustnesspercomponentnv ->
                  [] |> Requirements.Extension.Set.of_list
              | Robustnessperelementnv ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | None -> [] |> Capability.Set.of_list
              | Robustnesspercomponentnv ->
                  [Capability.Rawaccesschainsnv] |> Capability.Set.of_list
              | Robustnessperelementnv ->
                  [Capability.Rawaccesschainsnv] |> Capability.Set.of_list
          end
        module Rayflags =
          struct
            type t =
              | Cullbackfacingtriangleskhr 
              | Cullfrontfacingtriangleskhr 
              | Cullnoopaquekhr 
              | Cullopaquekhr 
              | Forceopacitymicromap2stateext 
              | Nonekhr 
              | Noopaquekhr 
              | Opaquekhr 
              | Skipaabbskhr 
              | Skipclosesthitshaderkhr 
              | Skiptriangleskhr 
              | Terminateonfirsthitkhr [@@deriving
                                         compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Cullbackfacingtriangleskhr -> [16l]
              | Cullfrontfacingtriangleskhr -> [32l]
              | Cullnoopaquekhr -> [128l]
              | Cullopaquekhr -> [64l]
              | Forceopacitymicromap2stateext -> [1024l]
              | Nonekhr -> [0l]
              | Noopaquekhr -> [2l]
              | Opaquekhr -> [1l]
              | Skipaabbskhr -> [512l]
              | Skipclosesthitshaderkhr -> [8l]
              | Skiptriangleskhr -> [256l]
              | Terminateonfirsthitkhr -> [4l]
            let any_required_version =
              function
              | Cullbackfacingtriangleskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cullfrontfacingtriangleskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cullnoopaquekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Cullopaquekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Forceopacitymicromap2stateext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Noopaquekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Opaquekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Skipaabbskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Skipclosesthitshaderkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Skiptriangleskhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Terminateonfirsthitkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Cullbackfacingtriangleskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Cullfrontfacingtriangleskhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Cullnoopaquekhr -> [] |> Requirements.Extension.Set.of_list
              | Cullopaquekhr -> [] |> Requirements.Extension.Set.of_list
              | Forceopacitymicromap2stateext ->
                  [] |> Requirements.Extension.Set.of_list
              | Nonekhr -> [] |> Requirements.Extension.Set.of_list
              | Noopaquekhr -> [] |> Requirements.Extension.Set.of_list
              | Opaquekhr -> [] |> Requirements.Extension.Set.of_list
              | Skipaabbskhr -> [] |> Requirements.Extension.Set.of_list
              | Skipclosesthitshaderkhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Skiptriangleskhr -> [] |> Requirements.Extension.Set.of_list
              | Terminateonfirsthitkhr ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Cullbackfacingtriangleskhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Cullfrontfacingtriangleskhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Cullnoopaquekhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Cullopaquekhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Forceopacitymicromap2stateext ->
                  [Capability.Raytracingopacitymicromapext] |>
                    Capability.Set.of_list
              | Nonekhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Noopaquekhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Opaquekhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Skipaabbskhr ->
                  [Capability.Raytraversalprimitivecullingkhr] |>
                    Capability.Set.of_list
              | Skipclosesthitshaderkhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Skiptriangleskhr ->
                  [Capability.Raytraversalprimitivecullingkhr] |>
                    Capability.Set.of_list
              | Terminateonfirsthitkhr ->
                  [Capability.Rayquerykhr; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
          end
        module Rayquerycandidateintersectiontype =
          struct
            type t =
              | Rayquerycandidateintersectionaabbkhr 
              | Rayquerycandidateintersectiontrianglekhr [@@deriving
                                                           compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rayquerycandidateintersectionaabbkhr -> [1l]
              | Rayquerycandidateintersectiontrianglekhr -> [0l]
            let any_required_version =
              function
              | Rayquerycandidateintersectionaabbkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rayquerycandidateintersectiontrianglekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Rayquerycandidateintersectionaabbkhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Rayquerycandidateintersectiontrianglekhr ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Rayquerycandidateintersectionaabbkhr ->
                  [Capability.Rayquerykhr] |> Capability.Set.of_list
              | Rayquerycandidateintersectiontrianglekhr ->
                  [Capability.Rayquerykhr] |> Capability.Set.of_list
          end
        module Rayquerycommittedintersectiontype =
          struct
            type t =
              | Rayquerycommittedintersectiongeneratedkhr 
              | Rayquerycommittedintersectionnonekhr 
              | Rayquerycommittedintersectiontrianglekhr [@@deriving
                                                           compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rayquerycommittedintersectiongeneratedkhr -> [2l]
              | Rayquerycommittedintersectionnonekhr -> [0l]
              | Rayquerycommittedintersectiontrianglekhr -> [1l]
            let any_required_version =
              function
              | Rayquerycommittedintersectiongeneratedkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rayquerycommittedintersectionnonekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rayquerycommittedintersectiontrianglekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Rayquerycommittedintersectiongeneratedkhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Rayquerycommittedintersectionnonekhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Rayquerycommittedintersectiontrianglekhr ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Rayquerycommittedintersectiongeneratedkhr ->
                  [Capability.Rayquerykhr] |> Capability.Set.of_list
              | Rayquerycommittedintersectionnonekhr ->
                  [Capability.Rayquerykhr] |> Capability.Set.of_list
              | Rayquerycommittedintersectiontrianglekhr ->
                  [Capability.Rayquerykhr] |> Capability.Set.of_list
          end
        module Rayqueryintersection =
          struct
            type t =
              | Rayquerycandidateintersectionkhr 
              | Rayquerycommittedintersectionkhr [@@deriving
                                                   compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Rayquerycandidateintersectionkhr -> [0l]
              | Rayquerycommittedintersectionkhr -> [1l]
            let any_required_version =
              function
              | Rayquerycandidateintersectionkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rayquerycommittedintersectionkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Rayquerycandidateintersectionkhr ->
                  [] |> Requirements.Extension.Set.of_list
              | Rayquerycommittedintersectionkhr ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Rayquerycandidateintersectionkhr ->
                  [Capability.Rayquerykhr] |> Capability.Set.of_list
              | Rayquerycommittedintersectionkhr ->
                  [Capability.Rayquerykhr] |> Capability.Set.of_list
          end
        module Sampleraddressingmode =
          struct
            type t =
              | Clamp 
              | Clamptoedge 
              | None 
              | Repeat 
              | Repeatmirrored [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Clamp -> [2l]
              | Clamptoedge -> [1l]
              | None -> [0l]
              | Repeat -> [3l]
              | Repeatmirrored -> [4l]
            let any_required_version =
              function
              | Clamp ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Clamptoedge ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Repeat ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Repeatmirrored ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Clamp -> [] |> Requirements.Extension.Set.of_list
              | Clamptoedge -> [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
              | Repeat -> [] |> Requirements.Extension.Set.of_list
              | Repeatmirrored -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Clamp -> [] |> Capability.Set.of_list
              | Clamptoedge -> [] |> Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
              | Repeat -> [] |> Capability.Set.of_list
              | Repeatmirrored -> [] |> Capability.Set.of_list
          end
        module Samplerfiltermode =
          struct
            type t =
              | Linear 
              | Nearest [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value = function | Linear -> [1l] | Nearest -> [0l]
            let any_required_version =
              function
              | Linear ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nearest ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Linear -> [] |> Requirements.Extension.Set.of_list
              | Nearest -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Linear -> [] |> Capability.Set.of_list
              | Nearest -> [] |> Capability.Set.of_list
          end
        module Scope =
          struct
            type t =
              | Crossdevice 
              | Device 
              | Invocation 
              | Queuefamily 
              | Shadercallkhr 
              | Subgroup 
              | Workgroup [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Crossdevice -> [0l]
              | Device -> [1l]
              | Invocation -> [4l]
              | Queuefamily -> [5l]
              | Shadercallkhr -> [6l]
              | Subgroup -> [3l]
              | Workgroup -> [2l]
            let any_required_version =
              function
              | Crossdevice ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Device ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Invocation ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Queuefamily ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shadercallkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Subgroup ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workgroup ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Crossdevice -> [] |> Requirements.Extension.Set.of_list
              | Device -> [] |> Requirements.Extension.Set.of_list
              | Invocation -> [] |> Requirements.Extension.Set.of_list
              | Queuefamily -> [] |> Requirements.Extension.Set.of_list
              | Shadercallkhr -> [] |> Requirements.Extension.Set.of_list
              | Subgroup -> [] |> Requirements.Extension.Set.of_list
              | Workgroup -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Crossdevice -> [] |> Capability.Set.of_list
              | Device -> [] |> Capability.Set.of_list
              | Invocation -> [] |> Capability.Set.of_list
              | Queuefamily ->
                  [Capability.Vulkanmemorymodel] |> Capability.Set.of_list
              | Shadercallkhr ->
                  [Capability.Raytracingkhr] |> Capability.Set.of_list
              | Subgroup -> [] |> Capability.Set.of_list
              | Workgroup -> [] |> Capability.Set.of_list
          end
        module Selectioncontrol =
          struct
            type t =
              | Dontflatten 
              | Flatten 
              | None [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function | Dontflatten -> [2l] | Flatten -> [1l] | None -> [0l]
            let any_required_version =
              function
              | Dontflatten ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Flatten ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Dontflatten -> [] |> Requirements.Extension.Set.of_list
              | Flatten -> [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Dontflatten -> [] |> Capability.Set.of_list
              | Flatten -> [] |> Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
          end
        module Sourcelanguage =
          struct
            type t =
              | Cpp_for_opencl 
              | Essl 
              | Glsl 
              | Hero_c 
              | Hlsl 
              | Nzsl 
              | Opencl_c 
              | Opencl_cpp 
              | Rust 
              | Slang 
              | Sycl 
              | Unknown 
              | Wgsl 
              | Zig [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Cpp_for_opencl -> [6l]
              | Essl -> [1l]
              | Glsl -> [2l]
              | Hero_c -> [8l]
              | Hlsl -> [5l]
              | Nzsl -> [9l]
              | Opencl_c -> [3l]
              | Opencl_cpp -> [4l]
              | Rust -> [13l]
              | Slang -> [11l]
              | Sycl -> [7l]
              | Unknown -> [0l]
              | Wgsl -> [10l]
              | Zig -> [12l]
            let any_required_version =
              function
              | Cpp_for_opencl ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Essl ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Glsl ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hero_c ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hlsl ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nzsl ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Opencl_c ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Opencl_cpp ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Rust ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Slang ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Sycl ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Unknown ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Wgsl ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Zig ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Cpp_for_opencl -> [] |> Requirements.Extension.Set.of_list
              | Essl -> [] |> Requirements.Extension.Set.of_list
              | Glsl -> [] |> Requirements.Extension.Set.of_list
              | Hero_c -> [] |> Requirements.Extension.Set.of_list
              | Hlsl -> [] |> Requirements.Extension.Set.of_list
              | Nzsl -> [] |> Requirements.Extension.Set.of_list
              | Opencl_c -> [] |> Requirements.Extension.Set.of_list
              | Opencl_cpp -> [] |> Requirements.Extension.Set.of_list
              | Rust -> [] |> Requirements.Extension.Set.of_list
              | Slang -> [] |> Requirements.Extension.Set.of_list
              | Sycl -> [] |> Requirements.Extension.Set.of_list
              | Unknown -> [] |> Requirements.Extension.Set.of_list
              | Wgsl -> [] |> Requirements.Extension.Set.of_list
              | Zig -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Cpp_for_opencl -> [] |> Capability.Set.of_list
              | Essl -> [] |> Capability.Set.of_list
              | Glsl -> [] |> Capability.Set.of_list
              | Hero_c -> [] |> Capability.Set.of_list
              | Hlsl -> [] |> Capability.Set.of_list
              | Nzsl -> [] |> Capability.Set.of_list
              | Opencl_c -> [] |> Capability.Set.of_list
              | Opencl_cpp -> [] |> Capability.Set.of_list
              | Rust -> [] |> Capability.Set.of_list
              | Slang -> [] |> Capability.Set.of_list
              | Sycl -> [] |> Capability.Set.of_list
              | Unknown -> [] |> Capability.Set.of_list
              | Wgsl -> [] |> Capability.Set.of_list
              | Zig -> [] |> Capability.Set.of_list
          end
        module Storageclass =
          struct
            type t =
              | Atomiccounter 
              | Callabledatakhr 
              | Codesectionintel 
              | Crossworkgroup 
              | Deviceonlyaltera 
              | Function 
              | Generic 
              | Hitattributekhr 
              | Hitobjectattributeext 
              | Hitobjectattributenv 
              | Hostonlyaltera 
              | Image 
              | Incomingcallabledatakhr 
              | Incomingraypayloadkhr 
              | Input 
              | Nodepayloadamdx 
              | Output 
              | Physicalstoragebuffer 
              | Private 
              | Pushconstant 
              | Raypayloadkhr 
              | Shaderrecordbufferkhr 
              | Storagebuffer 
              | Taskpayloadworkgroupext 
              | Tileattachmentqcom 
              | Tileimageext 
              | Uniform 
              | Uniformconstant 
              | Workgroup [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Atomiccounter -> [10l]
              | Callabledatakhr -> [5328l]
              | Codesectionintel -> [5605l]
              | Crossworkgroup -> [5l]
              | Deviceonlyaltera -> [5936l]
              | Function -> [7l]
              | Generic -> [8l]
              | Hitattributekhr -> [5339l]
              | Hitobjectattributeext -> [5411l]
              | Hitobjectattributenv -> [5385l]
              | Hostonlyaltera -> [5937l]
              | Image -> [11l]
              | Incomingcallabledatakhr -> [5329l]
              | Incomingraypayloadkhr -> [5342l]
              | Input -> [1l]
              | Nodepayloadamdx -> [5068l]
              | Output -> [3l]
              | Physicalstoragebuffer -> [5349l]
              | Private -> [6l]
              | Pushconstant -> [9l]
              | Raypayloadkhr -> [5338l]
              | Shaderrecordbufferkhr -> [5343l]
              | Storagebuffer -> [12l]
              | Taskpayloadworkgroupext -> [5402l]
              | Tileattachmentqcom -> [4491l]
              | Tileimageext -> [4172l]
              | Uniform -> [2l]
              | Uniformconstant -> [0l]
              | Workgroup -> [4l]
            let any_required_version =
              function
              | Atomiccounter ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Callabledatakhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Codesectionintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Crossworkgroup ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Deviceonlyaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Function ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Generic ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitattributekhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitobjectattributeext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hitobjectattributenv ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Hostonlyaltera ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Image ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Incomingcallabledatakhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Incomingraypayloadkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Input ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nodepayloadamdx ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Output ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Physicalstoragebuffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_5)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Private ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Pushconstant ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Raypayloadkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Shaderrecordbufferkhr ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Storagebuffer ->
                  (Requirements.Version.valid_versions ~required:(Some V1_3)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Taskpayloadworkgroupext ->
                  (Requirements.Version.valid_versions ~required:(Some V1_4)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileattachmentqcom ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tileimageext ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniform ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uniformconstant ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Workgroup ->
                  (Requirements.Version.valid_versions ~required:(Some V1_0)
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Atomiccounter -> [] |> Requirements.Extension.Set.of_list
              | Callabledatakhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Codesectionintel ->
                  [Requirements.Extension.Spv_intel_function_pointers] |>
                    Requirements.Extension.Set.of_list
              | Crossworkgroup -> [] |> Requirements.Extension.Set.of_list
              | Deviceonlyaltera -> [] |> Requirements.Extension.Set.of_list
              | Function -> [] |> Requirements.Extension.Set.of_list
              | Generic -> [] |> Requirements.Extension.Set.of_list
              | Hitattributekhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Hitobjectattributeext ->
                  [] |> Requirements.Extension.Set.of_list
              | Hitobjectattributenv ->
                  [] |> Requirements.Extension.Set.of_list
              | Hostonlyaltera -> [] |> Requirements.Extension.Set.of_list
              | Image -> [] |> Requirements.Extension.Set.of_list
              | Incomingcallabledatakhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Incomingraypayloadkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Input -> [] |> Requirements.Extension.Set.of_list
              | Nodepayloadamdx -> [] |> Requirements.Extension.Set.of_list
              | Output -> [] |> Requirements.Extension.Set.of_list
              | Physicalstoragebuffer ->
                  [Requirements.Extension.Spv_ext_physical_storage_buffer;
                  Requirements.Extension.Spv_khr_physical_storage_buffer] |>
                    Requirements.Extension.Set.of_list
              | Private -> [] |> Requirements.Extension.Set.of_list
              | Pushconstant -> [] |> Requirements.Extension.Set.of_list
              | Raypayloadkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Shaderrecordbufferkhr ->
                  [Requirements.Extension.Spv_nv_ray_tracing;
                  Requirements.Extension.Spv_khr_ray_tracing] |>
                    Requirements.Extension.Set.of_list
              | Storagebuffer ->
                  [Requirements.Extension.Spv_khr_storage_buffer_storage_class;
                  Requirements.Extension.Spv_khr_variable_pointers] |>
                    Requirements.Extension.Set.of_list
              | Taskpayloadworkgroupext ->
                  [Requirements.Extension.Spv_ext_mesh_shader] |>
                    Requirements.Extension.Set.of_list
              | Tileattachmentqcom ->
                  [] |> Requirements.Extension.Set.of_list
              | Tileimageext -> [] |> Requirements.Extension.Set.of_list
              | Uniform -> [] |> Requirements.Extension.Set.of_list
              | Uniformconstant -> [] |> Requirements.Extension.Set.of_list
              | Workgroup -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Atomiccounter ->
                  [Capability.Atomicstorage] |> Capability.Set.of_list
              | Callabledatakhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Codesectionintel ->
                  [Capability.Functionpointersintel] |>
                    Capability.Set.of_list
              | Crossworkgroup -> [] |> Capability.Set.of_list
              | Deviceonlyaltera ->
                  [Capability.Usmstorageclassesaltera] |>
                    Capability.Set.of_list
              | Function -> [] |> Capability.Set.of_list
              | Generic ->
                  [Capability.Genericpointer] |> Capability.Set.of_list
              | Hitattributekhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Hitobjectattributeext ->
                  [Capability.Shaderinvocationreorderext] |>
                    Capability.Set.of_list
              | Hitobjectattributenv ->
                  [Capability.Shaderinvocationreordernv] |>
                    Capability.Set.of_list
              | Hostonlyaltera ->
                  [Capability.Usmstorageclassesaltera] |>
                    Capability.Set.of_list
              | Image -> [] |> Capability.Set.of_list
              | Incomingcallabledatakhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Incomingraypayloadkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Input -> [] |> Capability.Set.of_list
              | Nodepayloadamdx ->
                  [Capability.Shaderenqueueamdx] |> Capability.Set.of_list
              | Output -> [Capability.Shader] |> Capability.Set.of_list
              | Physicalstoragebuffer ->
                  [Capability.Physicalstoragebufferaddresses] |>
                    Capability.Set.of_list
              | Private ->
                  [Capability.Shader; Capability.Vectorcomputeintel] |>
                    Capability.Set.of_list
              | Pushconstant -> [Capability.Shader] |> Capability.Set.of_list
              | Raypayloadkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Shaderrecordbufferkhr ->
                  [Capability.Raytracingnv; Capability.Raytracingkhr] |>
                    Capability.Set.of_list
              | Storagebuffer ->
                  [Capability.Shader] |> Capability.Set.of_list
              | Taskpayloadworkgroupext ->
                  [Capability.Meshshadingext] |> Capability.Set.of_list
              | Tileattachmentqcom ->
                  [Capability.Tileshadingqcom] |> Capability.Set.of_list
              | Tileimageext ->
                  [Capability.Tileimagecolorreadaccessext] |>
                    Capability.Set.of_list
              | Uniform -> [Capability.Shader] |> Capability.Set.of_list
              | Uniformconstant -> [] |> Capability.Set.of_list
              | Workgroup -> [] |> Capability.Set.of_list
          end
        module Storecachecontrol =
          struct
            type t =
              | Streamingintel 
              | Uncachedintel 
              | Writebackintel 
              | Writethroughintel [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Streamingintel -> [3l]
              | Uncachedintel -> [0l]
              | Writebackintel -> [2l]
              | Writethroughintel -> [1l]
            let any_required_version =
              function
              | Streamingintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Uncachedintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Writebackintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Writethroughintel ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Streamingintel -> [] |> Requirements.Extension.Set.of_list
              | Uncachedintel -> [] |> Requirements.Extension.Set.of_list
              | Writebackintel -> [] |> Requirements.Extension.Set.of_list
              | Writethroughintel -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Streamingintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Uncachedintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Writebackintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
              | Writethroughintel ->
                  [Capability.Cachecontrolsintel] |> Capability.Set.of_list
          end
        module Tensoraddressingoperands =
          struct
            type t =
              | Decodefunc 
              | None 
              | Tensorview [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Decodefunc -> [2l]
              | None -> [0l]
              | Tensorview -> [1l]
            let any_required_version =
              function
              | Decodefunc ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | None ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Tensorview ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Decodefunc -> [] |> Requirements.Extension.Set.of_list
              | None -> [] |> Requirements.Extension.Set.of_list
              | Tensorview -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Decodefunc ->
                  [Capability.Cooperativematrixblockloadsnv] |>
                    Capability.Set.of_list
              | None -> [] |> Capability.Set.of_list
              | Tensorview ->
                  [Capability.Cooperativematrixtensoraddressingnv] |>
                    Capability.Set.of_list
          end
        module Tensorclampmode =
          struct
            type t =
              | Clamptoedge 
              | Constant 
              | Repeat 
              | Repeatmirrored 
              | Undefined [@@deriving compare, sexp_of, enumerate]
            let category = Category.Valueenum
            let doc = None
            let value =
              function
              | Clamptoedge -> [2l]
              | Constant -> [1l]
              | Repeat -> [3l]
              | Repeatmirrored -> [4l]
              | Undefined -> [0l]
            let any_required_version =
              function
              | Clamptoedge ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Constant ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Repeat ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Repeatmirrored ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Undefined ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Clamptoedge -> [] |> Requirements.Extension.Set.of_list
              | Constant -> [] |> Requirements.Extension.Set.of_list
              | Repeat -> [] |> Requirements.Extension.Set.of_list
              | Repeatmirrored -> [] |> Requirements.Extension.Set.of_list
              | Undefined -> [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Clamptoedge -> [] |> Capability.Set.of_list
              | Constant -> [] |> Capability.Set.of_list
              | Repeat -> [] |> Capability.Set.of_list
              | Repeatmirrored -> [] |> Capability.Set.of_list
              | Undefined -> [] |> Capability.Set.of_list
          end
        module Tensoroperands =
          struct
            type t =
              | Makeelementavailablearm 
              | Makeelementvisiblearm 
              | Nonearm 
              | Nonprivateelementarm 
              | Nontemporalarm 
              | Outofboundsvaluearm [@@deriving compare, sexp_of, enumerate]
            let category = Category.Bitenum
            let doc = None
            let value =
              function
              | Makeelementavailablearm -> [4l]
              | Makeelementvisiblearm -> [8l]
              | Nonearm -> [0l]
              | Nonprivateelementarm -> [16l]
              | Nontemporalarm -> [1l]
              | Outofboundsvaluearm -> [2l]
            let any_required_version =
              function
              | Makeelementavailablearm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Makeelementvisiblearm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonearm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nonprivateelementarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Nontemporalarm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
              | Outofboundsvaluearm ->
                  (Requirements.Version.valid_versions ~required:None
                     ~last:None)
                    |> Requirements.Version.Set.of_list
            let any_required_extension =
              function
              | Makeelementavailablearm ->
                  [] |> Requirements.Extension.Set.of_list
              | Makeelementvisiblearm ->
                  [] |> Requirements.Extension.Set.of_list
              | Nonearm -> [] |> Requirements.Extension.Set.of_list
              | Nonprivateelementarm ->
                  [] |> Requirements.Extension.Set.of_list
              | Nontemporalarm -> [] |> Requirements.Extension.Set.of_list
              | Outofboundsvaluearm ->
                  [] |> Requirements.Extension.Set.of_list
            let any_required_capability =
              function
              | Makeelementavailablearm ->
                  [Capability.Tensorsarm] |> Capability.Set.of_list
              | Makeelementvisiblearm ->
                  [Capability.Tensorsarm] |> Capability.Set.of_list
              | Nonearm -> [Capability.Tensorsarm] |> Capability.Set.of_list
              | Nonprivateelementarm ->
                  [Capability.Tensorsarm] |> Capability.Set.of_list
              | Nontemporalarm ->
                  [Capability.Tensorsarm] |> Capability.Set.of_list
              | Outofboundsvaluearm ->
                  [Capability.Tensorsarm] |> Capability.Set.of_list
          end
      end
  end
module Instruction =
  struct
    module Annotation =
      struct
        type t =
          | Opdecorate of
          {
          target: Operand_kind.Payload.Idref.t ;
          decoration: Operand_kind.Payload.Decoration.t } 
          | Opdecorateid of
          {
          target: Operand_kind.Payload.Idref.t ;
          decoration: Operand_kind.Payload.Decoration.t } 
          | Opdecoratestring of
          {
          target: Operand_kind.Payload.Idref.t ;
          decoration: Operand_kind.Payload.Decoration.t } 
          | Opdecorationgroup of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opgroupdecorate of
          {
          decorationgroup: Operand_kind.Payload.Idref.t ;
          targets: Operand_kind.Payload.Idref.t list } 
          | Opgroupmemberdecorate of
          {
          decorationgroup: Operand_kind.Payload.Idref.t ;
          targets: Operand_kind.Payload.Pairidrefliteralinteger.t list } 
          | Opmemberdecorate of
          {
          structuretype: Operand_kind.Payload.Idref.t ;
          member: Operand_kind.Payload.Literalinteger.t ;
          decoration: Operand_kind.Payload.Decoration.t } 
          | Opmemberdecoratestring of
          {
          structtype: Operand_kind.Payload.Idref.t ;
          member: Operand_kind.Payload.Literalinteger.t ;
          decoration: Operand_kind.Payload.Decoration.t } [@@deriving
                                                            compare, sexp_of]
        let provisional =
          function
          | Opdecorate _ -> false
          | Opdecorateid _ -> false
          | Opdecoratestring _ -> false
          | Opdecorationgroup _ -> false
          | Opgroupdecorate _ -> false
          | Opgroupmemberdecorate _ -> false
          | Opmemberdecorate _ -> false
          | Opmemberdecoratestring _ -> false
        let value =
          function
          | Opdecorate t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Decoration.value t.decoration] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 71l in
              heading :: payload
          | Opdecorateid t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Decoration.value t.decoration] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 332l in
              heading :: payload
          | Opdecoratestring t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Decoration.value t.decoration] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5632l in
              heading :: payload
          | Opdecorationgroup t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 73l in
              heading :: payload
          | Opgroupdecorate t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.decorationgroup;
                  List.concat_map t.targets
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 74l in
              heading :: payload
          | Opgroupmemberdecorate t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.decorationgroup;
                  List.concat_map t.targets
                    ~f:Operand_kind.Payload.Pairidrefliteralinteger.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 75l in
              heading :: payload
          | Opmemberdecorate t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.structuretype;
                  Operand_kind.Payload.Literalinteger.value t.member;
                  Operand_kind.Payload.Decoration.value t.decoration] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 72l in
              heading :: payload
          | Opmemberdecoratestring t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.structtype;
                  Operand_kind.Payload.Literalinteger.value t.member;
                  Operand_kind.Payload.Decoration.value t.decoration] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5633l in
              heading :: payload
        let any_required_version =
          function
          | Opdecorate _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdecorateid _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_2)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdecoratestring _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_4)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdecorationgroup _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupdecorate _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupmemberdecorate _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmemberdecorate _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmemberdecoratestring _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_4)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opdecorate _ -> [] |> Requirements.Extension.Set.of_list
          | Opdecorateid _ ->
              [Requirements.Extension.Spv_google_hlsl_functionality1] |>
                Requirements.Extension.Set.of_list
          | Opdecoratestring _ ->
              [Requirements.Extension.Spv_google_decorate_string;
              Requirements.Extension.Spv_google_hlsl_functionality1] |>
                Requirements.Extension.Set.of_list
          | Opdecorationgroup _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupdecorate _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupmemberdecorate _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opmemberdecorate _ -> [] |> Requirements.Extension.Set.of_list
          | Opmemberdecoratestring _ ->
              [Requirements.Extension.Spv_google_decorate_string;
              Requirements.Extension.Spv_google_hlsl_functionality1] |>
                Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opdecorate _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opdecorateid _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opdecoratestring _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opdecorationgroup _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupdecorate _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupmemberdecorate _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opmemberdecorate _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opmemberdecoratestring _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Arithmetic =
      struct
        type t =
          | Opcooperativematrixmuladdkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          b: Operand_kind.Payload.Idref.t ;
          c: Operand_kind.Payload.Idref.t ;
          cooperativematrixoperands:
            Operand_kind.Payload.Cooperativematrixoperands.t option }
          
          | Opcooperativematrixreducenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          reduce: Operand_kind.Payload.Cooperativematrixreduce.t ;
          combinefunc: Operand_kind.Payload.Idref.t } 
          | Opdot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t } 
          | Opfadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfdiv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfmakhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t ;
          operand3: Operand_kind.Payload.Idref.t } 
          | Opfmod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfmul of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfnegate of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opfrem of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfsub of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiaddcarry of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opimul of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opisub of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opisubborrow of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opmatrixtimesmatrix of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          leftmatrix: Operand_kind.Payload.Idref.t ;
          rightmatrix: Operand_kind.Payload.Idref.t } 
          | Opmatrixtimesscalar of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          scalar: Operand_kind.Payload.Idref.t } 
          | Opmatrixtimesvector of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          vector: Operand_kind.Payload.Idref.t } 
          | Opouterproduct of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t } 
          | Opsdiv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsdot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opsdotaccsat of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          accumulator: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opsmod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsmulextended of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsnegate of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opsrem of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsudot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opsudotaccsat of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          accumulator: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opudiv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opudot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opudotaccsat of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          accumulator: Operand_kind.Payload.Idref.t ;
          packedvectorformat:
            Operand_kind.Payload.Packedvectorformat.t option }
          
          | Opumod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opumulextended of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opvectortimesmatrix of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t ;
          matrix: Operand_kind.Payload.Idref.t } 
          | Opvectortimesscalar of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t ;
          scalar: Operand_kind.Payload.Idref.t } [@@deriving
                                                   compare, sexp_of]
        let provisional =
          function
          | Opcooperativematrixmuladdkhr _ -> false
          | Opcooperativematrixreducenv _ -> false
          | Opdot _ -> false
          | Opfadd _ -> false
          | Opfdiv _ -> false
          | Opfmakhr _ -> false
          | Opfmod _ -> false
          | Opfmul _ -> false
          | Opfnegate _ -> false
          | Opfrem _ -> false
          | Opfsub _ -> false
          | Opiadd _ -> false
          | Opiaddcarry _ -> false
          | Opimul _ -> false
          | Opisub _ -> false
          | Opisubborrow _ -> false
          | Opmatrixtimesmatrix _ -> false
          | Opmatrixtimesscalar _ -> false
          | Opmatrixtimesvector _ -> false
          | Opouterproduct _ -> false
          | Opsdiv _ -> false
          | Opsdot _ -> false
          | Opsdotaccsat _ -> false
          | Opsmod _ -> false
          | Opsmulextended _ -> false
          | Opsnegate _ -> false
          | Opsrem _ -> false
          | Opsudot _ -> false
          | Opsudotaccsat _ -> false
          | Opudiv _ -> false
          | Opudot _ -> false
          | Opudotaccsat _ -> false
          | Opumod _ -> false
          | Opumulextended _ -> false
          | Opvectortimesmatrix _ -> false
          | Opvectortimesscalar _ -> false
        let value =
          function
          | Opcooperativematrixmuladdkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Idref.value t.c;
                  (t.cooperativematrixoperands |>
                     (Option.map
                        ~f:Operand_kind.Payload.Cooperativematrixoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4459l in
              heading :: payload
          | Opcooperativematrixreducenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.matrix;
                  Operand_kind.Payload.Cooperativematrixreduce.value t.reduce;
                  Operand_kind.Payload.Idref.value t.combinefunc] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5366l in
              heading :: payload
          | Opdot t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 148l in
              heading :: payload
          | Opfadd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 129l in
              heading :: payload
          | Opfdiv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 136l in
              heading :: payload
          | Opfmakhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2;
                  Operand_kind.Payload.Idref.value t.operand3] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4427l in
              heading :: payload
          | Opfmod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 141l in
              heading :: payload
          | Opfmul t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 133l in
              heading :: payload
          | Opfnegate t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 127l in
              heading :: payload
          | Opfrem t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 140l in
              heading :: payload
          | Opfsub t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 131l in
              heading :: payload
          | Opiadd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 128l in
              heading :: payload
          | Opiaddcarry t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 149l in
              heading :: payload
          | Opimul t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 132l in
              heading :: payload
          | Opisub t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 130l in
              heading :: payload
          | Opisubborrow t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 150l in
              heading :: payload
          | Opmatrixtimesmatrix t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.leftmatrix;
                  Operand_kind.Payload.Idref.value t.rightmatrix] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 146l in
              heading :: payload
          | Opmatrixtimesscalar t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.matrix;
                  Operand_kind.Payload.Idref.value t.scalar] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 143l in
              heading :: payload
          | Opmatrixtimesvector t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.matrix;
                  Operand_kind.Payload.Idref.value t.vector] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 145l in
              heading :: payload
          | Opouterproduct t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 147l in
              heading :: payload
          | Opsdiv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 135l in
              heading :: payload
          | Opsdot t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2;
                  (t.packedvectorformat |>
                     (Option.map
                        ~f:Operand_kind.Payload.Packedvectorformat.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4450l in
              heading :: payload
          | Opsdotaccsat t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2;
                  Operand_kind.Payload.Idref.value t.accumulator;
                  (t.packedvectorformat |>
                     (Option.map
                        ~f:Operand_kind.Payload.Packedvectorformat.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4453l in
              heading :: payload
          | Opsmod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 139l in
              heading :: payload
          | Opsmulextended t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 152l in
              heading :: payload
          | Opsnegate t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 126l in
              heading :: payload
          | Opsrem t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 138l in
              heading :: payload
          | Opsudot t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2;
                  (t.packedvectorformat |>
                     (Option.map
                        ~f:Operand_kind.Payload.Packedvectorformat.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4452l in
              heading :: payload
          | Opsudotaccsat t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2;
                  Operand_kind.Payload.Idref.value t.accumulator;
                  (t.packedvectorformat |>
                     (Option.map
                        ~f:Operand_kind.Payload.Packedvectorformat.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4455l in
              heading :: payload
          | Opudiv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 134l in
              heading :: payload
          | Opudot t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2;
                  (t.packedvectorformat |>
                     (Option.map
                        ~f:Operand_kind.Payload.Packedvectorformat.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4451l in
              heading :: payload
          | Opudotaccsat t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2;
                  Operand_kind.Payload.Idref.value t.accumulator;
                  (t.packedvectorformat |>
                     (Option.map
                        ~f:Operand_kind.Payload.Packedvectorformat.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4454l in
              heading :: payload
          | Opumod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 137l in
              heading :: payload
          | Opumulextended t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 151l in
              heading :: payload
          | Opvectortimesmatrix t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector;
                  Operand_kind.Payload.Idref.value t.matrix] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 144l in
              heading :: payload
          | Opvectortimesscalar t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector;
                  Operand_kind.Payload.Idref.value t.scalar] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 142l in
              heading :: payload
        let any_required_version =
          function
          | Opcooperativematrixmuladdkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixreducenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdot _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfadd _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfdiv _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfmakhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfmod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfmul _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfnegate _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfrem _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfsub _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opiadd _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opiaddcarry _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimul _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisub _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisubborrow _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmatrixtimesmatrix _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmatrixtimesscalar _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmatrixtimesvector _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opouterproduct _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsdiv _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsdot _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_6)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsdotaccsat _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_6)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsmod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsmulextended _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsnegate _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsrem _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsudot _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_6)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsudotaccsat _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_6)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opudiv _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opudot _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_6)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opudotaccsat _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_6)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opumod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opumulextended _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opvectortimesmatrix _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opvectortimesscalar _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opcooperativematrixmuladdkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativematrixreducenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opdot _ -> [] |> Requirements.Extension.Set.of_list
          | Opfadd _ -> [] |> Requirements.Extension.Set.of_list
          | Opfdiv _ -> [] |> Requirements.Extension.Set.of_list
          | Opfmakhr _ -> [] |> Requirements.Extension.Set.of_list
          | Opfmod _ -> [] |> Requirements.Extension.Set.of_list
          | Opfmul _ -> [] |> Requirements.Extension.Set.of_list
          | Opfnegate _ -> [] |> Requirements.Extension.Set.of_list
          | Opfrem _ -> [] |> Requirements.Extension.Set.of_list
          | Opfsub _ -> [] |> Requirements.Extension.Set.of_list
          | Opiadd _ -> [] |> Requirements.Extension.Set.of_list
          | Opiaddcarry _ -> [] |> Requirements.Extension.Set.of_list
          | Opimul _ -> [] |> Requirements.Extension.Set.of_list
          | Opisub _ -> [] |> Requirements.Extension.Set.of_list
          | Opisubborrow _ -> [] |> Requirements.Extension.Set.of_list
          | Opmatrixtimesmatrix _ -> [] |> Requirements.Extension.Set.of_list
          | Opmatrixtimesscalar _ -> [] |> Requirements.Extension.Set.of_list
          | Opmatrixtimesvector _ -> [] |> Requirements.Extension.Set.of_list
          | Opouterproduct _ -> [] |> Requirements.Extension.Set.of_list
          | Opsdiv _ -> [] |> Requirements.Extension.Set.of_list
          | Opsdot _ ->
              [Requirements.Extension.Spv_khr_integer_dot_product] |>
                Requirements.Extension.Set.of_list
          | Opsdotaccsat _ ->
              [Requirements.Extension.Spv_khr_integer_dot_product] |>
                Requirements.Extension.Set.of_list
          | Opsmod _ -> [] |> Requirements.Extension.Set.of_list
          | Opsmulextended _ -> [] |> Requirements.Extension.Set.of_list
          | Opsnegate _ -> [] |> Requirements.Extension.Set.of_list
          | Opsrem _ -> [] |> Requirements.Extension.Set.of_list
          | Opsudot _ ->
              [Requirements.Extension.Spv_khr_integer_dot_product] |>
                Requirements.Extension.Set.of_list
          | Opsudotaccsat _ ->
              [Requirements.Extension.Spv_khr_integer_dot_product] |>
                Requirements.Extension.Set.of_list
          | Opudiv _ -> [] |> Requirements.Extension.Set.of_list
          | Opudot _ ->
              [Requirements.Extension.Spv_khr_integer_dot_product] |>
                Requirements.Extension.Set.of_list
          | Opudotaccsat _ ->
              [Requirements.Extension.Spv_khr_integer_dot_product] |>
                Requirements.Extension.Set.of_list
          | Opumod _ -> [] |> Requirements.Extension.Set.of_list
          | Opumulextended _ -> [] |> Requirements.Extension.Set.of_list
          | Opvectortimesmatrix _ -> [] |> Requirements.Extension.Set.of_list
          | Opvectortimesscalar _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opcooperativematrixmuladdkhr _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixreducenv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixreductionsnv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opdot _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfadd _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfdiv _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfmakhr _ ->
              [Operand_kind.Payload.Capability.Fmakhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfmod _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfmul _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfnegate _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfrem _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfsub _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opiadd _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opiaddcarry _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opimul _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opisub _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opisubborrow _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opmatrixtimesmatrix _ ->
              [Operand_kind.Payload.Capability.Matrix] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opmatrixtimesscalar _ ->
              [Operand_kind.Payload.Capability.Matrix] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opmatrixtimesvector _ ->
              [Operand_kind.Payload.Capability.Matrix] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opouterproduct _ ->
              [Operand_kind.Payload.Capability.Matrix] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsdiv _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsdot _ ->
              [Operand_kind.Payload.Capability.Dotproduct] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsdotaccsat _ ->
              [Operand_kind.Payload.Capability.Dotproduct] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsmod _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsmulextended _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsnegate _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsrem _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsudot _ ->
              [Operand_kind.Payload.Capability.Dotproduct] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsudotaccsat _ ->
              [Operand_kind.Payload.Capability.Dotproduct] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opudiv _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opudot _ ->
              [Operand_kind.Payload.Capability.Dotproduct] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opudotaccsat _ ->
              [Operand_kind.Payload.Capability.Dotproduct] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opumod _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opumulextended _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opvectortimesmatrix _ ->
              [Operand_kind.Payload.Capability.Matrix] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opvectortimesscalar _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Atomic =
      struct
        type t =
          | Opatomicand of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomiccompareexchange of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          equal: Operand_kind.Payload.Idmemorysemantics.t ;
          unequal: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t ;
          comparator: Operand_kind.Payload.Idref.t } 
          | Opatomiccompareexchangeweak of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          equal: Operand_kind.Payload.Idmemorysemantics.t ;
          unequal: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t ;
          comparator: Operand_kind.Payload.Idref.t } 
          | Opatomicexchange of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicfaddext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicflagclear of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomicflagtestandset of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomicfmaxext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicfminext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomiciadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicidecrement of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomiciincrement of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomicisub of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicload of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opatomicor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicsmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicsmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicstore of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicumax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicumin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opatomicxor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t ;
          value: Operand_kind.Payload.Idref.t } [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opatomicand _ -> false
          | Opatomiccompareexchange _ -> false
          | Opatomiccompareexchangeweak _ -> false
          | Opatomicexchange _ -> false
          | Opatomicfaddext _ -> false
          | Opatomicflagclear _ -> false
          | Opatomicflagtestandset _ -> false
          | Opatomicfmaxext _ -> false
          | Opatomicfminext _ -> false
          | Opatomiciadd _ -> false
          | Opatomicidecrement _ -> false
          | Opatomiciincrement _ -> false
          | Opatomicisub _ -> false
          | Opatomicload _ -> false
          | Opatomicor _ -> false
          | Opatomicsmax _ -> false
          | Opatomicsmin _ -> false
          | Opatomicstore _ -> false
          | Opatomicumax _ -> false
          | Opatomicumin _ -> false
          | Opatomicxor _ -> false
        let value =
          function
          | Opatomicand t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 240l in
              heading :: payload
          | Opatomiccompareexchange t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.equal;
                  Operand_kind.Payload.Idmemorysemantics.value t.unequal;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.comparator] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 230l in
              heading :: payload
          | Opatomiccompareexchangeweak t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.equal;
                  Operand_kind.Payload.Idmemorysemantics.value t.unequal;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.comparator] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 231l in
              heading :: payload
          | Opatomicexchange t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 229l in
              heading :: payload
          | Opatomicfaddext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6035l in
              heading :: payload
          | Opatomicflagclear t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 319l in
              heading :: payload
          | Opatomicflagtestandset t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 318l in
              heading :: payload
          | Opatomicfmaxext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5615l in
              heading :: payload
          | Opatomicfminext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5614l in
              heading :: payload
          | Opatomiciadd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 234l in
              heading :: payload
          | Opatomicidecrement t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 233l in
              heading :: payload
          | Opatomiciincrement t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 232l in
              heading :: payload
          | Opatomicisub t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 235l in
              heading :: payload
          | Opatomicload t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 227l in
              heading :: payload
          | Opatomicor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 241l in
              heading :: payload
          | Opatomicsmax t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 238l in
              heading :: payload
          | Opatomicsmin t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 236l in
              heading :: payload
          | Opatomicstore t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 228l in
              heading :: payload
          | Opatomicumax t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 239l in
              heading :: payload
          | Opatomicumin t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 237l in
              heading :: payload
          | Opatomicxor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 242l in
              heading :: payload
        let any_required_version =
          function
          | Opatomicand _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomiccompareexchange _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomiccompareexchangeweak _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:(Some V1_3))
                |> Requirements.Version.Set.of_list
          | Opatomicexchange _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicfaddext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicflagclear _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicflagtestandset _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicfmaxext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicfminext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomiciadd _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicidecrement _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomiciincrement _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicisub _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicload _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicsmax _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicsmin _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicstore _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicumax _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicumin _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opatomicxor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opatomicand _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomiccompareexchange _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opatomiccompareexchangeweak _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opatomicexchange _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicfaddext _ ->
              [Requirements.Extension.Spv_ext_shader_atomic_float_add] |>
                Requirements.Extension.Set.of_list
          | Opatomicflagclear _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicflagtestandset _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opatomicfmaxext _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicfminext _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomiciadd _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicidecrement _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomiciincrement _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicisub _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicload _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicor _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicsmax _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicsmin _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicstore _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicumax _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicumin _ -> [] |> Requirements.Extension.Set.of_list
          | Opatomicxor _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opatomicand _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomiccompareexchange _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomiccompareexchangeweak _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opatomicexchange _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicfaddext _ ->
              [Operand_kind.Payload.Capability.Atomicfloat16addext;
              Operand_kind.Payload.Capability.Atomicfloat32addext;
              Operand_kind.Payload.Capability.Atomicfloat64addext;
              Operand_kind.Payload.Capability.Atomicfloat16vectornv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opatomicflagclear _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opatomicflagtestandset _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opatomicfmaxext _ ->
              [Operand_kind.Payload.Capability.Atomicfloat16minmaxext;
              Operand_kind.Payload.Capability.Atomicfloat32minmaxext;
              Operand_kind.Payload.Capability.Atomicfloat64minmaxext;
              Operand_kind.Payload.Capability.Atomicfloat16vectornv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opatomicfminext _ ->
              [Operand_kind.Payload.Capability.Atomicfloat16minmaxext;
              Operand_kind.Payload.Capability.Atomicfloat32minmaxext;
              Operand_kind.Payload.Capability.Atomicfloat64minmaxext;
              Operand_kind.Payload.Capability.Atomicfloat16vectornv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opatomiciadd _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicidecrement _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomiciincrement _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicisub _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicload _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicor _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicsmax _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicsmin _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicstore _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicumax _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicumin _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opatomicxor _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Barrier =
      struct
        type t =
          | Opcontrolbarrier of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opcontrolbarrierarriveintel of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opcontrolbarrierwaitintel of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opmemorybarrier of
          {
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opmemorynamedbarrier of
          {
          namedbarrier: Operand_kind.Payload.Idref.t ;
          memory: Operand_kind.Payload.Idscope.t ;
          semantics: Operand_kind.Payload.Idmemorysemantics.t } 
          | Opnamedbarrierinitialize of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          subgroupcount: Operand_kind.Payload.Idref.t } [@@deriving
                                                          compare, sexp_of]
        let provisional =
          function
          | Opcontrolbarrier _ -> false
          | Opcontrolbarrierarriveintel _ -> false
          | Opcontrolbarrierwaitintel _ -> false
          | Opmemorybarrier _ -> false
          | Opmemorynamedbarrier _ -> false
          | Opnamedbarrierinitialize _ -> false
        let value =
          function
          | Opcontrolbarrier t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 224l in
              heading :: payload
          | Opcontrolbarrierarriveintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6142l in
              heading :: payload
          | Opcontrolbarrierwaitintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6143l in
              heading :: payload
          | Opmemorybarrier t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 225l in
              heading :: payload
          | Opmemorynamedbarrier t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.namedbarrier;
                  Operand_kind.Payload.Idscope.value t.memory;
                  Operand_kind.Payload.Idmemorysemantics.value t.semantics] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 329l in
              heading :: payload
          | Opnamedbarrierinitialize t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.subgroupcount] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 328l in
              heading :: payload
        let any_required_version =
          function
          | Opcontrolbarrier _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcontrolbarrierarriveintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcontrolbarrierwaitintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmemorybarrier _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmemorynamedbarrier _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opnamedbarrierinitialize _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opcontrolbarrier _ -> [] |> Requirements.Extension.Set.of_list
          | Opcontrolbarrierarriveintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcontrolbarrierwaitintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opmemorybarrier _ -> [] |> Requirements.Extension.Set.of_list
          | Opmemorynamedbarrier _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opnamedbarrierinitialize _ ->
              [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opcontrolbarrier _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opcontrolbarrierarriveintel _ ->
              [Operand_kind.Payload.Capability.Splitbarrierintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcontrolbarrierwaitintel _ ->
              [Operand_kind.Payload.Capability.Splitbarrierintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opmemorybarrier _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opmemorynamedbarrier _ ->
              [Operand_kind.Payload.Capability.Namedbarrier] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opnamedbarrierinitialize _ ->
              [Operand_kind.Payload.Capability.Namedbarrier] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Bit =
      struct
        type t =
          | Opbitcount of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t } 
          | Opbitfieldinsert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          insert: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          count: Operand_kind.Payload.Idref.t } 
          | Opbitfieldsextract of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          count: Operand_kind.Payload.Idref.t } 
          | Opbitfielduextract of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          count: Operand_kind.Payload.Idref.t } 
          | Opbitreverse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t } 
          | Opbitwiseand of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opbitwisefunctionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          b: Operand_kind.Payload.Idref.t ;
          c: Operand_kind.Payload.Idref.t ;
          lutindex: Operand_kind.Payload.Idref.t } 
          | Opbitwiseor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opbitwisexor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opnot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opshiftleftlogical of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          shift: Operand_kind.Payload.Idref.t } 
          | Opshiftrightarithmetic of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          shift: Operand_kind.Payload.Idref.t } 
          | Opshiftrightlogical of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          shift: Operand_kind.Payload.Idref.t } [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opbitcount _ -> false
          | Opbitfieldinsert _ -> false
          | Opbitfieldsextract _ -> false
          | Opbitfielduextract _ -> false
          | Opbitreverse _ -> false
          | Opbitwiseand _ -> false
          | Opbitwisefunctionintel _ -> false
          | Opbitwiseor _ -> false
          | Opbitwisexor _ -> false
          | Opnot _ -> false
          | Opshiftleftlogical _ -> false
          | Opshiftrightarithmetic _ -> false
          | Opshiftrightlogical _ -> false
        let value =
          function
          | Opbitcount t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 205l in
              heading :: payload
          | Opbitfieldinsert t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.insert;
                  Operand_kind.Payload.Idref.value t.offset;
                  Operand_kind.Payload.Idref.value t.count] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 201l in
              heading :: payload
          | Opbitfieldsextract t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.offset;
                  Operand_kind.Payload.Idref.value t.count] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 202l in
              heading :: payload
          | Opbitfielduextract t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.offset;
                  Operand_kind.Payload.Idref.value t.count] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 203l in
              heading :: payload
          | Opbitreverse t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 204l in
              heading :: payload
          | Opbitwiseand t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 199l in
              heading :: payload
          | Opbitwisefunctionintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Idref.value t.c;
                  Operand_kind.Payload.Idref.value t.lutindex] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6242l in
              heading :: payload
          | Opbitwiseor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 197l in
              heading :: payload
          | Opbitwisexor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 198l in
              heading :: payload
          | Opnot t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 200l in
              heading :: payload
          | Opshiftleftlogical t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.shift] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 196l in
              heading :: payload
          | Opshiftrightarithmetic t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.shift] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 195l in
              heading :: payload
          | Opshiftrightlogical t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.shift] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 194l in
              heading :: payload
        let any_required_version =
          function
          | Opbitcount _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitfieldinsert _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitfieldsextract _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitfielduextract _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitreverse _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitwiseand _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitwisefunctionintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitwiseor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitwisexor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opnot _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opshiftleftlogical _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opshiftrightarithmetic _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opshiftrightlogical _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opbitcount _ -> [] |> Requirements.Extension.Set.of_list
          | Opbitfieldinsert _ -> [] |> Requirements.Extension.Set.of_list
          | Opbitfieldsextract _ -> [] |> Requirements.Extension.Set.of_list
          | Opbitfielduextract _ -> [] |> Requirements.Extension.Set.of_list
          | Opbitreverse _ -> [] |> Requirements.Extension.Set.of_list
          | Opbitwiseand _ -> [] |> Requirements.Extension.Set.of_list
          | Opbitwisefunctionintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opbitwiseor _ -> [] |> Requirements.Extension.Set.of_list
          | Opbitwisexor _ -> [] |> Requirements.Extension.Set.of_list
          | Opnot _ -> [] |> Requirements.Extension.Set.of_list
          | Opshiftleftlogical _ -> [] |> Requirements.Extension.Set.of_list
          | Opshiftrightarithmetic _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opshiftrightlogical _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opbitcount _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opbitfieldinsert _ ->
              [Operand_kind.Payload.Capability.Shader;
              Operand_kind.Payload.Capability.Bitinstructions] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opbitfieldsextract _ ->
              [Operand_kind.Payload.Capability.Shader;
              Operand_kind.Payload.Capability.Bitinstructions] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opbitfielduextract _ ->
              [Operand_kind.Payload.Capability.Shader;
              Operand_kind.Payload.Capability.Bitinstructions] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opbitreverse _ ->
              [Operand_kind.Payload.Capability.Shader;
              Operand_kind.Payload.Capability.Bitinstructions] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opbitwiseand _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opbitwisefunctionintel _ ->
              [Operand_kind.Payload.Capability.Ternarybitwisefunctionintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opbitwiseor _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opbitwisexor _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opnot _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opshiftleftlogical _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opshiftrightarithmetic _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opshiftrightlogical _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Composite =
      struct
        type t =
          | Opcompositeconstruct of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opcompositeconstructcontinuedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opcompositeconstructcoopmatqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcearray: Operand_kind.Payload.Idref.t } 
          | Opcompositeconstructreplicateext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opcompositeextract of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          composite: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Literalinteger.t list } 
          | Opcompositeextractcoopmatqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcecooperativematrix: Operand_kind.Payload.Idref.t } 
          | Opcompositeinsert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          object_: Operand_kind.Payload.Idref.t ;
          composite: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Literalinteger.t list } 
          | Opconditionalcopyobjectintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          condition0operand0condition1operand1___:
            Operand_kind.Payload.Idref.t list }
          
          | Opcopylogical of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opcopyobject of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opextractsubarrayqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcearray: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Optranspose of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t } 
          | Opvectorextractdynamic of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opvectorinsertdynamic of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t ;
          component: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opvectorshuffle of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector1: Operand_kind.Payload.Idref.t ;
          vector2: Operand_kind.Payload.Idref.t ;
          components: Operand_kind.Payload.Literalinteger.t list } [@@deriving
                                                                    compare, sexp_of]
        let provisional =
          function
          | Opcompositeconstruct _ -> false
          | Opcompositeconstructcontinuedintel _ -> false
          | Opcompositeconstructcoopmatqcom _ -> false
          | Opcompositeconstructreplicateext _ -> false
          | Opcompositeextract _ -> false
          | Opcompositeextractcoopmatqcom _ -> false
          | Opcompositeinsert _ -> false
          | Opconditionalcopyobjectintel _ -> true
          | Opcopylogical _ -> false
          | Opcopyobject _ -> false
          | Opextractsubarrayqcom _ -> false
          | Optranspose _ -> false
          | Opvectorextractdynamic _ -> false
          | Opvectorinsertdynamic _ -> false
          | Opvectorshuffle _ -> false
        let value =
          function
          | Opcompositeconstruct t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.constituents
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 80l in
              heading :: payload
          | Opcompositeconstructcontinuedintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.constituents
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6096l in
              heading :: payload
          | Opcompositeconstructcoopmatqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sourcearray] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4540l in
              heading :: payload
          | Opcompositeconstructreplicateext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4463l in
              heading :: payload
          | Opcompositeextract t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.composite;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Literalinteger.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 81l in
              heading :: payload
          | Opcompositeextractcoopmatqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sourcecooperativematrix] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4541l in
              heading :: payload
          | Opcompositeinsert t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.object_;
                  Operand_kind.Payload.Idref.value t.composite;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Literalinteger.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 82l in
              heading :: payload
          | Opconditionalcopyobjectintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.condition0operand0condition1operand1___
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6254l in
              heading :: payload
          | Opcopylogical t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 400l in
              heading :: payload
          | Opcopyobject t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 83l in
              heading :: payload
          | Opextractsubarrayqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sourcearray;
                  Operand_kind.Payload.Idref.value t.index] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4542l in
              heading :: payload
          | Optranspose t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.matrix] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 84l in
              heading :: payload
          | Opvectorextractdynamic t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector;
                  Operand_kind.Payload.Idref.value t.index] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 77l in
              heading :: payload
          | Opvectorinsertdynamic t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector;
                  Operand_kind.Payload.Idref.value t.component;
                  Operand_kind.Payload.Idref.value t.index] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 78l in
              heading :: payload
          | Opvectorshuffle t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector1;
                  Operand_kind.Payload.Idref.value t.vector2;
                  List.concat_map t.components
                    ~f:Operand_kind.Payload.Literalinteger.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 79l in
              heading :: payload
        let any_required_version =
          function
          | Opcompositeconstruct _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcompositeconstructcontinuedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcompositeconstructcoopmatqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcompositeconstructreplicateext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcompositeextract _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcompositeextractcoopmatqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcompositeinsert _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconditionalcopyobjectintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcopylogical _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_4)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcopyobject _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opextractsubarrayqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optranspose _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opvectorextractdynamic _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opvectorinsertdynamic _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opvectorshuffle _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opcompositeconstruct _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcompositeconstructcontinuedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcompositeconstructcoopmatqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcompositeconstructreplicateext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcompositeextract _ -> [] |> Requirements.Extension.Set.of_list
          | Opcompositeextractcoopmatqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcompositeinsert _ -> [] |> Requirements.Extension.Set.of_list
          | Opconditionalcopyobjectintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcopylogical _ -> [] |> Requirements.Extension.Set.of_list
          | Opcopyobject _ -> [] |> Requirements.Extension.Set.of_list
          | Opextractsubarrayqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optranspose _ -> [] |> Requirements.Extension.Set.of_list
          | Opvectorextractdynamic _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opvectorinsertdynamic _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opvectorshuffle _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opcompositeconstruct _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opcompositeconstructcontinuedintel _ ->
              [Operand_kind.Payload.Capability.Longcompositesintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcompositeconstructcoopmatqcom _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixconversionqcom]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opcompositeconstructreplicateext _ ->
              [Operand_kind.Payload.Capability.Replicatedcompositesext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcompositeextract _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opcompositeextractcoopmatqcom _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixconversionqcom]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opcompositeinsert _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconditionalcopyobjectintel _ ->
              [Operand_kind.Payload.Capability.Specconditionalintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcopylogical _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opcopyobject _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opextractsubarrayqcom _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixconversionqcom]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optranspose _ ->
              [Operand_kind.Payload.Capability.Matrix] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opvectorextractdynamic _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opvectorinsertdynamic _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opvectorshuffle _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Constant_creation =
      struct
        type t =
          | Opconstant of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Literalcontextdependentnumber.t } 
          | Opconstantcomposite of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opconstantcompositecontinuedintel of
          {
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opconstantcompositereplicateext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opconstantfalse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opconstantnull of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opconstantsampler of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampleraddressingmode: Operand_kind.Payload.Sampleraddressingmode.t ;
          param: Operand_kind.Payload.Literalinteger.t ;
          samplerfiltermode: Operand_kind.Payload.Samplerfiltermode.t } 
          | Opconstanttrue of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opspecconstant of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Literalcontextdependentnumber.t } 
          | Opspecconstantarchitectureintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          category: Operand_kind.Payload.Literalinteger.t ;
          family: Operand_kind.Payload.Literalinteger.t ;
          opcode: Operand_kind.Payload.Literalinteger.t ;
          architecture: Operand_kind.Payload.Literalinteger.t } 
          | Opspecconstantcapabilitiesintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          capabilities: Operand_kind.Payload.Capability.t list } 
          | Opspecconstantcomposite of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opspecconstantcompositecontinuedintel of
          {
          constituents: Operand_kind.Payload.Idref.t list } 
          | Opspecconstantcompositereplicateext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opspecconstantfalse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opspecconstantop of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          opcode: Operand_kind.Payload.Literalspecconstantopinteger.t } 
          | Opspecconstanttargetintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          target: Operand_kind.Payload.Literalinteger.t ;
          features: Operand_kind.Payload.Literalinteger.t list } 
          | Opspecconstanttrue of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } [@@deriving
                                                        compare, sexp_of]
        let provisional =
          function
          | Opconstant _ -> false
          | Opconstantcomposite _ -> false
          | Opconstantcompositecontinuedintel _ -> false
          | Opconstantcompositereplicateext _ -> false
          | Opconstantfalse _ -> false
          | Opconstantnull _ -> false
          | Opconstantsampler _ -> false
          | Opconstanttrue _ -> false
          | Opspecconstant _ -> false
          | Opspecconstantarchitectureintel _ -> true
          | Opspecconstantcapabilitiesintel _ -> true
          | Opspecconstantcomposite _ -> false
          | Opspecconstantcompositecontinuedintel _ -> false
          | Opspecconstantcompositereplicateext _ -> false
          | Opspecconstantfalse _ -> false
          | Opspecconstantop _ -> false
          | Opspecconstanttargetintel _ -> true
          | Opspecconstanttrue _ -> false
        let value =
          function
          | Opconstant t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalcontextdependentnumber.value
                    t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 43l in
              heading :: payload
          | Opconstantcomposite t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.constituents
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 44l in
              heading :: payload
          | Opconstantcompositecontinuedintel t ->
              let payload =
                List.concat
                  [List.concat_map t.constituents
                     ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6091l in
              heading :: payload
          | Opconstantcompositereplicateext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4461l in
              heading :: payload
          | Opconstantfalse t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 42l in
              heading :: payload
          | Opconstantnull t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 46l in
              heading :: payload
          | Opconstantsampler t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Sampleraddressingmode.value
                    t.sampleraddressingmode;
                  Operand_kind.Payload.Literalinteger.value t.param;
                  Operand_kind.Payload.Samplerfiltermode.value
                    t.samplerfiltermode] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 45l in
              heading :: payload
          | Opconstanttrue t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 41l in
              heading :: payload
          | Opspecconstant t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalcontextdependentnumber.value
                    t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 50l in
              heading :: payload
          | Opspecconstantarchitectureintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalinteger.value t.category;
                  Operand_kind.Payload.Literalinteger.value t.family;
                  Operand_kind.Payload.Literalinteger.value t.opcode;
                  Operand_kind.Payload.Literalinteger.value t.architecture] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6252l in
              heading :: payload
          | Opspecconstantcapabilitiesintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.capabilities
                    ~f:Operand_kind.Payload.Capability.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6253l in
              heading :: payload
          | Opspecconstantcomposite t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.constituents
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 51l in
              heading :: payload
          | Opspecconstantcompositecontinuedintel t ->
              let payload =
                List.concat
                  [List.concat_map t.constituents
                     ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6092l in
              heading :: payload
          | Opspecconstantcompositereplicateext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4462l in
              heading :: payload
          | Opspecconstantfalse t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 49l in
              heading :: payload
          | Opspecconstantop t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalspecconstantopinteger.value
                    t.opcode] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 52l in
              heading :: payload
          | Opspecconstanttargetintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalinteger.value t.target;
                  List.concat_map t.features
                    ~f:Operand_kind.Payload.Literalinteger.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6251l in
              heading :: payload
          | Opspecconstanttrue t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 48l in
              heading :: payload
        let any_required_version =
          function
          | Opconstant _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantcomposite _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantcompositecontinuedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantcompositereplicateext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantfalse _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantnull _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantsampler _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstanttrue _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstant _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstantarchitectureintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstantcapabilitiesintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstantcomposite _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstantcompositecontinuedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstantcompositereplicateext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstantfalse _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstantop _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstanttargetintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstanttrue _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opconstant _ -> [] |> Requirements.Extension.Set.of_list
          | Opconstantcomposite _ -> [] |> Requirements.Extension.Set.of_list
          | Opconstantcompositecontinuedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconstantcompositereplicateext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconstantfalse _ -> [] |> Requirements.Extension.Set.of_list
          | Opconstantnull _ -> [] |> Requirements.Extension.Set.of_list
          | Opconstantsampler _ -> [] |> Requirements.Extension.Set.of_list
          | Opconstanttrue _ -> [] |> Requirements.Extension.Set.of_list
          | Opspecconstant _ -> [] |> Requirements.Extension.Set.of_list
          | Opspecconstantarchitectureintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opspecconstantcapabilitiesintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opspecconstantcomposite _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opspecconstantcompositecontinuedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opspecconstantcompositereplicateext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opspecconstantfalse _ -> [] |> Requirements.Extension.Set.of_list
          | Opspecconstantop _ -> [] |> Requirements.Extension.Set.of_list
          | Opspecconstanttargetintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opspecconstanttrue _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opconstant _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconstantcomposite _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconstantcompositecontinuedintel _ ->
              [Operand_kind.Payload.Capability.Longcompositesintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconstantcompositereplicateext _ ->
              [Operand_kind.Payload.Capability.Replicatedcompositesext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconstantfalse _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconstantnull _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconstantsampler _ ->
              [Operand_kind.Payload.Capability.Literalsampler] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconstanttrue _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstant _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstantarchitectureintel _ ->
              [Operand_kind.Payload.Capability.Functionvariantsintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstantcapabilitiesintel _ ->
              [Operand_kind.Payload.Capability.Functionvariantsintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstantcomposite _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstantcompositecontinuedintel _ ->
              [Operand_kind.Payload.Capability.Longcompositesintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstantcompositereplicateext _ ->
              [Operand_kind.Payload.Capability.Replicatedcompositesext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstantfalse _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstantop _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstanttargetintel _ ->
              [Operand_kind.Payload.Capability.Functionvariantsintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstanttrue _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Control_flow =
      struct
        type t =
          | Opbranch of {
          targetlabel: Operand_kind.Payload.Idref.t } 
          | Opbranchconditional of
          {
          condition: Operand_kind.Payload.Idref.t ;
          truelabel: Operand_kind.Payload.Idref.t ;
          falselabel: Operand_kind.Payload.Idref.t ;
          branchweights: Operand_kind.Payload.Literalinteger.t list } 
          | Opdemotetohelperinvocation 
          | Opkill 
          | Oplabel of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Oplifetimestart of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          size: Operand_kind.Payload.Literalinteger.t } 
          | Oplifetimestop of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          size: Operand_kind.Payload.Literalinteger.t } 
          | Oploopmerge of
          {
          mergeblock: Operand_kind.Payload.Idref.t ;
          continuetarget: Operand_kind.Payload.Idref.t ;
          loopcontrol: Operand_kind.Payload.Loopcontrol.t } 
          | Opphi of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          variableparent___: Operand_kind.Payload.Pairidrefidref.t list } 
          | Opreturn 
          | Opreturnvalue of {
          value: Operand_kind.Payload.Idref.t } 
          | Opselectionmerge of
          {
          mergeblock: Operand_kind.Payload.Idref.t ;
          selectioncontrol: Operand_kind.Payload.Selectioncontrol.t } 
          | Opswitch of
          {
          selector: Operand_kind.Payload.Idref.t ;
          default: Operand_kind.Payload.Idref.t ;
          target: Operand_kind.Payload.Pairliteralintegeridref.t list } 
          | Opterminateinvocation 
          | Opunreachable [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opbranch _ -> false
          | Opbranchconditional _ -> false
          | Opdemotetohelperinvocation -> false
          | Opkill -> false
          | Oplabel _ -> false
          | Oplifetimestart _ -> false
          | Oplifetimestop _ -> false
          | Oploopmerge _ -> false
          | Opphi _ -> false
          | Opreturn -> false
          | Opreturnvalue _ -> false
          | Opselectionmerge _ -> false
          | Opswitch _ -> false
          | Opterminateinvocation -> false
          | Opunreachable -> false
        let value =
          function
          | Opbranch t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.targetlabel] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 249l in
              heading :: payload
          | Opbranchconditional t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.condition;
                  Operand_kind.Payload.Idref.value t.truelabel;
                  Operand_kind.Payload.Idref.value t.falselabel;
                  List.concat_map t.branchweights
                    ~f:Operand_kind.Payload.Literalinteger.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 250l in
              heading :: payload
          | Opdemotetohelperinvocation ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5380l in
              [heading]
          | Opkill ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 252l in
              [heading]
          | Oplabel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 248l in
              heading :: payload
          | Oplifetimestart t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Literalinteger.value t.size] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 256l in
              heading :: payload
          | Oplifetimestop t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Literalinteger.value t.size] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 257l in
              heading :: payload
          | Oploopmerge t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.mergeblock;
                  Operand_kind.Payload.Idref.value t.continuetarget;
                  Operand_kind.Payload.Loopcontrol.value t.loopcontrol] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 246l in
              heading :: payload
          | Opphi t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.variableparent___
                    ~f:Operand_kind.Payload.Pairidrefidref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 245l in
              heading :: payload
          | Opreturn ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 253l in
              [heading]
          | Opreturnvalue t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 254l in
              heading :: payload
          | Opselectionmerge t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.mergeblock;
                  Operand_kind.Payload.Selectioncontrol.value
                    t.selectioncontrol] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 247l in
              heading :: payload
          | Opswitch t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.selector;
                  Operand_kind.Payload.Idref.value t.default;
                  List.concat_map t.target
                    ~f:Operand_kind.Payload.Pairliteralintegeridref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 251l in
              heading :: payload
          | Opterminateinvocation ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 4416l in
              [heading]
          | Opunreachable ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 255l in
              [heading]
        let any_required_version =
          function
          | Opbranch _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbranchconditional _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdemotetohelperinvocation ->
              (Requirements.Version.valid_versions ~required:(Some V1_6)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opkill ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oplabel _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oplifetimestart _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oplifetimestop _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oploopmerge _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opphi _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreturn ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreturnvalue _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opselectionmerge _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opswitch _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opterminateinvocation ->
              (Requirements.Version.valid_versions ~required:(Some V1_6)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opunreachable ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opbranch _ -> [] |> Requirements.Extension.Set.of_list
          | Opbranchconditional _ -> [] |> Requirements.Extension.Set.of_list
          | Opdemotetohelperinvocation ->
              [] |> Requirements.Extension.Set.of_list
          | Opkill -> [] |> Requirements.Extension.Set.of_list
          | Oplabel _ -> [] |> Requirements.Extension.Set.of_list
          | Oplifetimestart _ -> [] |> Requirements.Extension.Set.of_list
          | Oplifetimestop _ -> [] |> Requirements.Extension.Set.of_list
          | Oploopmerge _ -> [] |> Requirements.Extension.Set.of_list
          | Opphi _ -> [] |> Requirements.Extension.Set.of_list
          | Opreturn -> [] |> Requirements.Extension.Set.of_list
          | Opreturnvalue _ -> [] |> Requirements.Extension.Set.of_list
          | Opselectionmerge _ -> [] |> Requirements.Extension.Set.of_list
          | Opswitch _ -> [] |> Requirements.Extension.Set.of_list
          | Opterminateinvocation ->
              [Requirements.Extension.Spv_khr_terminate_invocation] |>
                Requirements.Extension.Set.of_list
          | Opunreachable -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opbranch _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opbranchconditional _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opdemotetohelperinvocation ->
              [Operand_kind.Payload.Capability.Demotetohelperinvocation] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opkill ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oplabel _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Oplifetimestart _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oplifetimestop _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oploopmerge _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opphi _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opreturn -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opreturnvalue _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opselectionmerge _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opswitch _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opterminateinvocation ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opunreachable ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Conversion =
      struct
        type t =
          | Opbitcast of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opbitcastarrayqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcearray: Operand_kind.Payload.Idref.t } 
          | Opconvertbf16tofintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          bfloat16value: Operand_kind.Payload.Idref.t } 
          | Opconvertftobf16intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertftos of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertftou of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertptrtou of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opconvertstof of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          signedvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertutof of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          unsignedvalue: Operand_kind.Payload.Idref.t } 
          | Opconvertutoptr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          integervalue: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixconvertnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixtransposenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t } 
          | Opfconvert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opgenericcasttoptr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opgenericcasttoptrexplicit of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          storage: Operand_kind.Payload.Storageclass.t } 
          | Opptrcasttogeneric of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opquantizetof16 of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Oproundftotf32intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          floatvalue: Operand_kind.Payload.Idref.t } 
          | Opsatconvertstou of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          signedvalue: Operand_kind.Payload.Idref.t } 
          | Opsatconvertutos of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          unsignedvalue: Operand_kind.Payload.Idref.t } 
          | Opsconvert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          signedvalue: Operand_kind.Payload.Idref.t } 
          | Opuconvert of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          unsignedvalue: Operand_kind.Payload.Idref.t } [@@deriving
                                                          compare, sexp_of]
        let provisional =
          function
          | Opbitcast _ -> false
          | Opbitcastarrayqcom _ -> false
          | Opconvertbf16tofintel _ -> false
          | Opconvertftobf16intel _ -> false
          | Opconvertftos _ -> false
          | Opconvertftou _ -> false
          | Opconvertptrtou _ -> false
          | Opconvertstof _ -> false
          | Opconvertutof _ -> false
          | Opconvertutoptr _ -> false
          | Opcooperativematrixconvertnv _ -> false
          | Opcooperativematrixtransposenv _ -> false
          | Opfconvert _ -> false
          | Opgenericcasttoptr _ -> false
          | Opgenericcasttoptrexplicit _ -> false
          | Opptrcasttogeneric _ -> false
          | Opquantizetof16 _ -> false
          | Oproundftotf32intel _ -> false
          | Opsatconvertstou _ -> false
          | Opsatconvertutos _ -> false
          | Opsconvert _ -> false
          | Opuconvert _ -> false
        let value =
          function
          | Opbitcast t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 124l in
              heading :: payload
          | Opbitcastarrayqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sourcearray] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4497l in
              heading :: payload
          | Opconvertbf16tofintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.bfloat16value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6117l in
              heading :: payload
          | Opconvertftobf16intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.floatvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6116l in
              heading :: payload
          | Opconvertftos t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.floatvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 110l in
              heading :: payload
          | Opconvertftou t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.floatvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 109l in
              heading :: payload
          | Opconvertptrtou t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 117l in
              heading :: payload
          | Opconvertstof t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.signedvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 111l in
              heading :: payload
          | Opconvertutof t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.unsignedvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 112l in
              heading :: payload
          | Opconvertutoptr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.integervalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 120l in
              heading :: payload
          | Opcooperativematrixconvertnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.matrix] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5293l in
              heading :: payload
          | Opcooperativematrixtransposenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.matrix] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5390l in
              heading :: payload
          | Opfconvert t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.floatvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 115l in
              heading :: payload
          | Opgenericcasttoptr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 122l in
              heading :: payload
          | Opgenericcasttoptrexplicit t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Storageclass.value t.storage] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 123l in
              heading :: payload
          | Opptrcasttogeneric t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 121l in
              heading :: payload
          | Opquantizetof16 t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 116l in
              heading :: payload
          | Oproundftotf32intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.floatvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6426l in
              heading :: payload
          | Opsatconvertstou t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.signedvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 118l in
              heading :: payload
          | Opsatconvertutos t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.unsignedvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 119l in
              heading :: payload
          | Opsconvert t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.signedvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 114l in
              heading :: payload
          | Opuconvert t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.unsignedvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 113l in
              heading :: payload
        let any_required_version =
          function
          | Opbitcast _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbitcastarrayqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertbf16tofintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertftobf16intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertftos _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertftou _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertptrtou _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertstof _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertutof _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertutoptr _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixconvertnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixtransposenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfconvert _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgenericcasttoptr _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgenericcasttoptrexplicit _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opptrcasttogeneric _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opquantizetof16 _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oproundftotf32intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsatconvertstou _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsatconvertutos _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsconvert _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuconvert _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opbitcast _ -> [] |> Requirements.Extension.Set.of_list
          | Opbitcastarrayqcom _ -> [] |> Requirements.Extension.Set.of_list
          | Opconvertbf16tofintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconvertftobf16intel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconvertftos _ -> [] |> Requirements.Extension.Set.of_list
          | Opconvertftou _ -> [] |> Requirements.Extension.Set.of_list
          | Opconvertptrtou _ -> [] |> Requirements.Extension.Set.of_list
          | Opconvertstof _ -> [] |> Requirements.Extension.Set.of_list
          | Opconvertutof _ -> [] |> Requirements.Extension.Set.of_list
          | Opconvertutoptr _ -> [] |> Requirements.Extension.Set.of_list
          | Opcooperativematrixconvertnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativematrixtransposenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfconvert _ -> [] |> Requirements.Extension.Set.of_list
          | Opgenericcasttoptr _ -> [] |> Requirements.Extension.Set.of_list
          | Opgenericcasttoptrexplicit _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opptrcasttogeneric _ -> [] |> Requirements.Extension.Set.of_list
          | Opquantizetof16 _ -> [] |> Requirements.Extension.Set.of_list
          | Oproundftotf32intel _ -> [] |> Requirements.Extension.Set.of_list
          | Opsatconvertstou _ -> [] |> Requirements.Extension.Set.of_list
          | Opsatconvertutos _ -> [] |> Requirements.Extension.Set.of_list
          | Opsconvert _ -> [] |> Requirements.Extension.Set.of_list
          | Opuconvert _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opbitcast _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opbitcastarrayqcom _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixconversionqcom]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opconvertbf16tofintel _ ->
              [Operand_kind.Payload.Capability.Bfloat16conversionintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertftobf16intel _ ->
              [Operand_kind.Payload.Capability.Bfloat16conversionintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertftos _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconvertftou _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconvertptrtou _ ->
              [Operand_kind.Payload.Capability.Addresses;
              Operand_kind.Payload.Capability.Physicalstoragebufferaddresses]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opconvertstof _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconvertutof _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconvertutoptr _ ->
              [Operand_kind.Payload.Capability.Addresses;
              Operand_kind.Payload.Capability.Physicalstoragebufferaddresses]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixconvertnv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixconversionsnv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixtransposenv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixconversionsnv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfconvert _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opgenericcasttoptr _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgenericcasttoptrexplicit _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opptrcasttogeneric _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opquantizetof16 _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oproundftotf32intel _ ->
              [Operand_kind.Payload.Capability.Tensorfloat32roundingintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsatconvertstou _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsatconvertutos _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsconvert _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opuconvert _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Debug =
      struct
        type t =
          | Opline of
          {
          file: Operand_kind.Payload.Idref.t ;
          line: Operand_kind.Payload.Literalinteger.t ;
          column: Operand_kind.Payload.Literalinteger.t } 
          | Opmembername of
          {
          type_: Operand_kind.Payload.Idref.t ;
          member: Operand_kind.Payload.Literalinteger.t ;
          name: Operand_kind.Payload.Literalstring.t } 
          | Opmoduleprocessed of
          {
          process: Operand_kind.Payload.Literalstring.t } 
          | Opname of
          {
          target: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t } 
          | Opnoline 
          | Opsource of
          {
          sourcelanguage: Operand_kind.Payload.Sourcelanguage.t ;
          version: Operand_kind.Payload.Literalinteger.t ;
          file: Operand_kind.Payload.Idref.t option ;
          source: Operand_kind.Payload.Literalstring.t option } 
          | Opsourcecontinued of
          {
          continuedsource: Operand_kind.Payload.Literalstring.t } 
          | Opsourceextension of
          {
          extension: Operand_kind.Payload.Literalstring.t } 
          | Opstring of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          string: Operand_kind.Payload.Literalstring.t } [@@deriving
                                                           compare, sexp_of]
        let provisional =
          function
          | Opline _ -> false
          | Opmembername _ -> false
          | Opmoduleprocessed _ -> false
          | Opname _ -> false
          | Opnoline -> false
          | Opsource _ -> false
          | Opsourcecontinued _ -> false
          | Opsourceextension _ -> false
          | Opstring _ -> false
        let value =
          function
          | Opline t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.file;
                  Operand_kind.Payload.Literalinteger.value t.line;
                  Operand_kind.Payload.Literalinteger.value t.column] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 8l in
              heading :: payload
          | Opmembername t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.type_;
                  Operand_kind.Payload.Literalinteger.value t.member;
                  Operand_kind.Payload.Literalstring.value t.name] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6l in
              heading :: payload
          | Opmoduleprocessed t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Literalstring.value t.process] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 330l in
              heading :: payload
          | Opname t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Literalstring.value t.name] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5l in
              heading :: payload
          | Opnoline ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 317l in
              [heading]
          | Opsource t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Sourcelanguage.value t.sourcelanguage;
                  Operand_kind.Payload.Literalinteger.value t.version;
                  (t.file |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.source |>
                     (Option.map ~f:Operand_kind.Payload.Literalstring.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 3l in
              heading :: payload
          | Opsourcecontinued t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Literalstring.value t.continuedsource] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 2l in
              heading :: payload
          | Opsourceextension t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Literalstring.value t.extension] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4l in
              heading :: payload
          | Opstring t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalstring.value t.string] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 7l in
              heading :: payload
        let any_required_version =
          function
          | Opline _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmembername _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmoduleprocessed _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opname _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opnoline ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsource _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsourcecontinued _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsourceextension _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opstring _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opline _ -> [] |> Requirements.Extension.Set.of_list
          | Opmembername _ -> [] |> Requirements.Extension.Set.of_list
          | Opmoduleprocessed _ -> [] |> Requirements.Extension.Set.of_list
          | Opname _ -> [] |> Requirements.Extension.Set.of_list
          | Opnoline -> [] |> Requirements.Extension.Set.of_list
          | Opsource _ -> [] |> Requirements.Extension.Set.of_list
          | Opsourcecontinued _ -> [] |> Requirements.Extension.Set.of_list
          | Opsourceextension _ -> [] |> Requirements.Extension.Set.of_list
          | Opstring _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opline _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opmembername _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opmoduleprocessed _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opname _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opnoline -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsource _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsourcecontinued _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsourceextension _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opstring _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Derivative =
      struct
        type t =
          | Opdpdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdxcoarse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdxfine of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdy of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdycoarse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opdpdyfine of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opfwidth of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opfwidthcoarse of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } 
          | Opfwidthfine of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          p: Operand_kind.Payload.Idref.t } [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opdpdx _ -> false
          | Opdpdxcoarse _ -> false
          | Opdpdxfine _ -> false
          | Opdpdy _ -> false
          | Opdpdycoarse _ -> false
          | Opdpdyfine _ -> false
          | Opfwidth _ -> false
          | Opfwidthcoarse _ -> false
          | Opfwidthfine _ -> false
        let value =
          function
          | Opdpdx t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 207l in
              heading :: payload
          | Opdpdxcoarse t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 213l in
              heading :: payload
          | Opdpdxfine t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 210l in
              heading :: payload
          | Opdpdy t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 208l in
              heading :: payload
          | Opdpdycoarse t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 214l in
              heading :: payload
          | Opdpdyfine t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 211l in
              heading :: payload
          | Opfwidth t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 209l in
              heading :: payload
          | Opfwidthcoarse t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 215l in
              heading :: payload
          | Opfwidthfine t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.p] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 212l in
              heading :: payload
        let any_required_version =
          function
          | Opdpdx _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdpdxcoarse _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdpdxfine _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdpdy _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdpdycoarse _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdpdyfine _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfwidth _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfwidthcoarse _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfwidthfine _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opdpdx _ -> [] |> Requirements.Extension.Set.of_list
          | Opdpdxcoarse _ -> [] |> Requirements.Extension.Set.of_list
          | Opdpdxfine _ -> [] |> Requirements.Extension.Set.of_list
          | Opdpdy _ -> [] |> Requirements.Extension.Set.of_list
          | Opdpdycoarse _ -> [] |> Requirements.Extension.Set.of_list
          | Opdpdyfine _ -> [] |> Requirements.Extension.Set.of_list
          | Opfwidth _ -> [] |> Requirements.Extension.Set.of_list
          | Opfwidthcoarse _ -> [] |> Requirements.Extension.Set.of_list
          | Opfwidthfine _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opdpdx _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opdpdxcoarse _ ->
              [Operand_kind.Payload.Capability.Derivativecontrol] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opdpdxfine _ ->
              [Operand_kind.Payload.Capability.Derivativecontrol] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opdpdy _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opdpdycoarse _ ->
              [Operand_kind.Payload.Capability.Derivativecontrol] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opdpdyfine _ ->
              [Operand_kind.Payload.Capability.Derivativecontrol] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfwidth _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfwidthcoarse _ ->
              [Operand_kind.Payload.Capability.Derivativecontrol] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfwidthfine _ ->
              [Operand_kind.Payload.Capability.Derivativecontrol] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Device_side_enqueue =
      struct
        type t =
          | Opbuildndrange of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          globalworksize: Operand_kind.Payload.Idref.t ;
          localworksize: Operand_kind.Payload.Idref.t ;
          globalworkoffset: Operand_kind.Payload.Idref.t } 
          | Opcaptureeventprofilinginfo of
          {
          event: Operand_kind.Payload.Idref.t ;
          profilinginfo: Operand_kind.Payload.Idref.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opcreateuserevent of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Openqueuekernel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          queue: Operand_kind.Payload.Idref.t ;
          flags: Operand_kind.Payload.Idref.t ;
          ndrange: Operand_kind.Payload.Idref.t ;
          numevents: Operand_kind.Payload.Idref.t ;
          waitevents: Operand_kind.Payload.Idref.t ;
          retevent: Operand_kind.Payload.Idref.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t ;
          localsize: Operand_kind.Payload.Idref.t list } 
          | Openqueuemarker of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          queue: Operand_kind.Payload.Idref.t ;
          numevents: Operand_kind.Payload.Idref.t ;
          waitevents: Operand_kind.Payload.Idref.t ;
          retevent: Operand_kind.Payload.Idref.t } 
          | Opgetdefaultqueue of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opgetkernellocalsizeforsubgroupcount of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          subgroupcount: Operand_kind.Payload.Idref.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelmaxnumsubgroups of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelndrangemaxsubgroupsize of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          ndrange: Operand_kind.Payload.Idref.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelndrangesubgroupcount of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          ndrange: Operand_kind.Payload.Idref.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelpreferredworkgroupsizemultiple of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opgetkernelworkgroupsize of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          invoke: Operand_kind.Payload.Idref.t ;
          param: Operand_kind.Payload.Idref.t ;
          paramsize: Operand_kind.Payload.Idref.t ;
          paramalign: Operand_kind.Payload.Idref.t } 
          | Opisvalidevent of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          event: Operand_kind.Payload.Idref.t } 
          | Opreleaseevent of {
          event: Operand_kind.Payload.Idref.t } 
          | Opretainevent of {
          event: Operand_kind.Payload.Idref.t } 
          | Opsetusereventstatus of
          {
          event: Operand_kind.Payload.Idref.t ;
          status: Operand_kind.Payload.Idref.t } [@@deriving
                                                   compare, sexp_of]
        let provisional =
          function
          | Opbuildndrange _ -> false
          | Opcaptureeventprofilinginfo _ -> false
          | Opcreateuserevent _ -> false
          | Openqueuekernel _ -> false
          | Openqueuemarker _ -> false
          | Opgetdefaultqueue _ -> false
          | Opgetkernellocalsizeforsubgroupcount _ -> false
          | Opgetkernelmaxnumsubgroups _ -> false
          | Opgetkernelndrangemaxsubgroupsize _ -> false
          | Opgetkernelndrangesubgroupcount _ -> false
          | Opgetkernelpreferredworkgroupsizemultiple _ -> false
          | Opgetkernelworkgroupsize _ -> false
          | Opisvalidevent _ -> false
          | Opreleaseevent _ -> false
          | Opretainevent _ -> false
          | Opsetusereventstatus _ -> false
        let value =
          function
          | Opbuildndrange t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.globalworksize;
                  Operand_kind.Payload.Idref.value t.localworksize;
                  Operand_kind.Payload.Idref.value t.globalworkoffset] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 304l in
              heading :: payload
          | Opcaptureeventprofilinginfo t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.event;
                  Operand_kind.Payload.Idref.value t.profilinginfo;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 302l in
              heading :: payload
          | Opcreateuserevent t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 299l in
              heading :: payload
          | Openqueuekernel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.queue;
                  Operand_kind.Payload.Idref.value t.flags;
                  Operand_kind.Payload.Idref.value t.ndrange;
                  Operand_kind.Payload.Idref.value t.numevents;
                  Operand_kind.Payload.Idref.value t.waitevents;
                  Operand_kind.Payload.Idref.value t.retevent;
                  Operand_kind.Payload.Idref.value t.invoke;
                  Operand_kind.Payload.Idref.value t.param;
                  Operand_kind.Payload.Idref.value t.paramsize;
                  Operand_kind.Payload.Idref.value t.paramalign;
                  List.concat_map t.localsize
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 292l in
              heading :: payload
          | Openqueuemarker t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.queue;
                  Operand_kind.Payload.Idref.value t.numevents;
                  Operand_kind.Payload.Idref.value t.waitevents;
                  Operand_kind.Payload.Idref.value t.retevent] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 291l in
              heading :: payload
          | Opgetdefaultqueue t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 303l in
              heading :: payload
          | Opgetkernellocalsizeforsubgroupcount t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.subgroupcount;
                  Operand_kind.Payload.Idref.value t.invoke;
                  Operand_kind.Payload.Idref.value t.param;
                  Operand_kind.Payload.Idref.value t.paramsize;
                  Operand_kind.Payload.Idref.value t.paramalign] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 325l in
              heading :: payload
          | Opgetkernelmaxnumsubgroups t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.invoke;
                  Operand_kind.Payload.Idref.value t.param;
                  Operand_kind.Payload.Idref.value t.paramsize;
                  Operand_kind.Payload.Idref.value t.paramalign] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 326l in
              heading :: payload
          | Opgetkernelndrangemaxsubgroupsize t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.ndrange;
                  Operand_kind.Payload.Idref.value t.invoke;
                  Operand_kind.Payload.Idref.value t.param;
                  Operand_kind.Payload.Idref.value t.paramsize;
                  Operand_kind.Payload.Idref.value t.paramalign] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 294l in
              heading :: payload
          | Opgetkernelndrangesubgroupcount t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.ndrange;
                  Operand_kind.Payload.Idref.value t.invoke;
                  Operand_kind.Payload.Idref.value t.param;
                  Operand_kind.Payload.Idref.value t.paramsize;
                  Operand_kind.Payload.Idref.value t.paramalign] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 293l in
              heading :: payload
          | Opgetkernelpreferredworkgroupsizemultiple t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.invoke;
                  Operand_kind.Payload.Idref.value t.param;
                  Operand_kind.Payload.Idref.value t.paramsize;
                  Operand_kind.Payload.Idref.value t.paramalign] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 296l in
              heading :: payload
          | Opgetkernelworkgroupsize t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.invoke;
                  Operand_kind.Payload.Idref.value t.param;
                  Operand_kind.Payload.Idref.value t.paramsize;
                  Operand_kind.Payload.Idref.value t.paramalign] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 295l in
              heading :: payload
          | Opisvalidevent t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.event] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 300l in
              heading :: payload
          | Opreleaseevent t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.event] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 298l in
              heading :: payload
          | Opretainevent t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.event] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 297l in
              heading :: payload
          | Opsetusereventstatus t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.event;
                  Operand_kind.Payload.Idref.value t.status] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 301l in
              heading :: payload
        let any_required_version =
          function
          | Opbuildndrange _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcaptureeventprofilinginfo _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcreateuserevent _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Openqueuekernel _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Openqueuemarker _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetdefaultqueue _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetkernellocalsizeforsubgroupcount _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetkernelmaxnumsubgroups _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetkernelndrangemaxsubgroupsize _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetkernelndrangesubgroupcount _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetkernelpreferredworkgroupsizemultiple _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetkernelworkgroupsize _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisvalidevent _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreleaseevent _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opretainevent _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsetusereventstatus _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opbuildndrange _ -> [] |> Requirements.Extension.Set.of_list
          | Opcaptureeventprofilinginfo _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcreateuserevent _ -> [] |> Requirements.Extension.Set.of_list
          | Openqueuekernel _ -> [] |> Requirements.Extension.Set.of_list
          | Openqueuemarker _ -> [] |> Requirements.Extension.Set.of_list
          | Opgetdefaultqueue _ -> [] |> Requirements.Extension.Set.of_list
          | Opgetkernellocalsizeforsubgroupcount _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgetkernelmaxnumsubgroups _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgetkernelndrangemaxsubgroupsize _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgetkernelndrangesubgroupcount _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgetkernelpreferredworkgroupsizemultiple _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgetkernelworkgroupsize _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opisvalidevent _ -> [] |> Requirements.Extension.Set.of_list
          | Opreleaseevent _ -> [] |> Requirements.Extension.Set.of_list
          | Opretainevent _ -> [] |> Requirements.Extension.Set.of_list
          | Opsetusereventstatus _ ->
              [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opbuildndrange _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcaptureeventprofilinginfo _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcreateuserevent _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Openqueuekernel _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Openqueuemarker _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetdefaultqueue _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetkernellocalsizeforsubgroupcount _ ->
              [Operand_kind.Payload.Capability.Subgroupdispatch] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetkernelmaxnumsubgroups _ ->
              [Operand_kind.Payload.Capability.Subgroupdispatch] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetkernelndrangemaxsubgroupsize _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetkernelndrangesubgroupcount _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetkernelpreferredworkgroupsizemultiple _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetkernelworkgroupsize _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opisvalidevent _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreleaseevent _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opretainevent _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsetusereventstatus _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Exclude =
      struct
        type t =
          | Opaliasdomaindeclintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          name: Operand_kind.Payload.Idref.t option } 
          | Opaliasscopedeclintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          aliasdomain: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Idref.t option } 
          | Opaliasscopelistdeclintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          aliasscope1aliasscope2___: Operand_kind.Payload.Idref.t list } 
          | Oparbitraryfloatacosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          m1: Operand_kind.Payload.Literalinteger.t ;
          mout: Operand_kind.Payload.Literalinteger.t ;
          enablesubnormals: Operand_kind.Payload.Literalinteger.t ;
          roundingmode: Operand_kind.Payload.Literalinteger.t ;
          roundingaccuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatacospiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloataddaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatasinintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatasinpiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatatan2intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatatanintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatatanpiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcastaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcastfromintaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          fromsign: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcasttointaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          tosign: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcbrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatcospiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatdivaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloateqaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatexp10intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatexp2intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatexpintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatexpm1intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatgealtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatgtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloathypotaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlealtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlog10intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlog1pintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlog2intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatlogintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatltaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatmulaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatpowintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatpownintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          signofb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatpowrintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatrecipaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatrsqrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsincosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsincospialtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          roundingaccuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsinintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsinpiintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsqrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Oparbitraryfloatsubaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          ma: Operand_kind.Payload.Literalinteger.t ;
          b: Operand_kind.Payload.Idref.t ;
          mb: Operand_kind.Payload.Literalinteger.t ;
          mresult: Operand_kind.Payload.Literalinteger.t ;
          subnormal: Operand_kind.Payload.Literalinteger.t ;
          rounding: Operand_kind.Payload.Literalinteger.t ;
          accuracy: Operand_kind.Payload.Literalinteger.t } 
          | Opasmcallintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          asm: Operand_kind.Payload.Idref.t ;
          argument: Operand_kind.Payload.Idref.t list } 
          | Opasmintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          asmtype: Operand_kind.Payload.Idref.t ;
          target: Operand_kind.Payload.Idref.t ;
          asminstructions: Operand_kind.Payload.Literalstring.t ;
          constraints: Operand_kind.Payload.Literalstring.t } 
          | Opasmtargetintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          asmtarget: Operand_kind.Payload.Literalstring.t } 
          | Opconstantfunctionpointerintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          function_: Operand_kind.Payload.Idref.t } 
          | Opcrossworkgroupcasttoptraltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opfixedcosaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedcospialtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedexpaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedlogaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedrecipaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedrsqrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsinaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsincosaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsincospialtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsinpialtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfixedsqrtaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          s: Operand_kind.Payload.Literalinteger.t ;
          i: Operand_kind.Payload.Literalinteger.t ;
          ri: Operand_kind.Payload.Literalinteger.t ;
          q: Operand_kind.Payload.Literalinteger.t ;
          o: Operand_kind.Payload.Literalinteger.t } 
          | Opfpgaregaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t } 
          | Opfunctionpointercallintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t list } 
          | Opptrcasttocrossworkgroupaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opreadpipeblockingaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcbmeinitializeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srccoord: Operand_kind.Payload.Idref.t ;
          motionvectors: Operand_kind.Payload.Idref.t ;
          majorshapes: Operand_kind.Payload.Idref.t ;
          minorshapes: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          pixelresolution: Operand_kind.Payload.Idref.t ;
          bidirectionalweight: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcfmeinitializeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srccoord: Operand_kind.Payload.Idref.t ;
          motionvectors: Operand_kind.Payload.Idref.t ;
          majorshapes: Operand_kind.Payload.Idref.t ;
          minorshapes: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          pixelresolution: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeadjustrefoffsetintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          refoffset: Operand_kind.Payload.Idref.t ;
          srccoord: Operand_kind.Payload.Idref.t ;
          refwindowsize: Operand_kind.Payload.Idref.t ;
          imagesize: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeconverttomcepayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeconverttomceresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithdualreferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          streamincomponents: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          streamincomponents: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithsinglereferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          streamincomponents: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          streamincomponents: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetborderreachedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          imageselect: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetdualreferencestreaminintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetsinglereferencestreaminintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t } 
          |
          Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t ;
          majorshape: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegettruncatedsearchindicationintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimeinitializeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srccoord: Operand_kind.Payload.Idref.t ;
          partitionmask: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimerefwindowsizeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          searchwindowconfig: Operand_kind.Payload.Idref.t ;
          dualref: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetdualreferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          fwdrefoffset: Operand_kind.Payload.Idref.t ;
          bwdrefoffset: Operand_kind.Payload.Idref.t ;
          searchwindowconfig: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetearlysearchterminationthresholdintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          threshold: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetmaxmotionvectorcountintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          maxmotionvectorcount: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetsinglereferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          refoffset: Operand_kind.Payload.Idref.t ;
          searchwindowconfig: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetunidirectionalmixdisableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimesetweightedsadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedsadweights: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimestripdualreferencestreamoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcimestripsinglereferencestreamoutintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttoimepayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttoimeresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttorefpayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttorefresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttosicpayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmceconverttosicresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetbestinterdistortionsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          slicetype: Operand_kind.Payload.Idref.t ;
          qp: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opsubgroupavcmcegetinterdirectionsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetinterdistortionsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetintermajorshapeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetinterminorshapeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetintermotionvectorcountintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetinterreferenceidsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          packedreferenceparameterfieldpolarities:
            Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcegetmotionvectorsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetaconlyhaarintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          forwardreferencefieldpolarity: Operand_kind.Payload.Idref.t ;
          backwardreferencefieldpolarity: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          referencebasepenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetinterdirectionpenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          directioncost: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetintershapepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedshapepenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedcostcenterdelta: Operand_kind.Payload.Idref.t ;
          packedcosttable: Operand_kind.Payload.Idref.t ;
          costprecision: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          referencefieldpolarity: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sourcefieldpolarity: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefconverttomcepayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefconverttomceresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefevaluatewithdualreferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefevaluatewithmultireferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          packedreferencefieldpolarities: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefevaluatewithsinglereferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefsetbidirectionalmixdisableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcrefsetbilinearfilterenableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconfigureipelumachromaintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          lumaintrapartitionmask: Operand_kind.Payload.Idref.t ;
          intraneighbouravailabilty: Operand_kind.Payload.Idref.t ;
          leftedgelumapixels: Operand_kind.Payload.Idref.t ;
          upperleftcornerlumapixel: Operand_kind.Payload.Idref.t ;
          upperedgelumapixels: Operand_kind.Payload.Idref.t ;
          upperrightedgelumapixels: Operand_kind.Payload.Idref.t ;
          leftedgechromapixels: Operand_kind.Payload.Idref.t ;
          upperleftcornerchromapixel: Operand_kind.Payload.Idref.t ;
          upperedgechromapixels: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconfigureipelumaintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          lumaintrapartitionmask: Operand_kind.Payload.Idref.t ;
          intraneighbouravailabilty: Operand_kind.Payload.Idref.t ;
          leftedgelumapixels: Operand_kind.Payload.Idref.t ;
          upperleftcornerlumapixel: Operand_kind.Payload.Idref.t ;
          upperedgelumapixels: Operand_kind.Payload.Idref.t ;
          upperrightedgelumapixels: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconfigureskcintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          skipblockpartitiontype: Operand_kind.Payload.Idref.t ;
          skipmotionvectormask: Operand_kind.Payload.Idref.t ;
          motionvectors: Operand_kind.Payload.Idref.t ;
          bidirectionalweight: Operand_kind.Payload.Idref.t ;
          sadadjustment: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconverttomcepayloadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicconverttomceresultintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluateipeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluatewithdualreferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          fwdrefimage: Operand_kind.Payload.Idref.t ;
          bwdrefimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluatewithmultireferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          packedreferenceids: Operand_kind.Payload.Idref.t ;
          packedreferencefieldpolarities: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicevaluatewithsinglereferenceintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srcimage: Operand_kind.Payload.Idref.t ;
          refimage: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetbestipechromadistortionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetbestipelumadistortionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetinterrawsadsintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetipechromamodeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetipelumashapeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetmotionvectormaskintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          skipblockpartitiontype: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetpackedipelumamodesintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicinitializeintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          srccoord: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetbilinearfilterenableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetblockbasedrawskipsadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          blockbasedskiptype: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          chromamodebasepenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetintralumamodecostfunctionintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          lumamodepenalty: Operand_kind.Payload.Idref.t ;
          lumapackedneighbormodes: Operand_kind.Payload.Idref.t ;
          lumapackednondcpenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetintralumashapepenaltyintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedshapepenalty: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opsubgroupavcsicsetskcforwardtransformenableintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packedsadcoefficients: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Optasksequenceasyncaltera of
          {
          sequence: Operand_kind.Payload.Idref.t ;
          arguments: Operand_kind.Payload.Idref.t list } 
          | Optasksequencecreatealtera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          function_: Operand_kind.Payload.Idref.t ;
          pipelined: Operand_kind.Payload.Literalinteger.t ;
          usestallenableclusters: Operand_kind.Payload.Literalinteger.t ;
          getcapacity: Operand_kind.Payload.Literalinteger.t ;
          asynccapacity: Operand_kind.Payload.Literalinteger.t } 
          | Optasksequencegetaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sequence: Operand_kind.Payload.Idref.t } 
          | Optasksequencereleasealtera of
          {
          sequence: Operand_kind.Payload.Idref.t } 
          | Optypeavcimedualreferencestreaminintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimepayloadintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimeresultdualreferencestreamoutintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimeresultintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimeresultsinglereferencestreamoutintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcimesinglereferencestreaminintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcmcepayloadintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcmceresultintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcrefpayloadintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcrefresultintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcsicpayloadintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeavcsicresultintel of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypetasksequencealtera of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypevmeimageintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          imagetype: Operand_kind.Payload.Idref.t } 
          | Opvmeimageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          imagetype: Operand_kind.Payload.Idref.t ;
          sampler: Operand_kind.Payload.Idref.t } 
          | Opwritepipeblockingaltera of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } [@@deriving
                                                            compare, sexp_of]
        let provisional =
          function
          | Opaliasdomaindeclintel _ -> false
          | Opaliasscopedeclintel _ -> false
          | Opaliasscopelistdeclintel _ -> false
          | Oparbitraryfloatacosintel _ -> false
          | Oparbitraryfloatacospiintel _ -> false
          | Oparbitraryfloataddaltera _ -> false
          | Oparbitraryfloatasinintel _ -> false
          | Oparbitraryfloatasinpiintel _ -> false
          | Oparbitraryfloatatan2intel _ -> false
          | Oparbitraryfloatatanintel _ -> false
          | Oparbitraryfloatatanpiintel _ -> false
          | Oparbitraryfloatcastaltera _ -> false
          | Oparbitraryfloatcastfromintaltera _ -> false
          | Oparbitraryfloatcasttointaltera _ -> false
          | Oparbitraryfloatcbrtaltera _ -> false
          | Oparbitraryfloatcosintel _ -> false
          | Oparbitraryfloatcospiintel _ -> false
          | Oparbitraryfloatdivaltera _ -> false
          | Oparbitraryfloateqaltera _ -> false
          | Oparbitraryfloatexp10intel _ -> false
          | Oparbitraryfloatexp2intel _ -> false
          | Oparbitraryfloatexpintel _ -> false
          | Oparbitraryfloatexpm1intel _ -> false
          | Oparbitraryfloatgealtera _ -> false
          | Oparbitraryfloatgtaltera _ -> false
          | Oparbitraryfloathypotaltera _ -> false
          | Oparbitraryfloatlealtera _ -> false
          | Oparbitraryfloatlog10intel _ -> false
          | Oparbitraryfloatlog1pintel _ -> false
          | Oparbitraryfloatlog2intel _ -> false
          | Oparbitraryfloatlogintel _ -> false
          | Oparbitraryfloatltaltera _ -> false
          | Oparbitraryfloatmulaltera _ -> false
          | Oparbitraryfloatpowintel _ -> false
          | Oparbitraryfloatpownintel _ -> false
          | Oparbitraryfloatpowrintel _ -> false
          | Oparbitraryfloatrecipaltera _ -> false
          | Oparbitraryfloatrsqrtaltera _ -> false
          | Oparbitraryfloatsincosintel _ -> false
          | Oparbitraryfloatsincospialtera _ -> false
          | Oparbitraryfloatsinintel _ -> false
          | Oparbitraryfloatsinpiintel _ -> false
          | Oparbitraryfloatsqrtaltera _ -> false
          | Oparbitraryfloatsubaltera _ -> false
          | Opasmcallintel _ -> false
          | Opasmintel _ -> false
          | Opasmtargetintel _ -> false
          | Opconstantfunctionpointerintel _ -> false
          | Opcrossworkgroupcasttoptraltera _ -> false
          | Opfixedcosaltera _ -> false
          | Opfixedcospialtera _ -> false
          | Opfixedexpaltera _ -> false
          | Opfixedlogaltera _ -> false
          | Opfixedrecipaltera _ -> false
          | Opfixedrsqrtaltera _ -> false
          | Opfixedsinaltera _ -> false
          | Opfixedsincosaltera _ -> false
          | Opfixedsincospialtera _ -> false
          | Opfixedsinpialtera _ -> false
          | Opfixedsqrtaltera _ -> false
          | Opfpgaregaltera _ -> false
          | Opfunctionpointercallintel _ -> false
          | Opptrcasttocrossworkgroupaltera _ -> false
          | Opreadpipeblockingaltera _ -> false
          | Opsubgroupavcbmeinitializeintel _ -> false
          | Opsubgroupavcfmeinitializeintel _ -> false
          | Opsubgroupavcimeadjustrefoffsetintel _ -> false
          | Opsubgroupavcimeconverttomcepayloadintel _ -> false
          | Opsubgroupavcimeconverttomceresultintel _ -> false
          | Opsubgroupavcimeevaluatewithdualreferenceintel _ -> false
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel _ -> false
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel _ ->
              false
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel _ ->
              false
          | Opsubgroupavcimeevaluatewithsinglereferenceintel _ -> false
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel _ ->
              false
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel _ ->
              false
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel _ ->
              false
          | Opsubgroupavcimegetborderreachedintel _ -> false
          | Opsubgroupavcimegetdualreferencestreaminintel _ -> false
          | Opsubgroupavcimegetsinglereferencestreaminintel _ -> false
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              _ -> false
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              _ -> false
          | Opsubgroupavcimegettruncatedsearchindicationintel _ -> false
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel _ ->
              false
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel _ ->
              false
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel _ ->
              false
          | Opsubgroupavcimeinitializeintel _ -> false
          | Opsubgroupavcimerefwindowsizeintel _ -> false
          | Opsubgroupavcimesetdualreferenceintel _ -> false
          | Opsubgroupavcimesetearlysearchterminationthresholdintel _ ->
              false
          | Opsubgroupavcimesetmaxmotionvectorcountintel _ -> false
          | Opsubgroupavcimesetsinglereferenceintel _ -> false
          | Opsubgroupavcimesetunidirectionalmixdisableintel _ -> false
          | Opsubgroupavcimesetweightedsadintel _ -> false
          | Opsubgroupavcimestripdualreferencestreamoutintel _ -> false
          | Opsubgroupavcimestripsinglereferencestreamoutintel _ -> false
          | Opsubgroupavcmceconverttoimepayloadintel _ -> false
          | Opsubgroupavcmceconverttoimeresultintel _ -> false
          | Opsubgroupavcmceconverttorefpayloadintel _ -> false
          | Opsubgroupavcmceconverttorefresultintel _ -> false
          | Opsubgroupavcmceconverttosicpayloadintel _ -> false
          | Opsubgroupavcmceconverttosicresultintel _ -> false
          | Opsubgroupavcmcegetbestinterdistortionsintel _ -> false
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel _ -> false
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel _
              -> false
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel _ -> false
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel _ ->
              false
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel _ -> false
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel _ ->
              false
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel _ -> false
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel _ -> false
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel _ -> false
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel _ -> false
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel _ -> false
          | Opsubgroupavcmcegetinterdirectionsintel _ -> false
          | Opsubgroupavcmcegetinterdistortionsintel _ -> false
          | Opsubgroupavcmcegetintermajorshapeintel _ -> false
          | Opsubgroupavcmcegetinterminorshapeintel _ -> false
          | Opsubgroupavcmcegetintermotionvectorcountintel _ -> false
          | Opsubgroupavcmcegetinterreferenceidsintel _ -> false
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel _
              -> false
          | Opsubgroupavcmcegetmotionvectorsintel _ -> false
          | Opsubgroupavcmcesetaconlyhaarintel _ -> false
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel _
              -> false
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel _ -> false
          | Opsubgroupavcmcesetinterdirectionpenaltyintel _ -> false
          | Opsubgroupavcmcesetintershapepenaltyintel _ -> false
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel _ -> false
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel _
              -> false
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel _ -> false
          | Opsubgroupavcrefconverttomcepayloadintel _ -> false
          | Opsubgroupavcrefconverttomceresultintel _ -> false
          | Opsubgroupavcrefevaluatewithdualreferenceintel _ -> false
          | Opsubgroupavcrefevaluatewithmultireferenceintel _ -> false
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel _ ->
              false
          | Opsubgroupavcrefevaluatewithsinglereferenceintel _ -> false
          | Opsubgroupavcrefsetbidirectionalmixdisableintel _ -> false
          | Opsubgroupavcrefsetbilinearfilterenableintel _ -> false
          | Opsubgroupavcsicconfigureipelumachromaintel _ -> false
          | Opsubgroupavcsicconfigureipelumaintel _ -> false
          | Opsubgroupavcsicconfigureskcintel _ -> false
          | Opsubgroupavcsicconverttomcepayloadintel _ -> false
          | Opsubgroupavcsicconverttomceresultintel _ -> false
          | Opsubgroupavcsicevaluateipeintel _ -> false
          | Opsubgroupavcsicevaluatewithdualreferenceintel _ -> false
          | Opsubgroupavcsicevaluatewithmultireferenceintel _ -> false
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel _ ->
              false
          | Opsubgroupavcsicevaluatewithsinglereferenceintel _ -> false
          | Opsubgroupavcsicgetbestipechromadistortionintel _ -> false
          | Opsubgroupavcsicgetbestipelumadistortionintel _ -> false
          | Opsubgroupavcsicgetinterrawsadsintel _ -> false
          | Opsubgroupavcsicgetipechromamodeintel _ -> false
          | Opsubgroupavcsicgetipelumashapeintel _ -> false
          | Opsubgroupavcsicgetmotionvectormaskintel _ -> false
          | Opsubgroupavcsicgetpackedipelumamodesintel _ -> false
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel _ -> false
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel _ -> false
          | Opsubgroupavcsicinitializeintel _ -> false
          | Opsubgroupavcsicsetbilinearfilterenableintel _ -> false
          | Opsubgroupavcsicsetblockbasedrawskipsadintel _ -> false
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel _ -> false
          | Opsubgroupavcsicsetintralumamodecostfunctionintel _ -> false
          | Opsubgroupavcsicsetintralumashapepenaltyintel _ -> false
          | Opsubgroupavcsicsetskcforwardtransformenableintel _ -> false
          | Optasksequenceasyncaltera _ -> false
          | Optasksequencecreatealtera _ -> false
          | Optasksequencegetaltera _ -> false
          | Optasksequencereleasealtera _ -> false
          | Optypeavcimedualreferencestreaminintel _ -> false
          | Optypeavcimepayloadintel _ -> false
          | Optypeavcimeresultdualreferencestreamoutintel _ -> false
          | Optypeavcimeresultintel _ -> false
          | Optypeavcimeresultsinglereferencestreamoutintel _ -> false
          | Optypeavcimesinglereferencestreaminintel _ -> false
          | Optypeavcmcepayloadintel _ -> false
          | Optypeavcmceresultintel _ -> false
          | Optypeavcrefpayloadintel _ -> false
          | Optypeavcrefresultintel _ -> false
          | Optypeavcsicpayloadintel _ -> false
          | Optypeavcsicresultintel _ -> false
          | Optypetasksequencealtera _ -> false
          | Optypevmeimageintel _ -> false
          | Opvmeimageintel _ -> false
          | Opwritepipeblockingaltera _ -> false
        let value =
          function
          | Opaliasdomaindeclintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  (t.name |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5911l in
              heading :: payload
          | Opaliasscopedeclintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.aliasdomain;
                  (t.name |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5912l in
              heading :: payload
          | Opaliasscopelistdeclintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.aliasscope1aliasscope2___
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5913l in
              heading :: payload
          | Oparbitraryfloatacosintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.m1;
                  Operand_kind.Payload.Literalinteger.value t.mout;
                  Operand_kind.Payload.Literalinteger.value
                    t.enablesubnormals;
                  Operand_kind.Payload.Literalinteger.value t.roundingmode;
                  Operand_kind.Payload.Literalinteger.value
                    t.roundingaccuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5875l in
              heading :: payload
          | Oparbitraryfloatacospiintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5876l in
              heading :: payload
          | Oparbitraryfloataddaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5846l in
              heading :: payload
          | Oparbitraryfloatasinintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5873l in
              heading :: payload
          | Oparbitraryfloatasinpiintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5874l in
              heading :: payload
          | Oparbitraryfloatatan2intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5879l in
              heading :: payload
          | Oparbitraryfloatatanintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5877l in
              heading :: payload
          | Oparbitraryfloatatanpiintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5878l in
              heading :: payload
          | Oparbitraryfloatcastaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5841l in
              heading :: payload
          | Oparbitraryfloatcastfromintaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.fromsign;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5842l in
              heading :: payload
          | Oparbitraryfloatcasttointaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.tosign;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5843l in
              heading :: payload
          | Oparbitraryfloatcbrtaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5857l in
              heading :: payload
          | Oparbitraryfloatcosintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5869l in
              heading :: payload
          | Oparbitraryfloatcospiintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5872l in
              heading :: payload
          | Oparbitraryfloatdivaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5849l in
              heading :: payload
          | Oparbitraryfloateqaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5854l in
              heading :: payload
          | Oparbitraryfloatexp10intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5866l in
              heading :: payload
          | Oparbitraryfloatexp2intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5865l in
              heading :: payload
          | Oparbitraryfloatexpintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5864l in
              heading :: payload
          | Oparbitraryfloatexpm1intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5867l in
              heading :: payload
          | Oparbitraryfloatgealtera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5851l in
              heading :: payload
          | Oparbitraryfloatgtaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5850l in
              heading :: payload
          | Oparbitraryfloathypotaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5858l in
              heading :: payload
          | Oparbitraryfloatlealtera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5853l in
              heading :: payload
          | Oparbitraryfloatlog10intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5862l in
              heading :: payload
          | Oparbitraryfloatlog1pintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5863l in
              heading :: payload
          | Oparbitraryfloatlog2intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5861l in
              heading :: payload
          | Oparbitraryfloatlogintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5860l in
              heading :: payload
          | Oparbitraryfloatltaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5852l in
              heading :: payload
          | Oparbitraryfloatmulaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5848l in
              heading :: payload
          | Oparbitraryfloatpowintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5880l in
              heading :: payload
          | Oparbitraryfloatpownintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.signofb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5882l in
              heading :: payload
          | Oparbitraryfloatpowrintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5881l in
              heading :: payload
          | Oparbitraryfloatrecipaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5855l in
              heading :: payload
          | Oparbitraryfloatrsqrtaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5856l in
              heading :: payload
          | Oparbitraryfloatsincosintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5870l in
              heading :: payload
          | Oparbitraryfloatsincospialtera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value
                    t.roundingaccuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5840l in
              heading :: payload
          | Oparbitraryfloatsinintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5868l in
              heading :: payload
          | Oparbitraryfloatsinpiintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5871l in
              heading :: payload
          | Oparbitraryfloatsqrtaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5859l in
              heading :: payload
          | Oparbitraryfloatsubaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Literalinteger.value t.ma;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Literalinteger.value t.mb;
                  Operand_kind.Payload.Literalinteger.value t.mresult;
                  Operand_kind.Payload.Literalinteger.value t.subnormal;
                  Operand_kind.Payload.Literalinteger.value t.rounding;
                  Operand_kind.Payload.Literalinteger.value t.accuracy] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5847l in
              heading :: payload
          | Opasmcallintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.asm;
                  List.concat_map t.argument
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5611l in
              heading :: payload
          | Opasmintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.asmtype;
                  Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Literalstring.value t.asminstructions;
                  Operand_kind.Payload.Literalstring.value t.constraints] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5610l in
              heading :: payload
          | Opasmtargetintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalstring.value t.asmtarget] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5609l in
              heading :: payload
          | Opconstantfunctionpointerintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.function_] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5600l in
              heading :: payload
          | Opcrossworkgroupcasttoptraltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5938l in
              heading :: payload
          | Opfixedcosaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5927l in
              heading :: payload
          | Opfixedcospialtera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5930l in
              heading :: payload
          | Opfixedexpaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5933l in
              heading :: payload
          | Opfixedlogaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5932l in
              heading :: payload
          | Opfixedrecipaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5924l in
              heading :: payload
          | Opfixedrsqrtaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5925l in
              heading :: payload
          | Opfixedsinaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5926l in
              heading :: payload
          | Opfixedsincosaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5928l in
              heading :: payload
          | Opfixedsincospialtera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5931l in
              heading :: payload
          | Opfixedsinpialtera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5929l in
              heading :: payload
          | Opfixedsqrtaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Literalinteger.value t.s;
                  Operand_kind.Payload.Literalinteger.value t.i;
                  Operand_kind.Payload.Literalinteger.value t.ri;
                  Operand_kind.Payload.Literalinteger.value t.q;
                  Operand_kind.Payload.Literalinteger.value t.o] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5923l in
              heading :: payload
          | Opfpgaregaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5949l in
              heading :: payload
          | Opfunctionpointercallintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.operand1
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5601l in
              heading :: payload
          | Opptrcasttocrossworkgroupaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5934l in
              heading :: payload
          | Opreadpipeblockingaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5946l in
              heading :: payload
          | Opsubgroupavcbmeinitializeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srccoord;
                  Operand_kind.Payload.Idref.value t.motionvectors;
                  Operand_kind.Payload.Idref.value t.majorshapes;
                  Operand_kind.Payload.Idref.value t.minorshapes;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.pixelresolution;
                  Operand_kind.Payload.Idref.value t.bidirectionalweight;
                  Operand_kind.Payload.Idref.value t.sadadjustment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5782l in
              heading :: payload
          | Opsubgroupavcfmeinitializeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srccoord;
                  Operand_kind.Payload.Idref.value t.motionvectors;
                  Operand_kind.Payload.Idref.value t.majorshapes;
                  Operand_kind.Payload.Idref.value t.minorshapes;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.pixelresolution;
                  Operand_kind.Payload.Idref.value t.sadadjustment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5781l in
              heading :: payload
          | Opsubgroupavcimeadjustrefoffsetintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.refoffset;
                  Operand_kind.Payload.Idref.value t.srccoord;
                  Operand_kind.Payload.Idref.value t.refwindowsize;
                  Operand_kind.Payload.Idref.value t.imagesize] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5751l in
              heading :: payload
          | Opsubgroupavcimeconverttomcepayloadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5752l in
              heading :: payload
          | Opsubgroupavcimeconverttomceresultintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5765l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithdualreferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.fwdrefimage;
                  Operand_kind.Payload.Idref.value t.bwdrefimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5758l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.fwdrefimage;
                  Operand_kind.Payload.Idref.value t.bwdrefimage;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.streamincomponents] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5760l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.fwdrefimage;
                  Operand_kind.Payload.Idref.value t.bwdrefimage;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.streamincomponents] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5764l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.fwdrefimage;
                  Operand_kind.Payload.Idref.value t.bwdrefimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5762l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithsinglereferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.refimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5757l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.refimage;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.streamincomponents] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5759l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.refimage;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.streamincomponents] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5763l in
              heading :: payload
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.refimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5761l in
              heading :: payload
          | Opsubgroupavcimegetborderreachedintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.imageselect;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5776l in
              heading :: payload
          | Opsubgroupavcimegetdualreferencestreaminintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5767l in
              heading :: payload
          | Opsubgroupavcimegetsinglereferencestreaminintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5766l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.majorshape;
                  Operand_kind.Payload.Idref.value t.direction] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5774l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.majorshape;
                  Operand_kind.Payload.Idref.value t.direction] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5773l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.majorshape;
                  Operand_kind.Payload.Idref.value t.direction] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5775l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.majorshape] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5771l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.majorshape] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5770l in
              heading :: payload
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload;
                  Operand_kind.Payload.Idref.value t.majorshape] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5772l in
              heading :: payload
          | Opsubgroupavcimegettruncatedsearchindicationintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5777l in
              heading :: payload
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5778l in
              heading :: payload
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5780l in
              heading :: payload
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5779l in
              heading :: payload
          | Opsubgroupavcimeinitializeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srccoord;
                  Operand_kind.Payload.Idref.value t.partitionmask;
                  Operand_kind.Payload.Idref.value t.sadadjustment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5747l in
              heading :: payload
          | Opsubgroupavcimerefwindowsizeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.searchwindowconfig;
                  Operand_kind.Payload.Idref.value t.dualref] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5750l in
              heading :: payload
          | Opsubgroupavcimesetdualreferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.fwdrefoffset;
                  Operand_kind.Payload.Idref.value t.bwdrefoffset;
                  Operand_kind.Payload.Idref.value t.searchwindowconfig;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5749l in
              heading :: payload
          | Opsubgroupavcimesetearlysearchterminationthresholdintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.threshold;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5755l in
              heading :: payload
          | Opsubgroupavcimesetmaxmotionvectorcountintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.maxmotionvectorcount;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5753l in
              heading :: payload
          | Opsubgroupavcimesetsinglereferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.refoffset;
                  Operand_kind.Payload.Idref.value t.searchwindowconfig;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5748l in
              heading :: payload
          | Opsubgroupavcimesetunidirectionalmixdisableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5754l in
              heading :: payload
          | Opsubgroupavcimesetweightedsadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.packedsadweights;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5756l in
              heading :: payload
          | Opsubgroupavcimestripdualreferencestreamoutintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5769l in
              heading :: payload
          | Opsubgroupavcimestripsinglereferencestreamoutintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5768l in
              heading :: payload
          | Opsubgroupavcmceconverttoimepayloadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5732l in
              heading :: payload
          | Opsubgroupavcmceconverttoimeresultintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5733l in
              heading :: payload
          | Opsubgroupavcmceconverttorefpayloadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5734l in
              heading :: payload
          | Opsubgroupavcmceconverttorefresultintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5735l in
              heading :: payload
          | Opsubgroupavcmceconverttosicpayloadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5736l in
              heading :: payload
          | Opsubgroupavcmceconverttosicresultintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5737l in
              heading :: payload
          | Opsubgroupavcmcegetbestinterdistortionsintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5740l in
              heading :: payload
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5721l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel t
              ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.slicetype;
                  Operand_kind.Payload.Idref.value t.qp] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5713l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.slicetype;
                  Operand_kind.Payload.Idref.value t.qp] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5717l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.slicetype;
                  Operand_kind.Payload.Idref.value t.qp] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5720l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.slicetype;
                  Operand_kind.Payload.Idref.value t.qp] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5715l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5727l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.slicetype;
                  Operand_kind.Payload.Idref.value t.qp] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5725l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.slicetype;
                  Operand_kind.Payload.Idref.value t.qp] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5719l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5723l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5722l in
              heading :: payload
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5726l in
              heading :: payload
          | Opsubgroupavcmcegetinterdirectionsintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5743l in
              heading :: payload
          | Opsubgroupavcmcegetinterdistortionsintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5739l in
              heading :: payload
          | Opsubgroupavcmcegetintermajorshapeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5741l in
              heading :: payload
          | Opsubgroupavcmcegetinterminorshapeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5742l in
              heading :: payload
          | Opsubgroupavcmcegetintermotionvectorcountintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5744l in
              heading :: payload
          | Opsubgroupavcmcegetinterreferenceidsintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5745l in
              heading :: payload
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel t
              ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.packedreferenceids;
                  Operand_kind.Payload.Idref.value
                    t.packedreferenceparameterfieldpolarities;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5746l in
              heading :: payload
          | Opsubgroupavcmcegetmotionvectorsintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5738l in
              heading :: payload
          | Opsubgroupavcmcesetaconlyhaarintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5728l in
              heading :: payload
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel t
              ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value
                    t.forwardreferencefieldpolarity;
                  Operand_kind.Payload.Idref.value
                    t.backwardreferencefieldpolarity;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5731l in
              heading :: payload
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.referencebasepenalty;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5714l in
              heading :: payload
          | Opsubgroupavcmcesetinterdirectionpenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.directioncost;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5718l in
              heading :: payload
          | Opsubgroupavcmcesetintershapepenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.packedshapepenalty;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5716l in
              heading :: payload
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.packedcostcenterdelta;
                  Operand_kind.Payload.Idref.value t.packedcosttable;
                  Operand_kind.Payload.Idref.value t.costprecision;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5724l in
              heading :: payload
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel t
              ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.referencefieldpolarity;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5730l in
              heading :: payload
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sourcefieldpolarity;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5729l in
              heading :: payload
          | Opsubgroupavcrefconverttomcepayloadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5783l in
              heading :: payload
          | Opsubgroupavcrefconverttomceresultintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5790l in
              heading :: payload
          | Opsubgroupavcrefevaluatewithdualreferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.fwdrefimage;
                  Operand_kind.Payload.Idref.value t.bwdrefimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5787l in
              heading :: payload
          | Opsubgroupavcrefevaluatewithmultireferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.packedreferenceids;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5788l in
              heading :: payload
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.packedreferenceids;
                  Operand_kind.Payload.Idref.value
                    t.packedreferencefieldpolarities;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5789l in
              heading :: payload
          | Opsubgroupavcrefevaluatewithsinglereferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.refimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5786l in
              heading :: payload
          | Opsubgroupavcrefsetbidirectionalmixdisableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5784l in
              heading :: payload
          | Opsubgroupavcrefsetbilinearfilterenableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5785l in
              heading :: payload
          | Opsubgroupavcsicconfigureipelumachromaintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.lumaintrapartitionmask;
                  Operand_kind.Payload.Idref.value
                    t.intraneighbouravailabilty;
                  Operand_kind.Payload.Idref.value t.leftedgelumapixels;
                  Operand_kind.Payload.Idref.value t.upperleftcornerlumapixel;
                  Operand_kind.Payload.Idref.value t.upperedgelumapixels;
                  Operand_kind.Payload.Idref.value t.upperrightedgelumapixels;
                  Operand_kind.Payload.Idref.value t.leftedgechromapixels;
                  Operand_kind.Payload.Idref.value
                    t.upperleftcornerchromapixel;
                  Operand_kind.Payload.Idref.value t.upperedgechromapixels;
                  Operand_kind.Payload.Idref.value t.sadadjustment;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5794l in
              heading :: payload
          | Opsubgroupavcsicconfigureipelumaintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.lumaintrapartitionmask;
                  Operand_kind.Payload.Idref.value
                    t.intraneighbouravailabilty;
                  Operand_kind.Payload.Idref.value t.leftedgelumapixels;
                  Operand_kind.Payload.Idref.value t.upperleftcornerlumapixel;
                  Operand_kind.Payload.Idref.value t.upperedgelumapixels;
                  Operand_kind.Payload.Idref.value t.upperrightedgelumapixels;
                  Operand_kind.Payload.Idref.value t.sadadjustment;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5793l in
              heading :: payload
          | Opsubgroupavcsicconfigureskcintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.skipblockpartitiontype;
                  Operand_kind.Payload.Idref.value t.skipmotionvectormask;
                  Operand_kind.Payload.Idref.value t.motionvectors;
                  Operand_kind.Payload.Idref.value t.bidirectionalweight;
                  Operand_kind.Payload.Idref.value t.sadadjustment;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5792l in
              heading :: payload
          | Opsubgroupavcsicconverttomcepayloadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5796l in
              heading :: payload
          | Opsubgroupavcsicconverttomceresultintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5808l in
              heading :: payload
          | Opsubgroupavcsicevaluateipeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5803l in
              heading :: payload
          | Opsubgroupavcsicevaluatewithdualreferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.fwdrefimage;
                  Operand_kind.Payload.Idref.value t.bwdrefimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5805l in
              heading :: payload
          | Opsubgroupavcsicevaluatewithmultireferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.packedreferenceids;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5806l in
              heading :: payload
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.packedreferenceids;
                  Operand_kind.Payload.Idref.value
                    t.packedreferencefieldpolarities;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5807l in
              heading :: payload
          | Opsubgroupavcsicevaluatewithsinglereferenceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srcimage;
                  Operand_kind.Payload.Idref.value t.refimage;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5804l in
              heading :: payload
          | Opsubgroupavcsicgetbestipechromadistortionintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5811l in
              heading :: payload
          | Opsubgroupavcsicgetbestipelumadistortionintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5810l in
              heading :: payload
          | Opsubgroupavcsicgetinterrawsadsintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5816l in
              heading :: payload
          | Opsubgroupavcsicgetipechromamodeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5813l in
              heading :: payload
          | Opsubgroupavcsicgetipelumashapeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5809l in
              heading :: payload
          | Opsubgroupavcsicgetmotionvectormaskintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.skipblockpartitiontype;
                  Operand_kind.Payload.Idref.value t.direction] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5795l in
              heading :: payload
          | Opsubgroupavcsicgetpackedipelumamodesintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5812l in
              heading :: payload
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5814l in
              heading :: payload
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5815l in
              heading :: payload
          | Opsubgroupavcsicinitializeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.srccoord] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5791l in
              heading :: payload
          | Opsubgroupavcsicsetbilinearfilterenableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5800l in
              heading :: payload
          | Opsubgroupavcsicsetblockbasedrawskipsadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.blockbasedskiptype;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5802l in
              heading :: payload
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.chromamodebasepenalty;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5799l in
              heading :: payload
          | Opsubgroupavcsicsetintralumamodecostfunctionintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.lumamodepenalty;
                  Operand_kind.Payload.Idref.value t.lumapackedneighbormodes;
                  Operand_kind.Payload.Idref.value t.lumapackednondcpenalty;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5798l in
              heading :: payload
          | Opsubgroupavcsicsetintralumashapepenaltyintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.packedshapepenalty;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5797l in
              heading :: payload
          | Opsubgroupavcsicsetskcforwardtransformenableintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.packedsadcoefficients;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5801l in
              heading :: payload
          | Optasksequenceasyncaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.sequence;
                  List.concat_map t.arguments
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6164l in
              heading :: payload
          | Optasksequencecreatealtera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.function_;
                  Operand_kind.Payload.Literalinteger.value t.pipelined;
                  Operand_kind.Payload.Literalinteger.value
                    t.usestallenableclusters;
                  Operand_kind.Payload.Literalinteger.value t.getcapacity;
                  Operand_kind.Payload.Literalinteger.value t.asynccapacity] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6163l in
              heading :: payload
          | Optasksequencegetaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sequence] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6165l in
              heading :: payload
          | Optasksequencereleasealtera t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.sequence] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6166l in
              heading :: payload
          | Optypeavcimedualreferencestreaminintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5710l in
              heading :: payload
          | Optypeavcimepayloadintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5701l in
              heading :: payload
          | Optypeavcimeresultdualreferencestreamoutintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5708l in
              heading :: payload
          | Optypeavcimeresultintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5706l in
              heading :: payload
          | Optypeavcimeresultsinglereferencestreamoutintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5707l in
              heading :: payload
          | Optypeavcimesinglereferencestreaminintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5709l in
              heading :: payload
          | Optypeavcmcepayloadintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5704l in
              heading :: payload
          | Optypeavcmceresultintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5705l in
              heading :: payload
          | Optypeavcrefpayloadintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5702l in
              heading :: payload
          | Optypeavcrefresultintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5711l in
              heading :: payload
          | Optypeavcsicpayloadintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5703l in
              heading :: payload
          | Optypeavcsicresultintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5712l in
              heading :: payload
          | Optypetasksequencealtera t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6199l in
              heading :: payload
          | Optypevmeimageintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.imagetype] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5700l in
              heading :: payload
          | Opvmeimageintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.imagetype;
                  Operand_kind.Payload.Idref.value t.sampler] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5699l in
              heading :: payload
          | Opwritepipeblockingaltera t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5947l in
              heading :: payload
        let any_required_version =
          function
          | Opaliasdomaindeclintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opaliasscopedeclintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opaliasscopelistdeclintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatacosintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatacospiintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloataddaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatasinintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatasinpiintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatatan2intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatatanintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatatanpiintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatcastaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatcastfromintaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatcasttointaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatcbrtaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatcosintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatcospiintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatdivaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloateqaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatexp10intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatexp2intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatexpintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatexpm1intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatgealtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatgtaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloathypotaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatlealtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatlog10intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatlog1pintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatlog2intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatlogintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatltaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatmulaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatpowintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatpownintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatpowrintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatrecipaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatrsqrtaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatsincosintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatsincospialtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatsinintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatsinpiintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatsqrtaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparbitraryfloatsubaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opasmcallintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opasmintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opasmtargetintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantfunctionpointerintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcrossworkgroupcasttoptraltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedcosaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedcospialtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedexpaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedlogaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedrecipaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedrsqrtaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedsinaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedsincosaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedsincospialtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedsinpialtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfixedsqrtaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfpgaregaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunctionpointercallintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opptrcasttocrossworkgroupaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreadpipeblockingaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcbmeinitializeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcfmeinitializeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeadjustrefoffsetintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeconverttomcepayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeconverttomceresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetborderreachedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetdualreferencestreaminintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetsinglereferencestreaminintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegettruncatedsearchindicationintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimeinitializeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimerefwindowsizeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimesetdualreferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimesetearlysearchterminationthresholdintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimesetmaxmotionvectorcountintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimesetsinglereferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimesetunidirectionalmixdisableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimesetweightedsadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimestripdualreferencestreamoutintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcimestripsinglereferencestreamoutintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmceconverttoimepayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmceconverttoimeresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmceconverttorefpayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmceconverttorefresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmceconverttosicpayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmceconverttosicresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetbestinterdistortionsintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel _
              ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetinterdirectionsintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetinterdistortionsintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetintermajorshapeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetinterminorshapeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetintermotionvectorcountintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetinterreferenceidsintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel _
              ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcegetmotionvectorsintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcesetaconlyhaarintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel _
              ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcesetinterdirectionpenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcesetintershapepenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel _
              ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcrefconverttomcepayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcrefconverttomceresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcrefevaluatewithdualreferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcrefevaluatewithmultireferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcrefevaluatewithsinglereferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcrefsetbidirectionalmixdisableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcrefsetbilinearfilterenableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicconfigureipelumachromaintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicconfigureipelumaintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicconfigureskcintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicconverttomcepayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicconverttomceresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicevaluateipeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicevaluatewithdualreferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicevaluatewithmultireferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicevaluatewithsinglereferenceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetbestipechromadistortionintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetbestipelumadistortionintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetinterrawsadsintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetipechromamodeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetipelumashapeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetmotionvectormaskintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetpackedipelumamodesintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicinitializeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicsetbilinearfilterenableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicsetblockbasedrawskipsadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicsetintralumamodecostfunctionintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicsetintralumashapepenaltyintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupavcsicsetskcforwardtransformenableintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optasksequenceasyncaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optasksequencecreatealtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optasksequencegetaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optasksequencereleasealtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcimedualreferencestreaminintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcimepayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcimeresultdualreferencestreamoutintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcimeresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcimeresultsinglereferencestreamoutintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcimesinglereferencestreaminintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcmcepayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcmceresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcrefpayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcrefresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcsicpayloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeavcsicresultintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypetasksequencealtera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypevmeimageintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opvmeimageintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opwritepipeblockingaltera _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opaliasdomaindeclintel _ ->
              [Requirements.Extension.Spv_intel_memory_access_aliasing] |>
                Requirements.Extension.Set.of_list
          | Opaliasscopedeclintel _ ->
              [Requirements.Extension.Spv_intel_memory_access_aliasing] |>
                Requirements.Extension.Set.of_list
          | Opaliasscopelistdeclintel _ ->
              [Requirements.Extension.Spv_intel_memory_access_aliasing] |>
                Requirements.Extension.Set.of_list
          | Oparbitraryfloatacosintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatacospiintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloataddaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatasinintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatasinpiintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatatan2intel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatatanintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatatanpiintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatcastaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatcastfromintaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatcasttointaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatcbrtaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatcosintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatcospiintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatdivaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloateqaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatexp10intel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatexp2intel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatexpintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatexpm1intel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatgealtera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatgtaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloathypotaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatlealtera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatlog10intel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatlog1pintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatlog2intel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatlogintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatltaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatmulaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatpowintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatpownintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatpowrintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatrecipaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatrsqrtaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatsincosintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatsincospialtera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatsinintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatsinpiintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatsqrtaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oparbitraryfloatsubaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opasmcallintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opasmintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opasmtargetintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opconstantfunctionpointerintel _ ->
              [Requirements.Extension.Spv_intel_function_pointers] |>
                Requirements.Extension.Set.of_list
          | Opcrossworkgroupcasttoptraltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfixedcosaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedcospialtera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedexpaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedlogaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedrecipaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedrsqrtaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedsinaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedsincosaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedsincospialtera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfixedsinpialtera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfixedsqrtaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfpgaregaltera _ -> [] |> Requirements.Extension.Set.of_list
          | Opfunctionpointercallintel _ ->
              [Requirements.Extension.Spv_intel_function_pointers] |>
                Requirements.Extension.Set.of_list
          | Opptrcasttocrossworkgroupaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opreadpipeblockingaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcbmeinitializeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcfmeinitializeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeadjustrefoffsetintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeconverttomcepayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeconverttomceresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetborderreachedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetdualreferencestreaminintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetsinglereferencestreaminintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              _ -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              _ -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              _ -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              _ -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              _ -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              _ -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegettruncatedsearchindicationintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimeinitializeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimerefwindowsizeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimesetdualreferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimesetearlysearchterminationthresholdintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimesetmaxmotionvectorcountintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimesetsinglereferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimesetunidirectionalmixdisableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimesetweightedsadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimestripdualreferencestreamoutintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcimestripsinglereferencestreamoutintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmceconverttoimepayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmceconverttoimeresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmceconverttorefpayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmceconverttorefresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmceconverttosicpayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmceconverttosicresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetbestinterdistortionsintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel _
              -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetinterdirectionsintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetinterdistortionsintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetintermajorshapeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetinterminorshapeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetintermotionvectorcountintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetinterreferenceidsintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel _
              -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcegetmotionvectorsintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcesetaconlyhaarintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel _
              -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcesetinterdirectionpenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcesetintershapepenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel _
              -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcrefconverttomcepayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcrefconverttomceresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcrefevaluatewithdualreferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcrefevaluatewithmultireferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcrefevaluatewithsinglereferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcrefsetbidirectionalmixdisableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcrefsetbilinearfilterenableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicconfigureipelumachromaintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicconfigureipelumaintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicconfigureskcintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicconverttomcepayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicconverttomceresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicevaluateipeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicevaluatewithdualreferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicevaluatewithmultireferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicevaluatewithsinglereferenceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetbestipechromadistortionintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetbestipelumadistortionintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetinterrawsadsintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetipechromamodeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetipelumashapeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetmotionvectormaskintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetpackedipelumamodesintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicinitializeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicsetbilinearfilterenableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicsetblockbasedrawskipsadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicsetintralumamodecostfunctionintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicsetintralumashapepenaltyintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupavcsicsetskcforwardtransformenableintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optasksequenceasyncaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optasksequencecreatealtera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optasksequencegetaltera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optasksequencereleasealtera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcimedualreferencestreaminintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcimepayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcimeresultdualreferencestreamoutintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcimeresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcimeresultsinglereferencestreamoutintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcimesinglereferencestreaminintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcmcepayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcmceresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcrefpayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcrefresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcsicpayloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypeavcsicresultintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypetasksequencealtera _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypevmeimageintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opvmeimageintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opwritepipeblockingaltera _ ->
              [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opaliasdomaindeclintel _ ->
              [Operand_kind.Payload.Capability.Memoryaccessaliasingintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opaliasscopedeclintel _ ->
              [Operand_kind.Payload.Capability.Memoryaccessaliasingintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opaliasscopelistdeclintel _ ->
              [Operand_kind.Payload.Capability.Memoryaccessaliasingintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatacosintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatacospiintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloataddaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatasinintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatasinpiintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatatan2intel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatatanintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatatanpiintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatcastaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatcastfromintaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatcasttointaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatcbrtaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatcosintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatcospiintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatdivaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloateqaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatexp10intel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatexp2intel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatexpintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatexpm1intel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatgealtera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatgtaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloathypotaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatlealtera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatlog10intel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatlog1pintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatlog2intel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatlogintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatltaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatmulaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatpowintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatpownintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatpowrintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatrecipaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatrsqrtaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatsincosintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatsincospialtera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatsinintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatsinpiintel _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatsqrtaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oparbitraryfloatsubaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfloatingpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opasmcallintel _ ->
              [Operand_kind.Payload.Capability.Asmintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opasmintel _ ->
              [Operand_kind.Payload.Capability.Asmintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opasmtargetintel _ ->
              [Operand_kind.Payload.Capability.Asmintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconstantfunctionpointerintel _ ->
              [Operand_kind.Payload.Capability.Functionpointersintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcrossworkgroupcasttoptraltera _ ->
              [Operand_kind.Payload.Capability.Usmstorageclassesaltera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfixedcosaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedcospialtera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedexpaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedlogaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedrecipaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedrsqrtaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedsinaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedsincosaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedsincospialtera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedsinpialtera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfixedsqrtaltera _ ->
              [Operand_kind.Payload.Capability.Arbitraryprecisionfixedpointaltera]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfpgaregaltera _ ->
              [Operand_kind.Payload.Capability.Fpgaregaltera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfunctionpointercallintel _ ->
              [Operand_kind.Payload.Capability.Functionpointersintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opptrcasttocrossworkgroupaltera _ ->
              [Operand_kind.Payload.Capability.Usmstorageclassesaltera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreadpipeblockingaltera _ ->
              [Operand_kind.Payload.Capability.Blockingpipesaltera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcbmeinitializeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcfmeinitializeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeadjustrefoffsetintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeconverttomcepayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeconverttomceresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreaminintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreaminoutintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeevaluatewithdualreferencestreamoutintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreaminoutintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeevaluatewithsinglereferencestreamoutintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetborderreachedintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetdualreferencestreaminintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetsinglereferencestreaminintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapedistortionsintel
              _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapemotionvectorsintel
              _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetstreamoutdualreferencemajorshapereferenceidsintel
              _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapedistortionsintel
              _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapemotionvectorsintel
              _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetstreamoutsinglereferencemajorshapereferenceidsintel
              _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegettruncatedsearchindicationintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetunidirectionalearlysearchterminationintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetweightingpatternminimumdistortionintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimegetweightingpatternminimummotionvectorintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimeinitializeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimerefwindowsizeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimesetdualreferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimesetearlysearchterminationthresholdintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimesetmaxmotionvectorcountintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimesetsinglereferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimesetunidirectionalmixdisableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimesetweightedsadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimestripdualreferencestreamoutintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcimestripsinglereferencestreamoutintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmceconverttoimepayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmceconverttoimeresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmceconverttorefpayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmceconverttorefresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmceconverttosicpayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmceconverttosicresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetbestinterdistortionsintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaulthighpenaltycosttableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultinterbasemultireferencepenaltyintel _
              ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultinterdirectionpenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultintermotionvectorcosttableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultintershapepenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultintrachromamodebasepenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationchromaintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultintralumamodepenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultintralumashapepenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultlowpenaltycosttableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultmediumpenaltycosttableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetdefaultnondclumaintrapenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetinterdirectionsintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetinterdistortionsintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetintermajorshapeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetinterminorshapeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetintermotionvectorcountintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetinterreferenceidsintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetinterreferenceinterlacedfieldpolaritiesintel _
              ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcegetmotionvectorsintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcesetaconlyhaarintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcesetdualreferenceinterlacedfieldpolaritiesintel _
              ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcesetinterbasemultireferencepenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcesetinterdirectionpenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcesetintershapepenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcesetmotionvectorcostfunctionintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcesetsinglereferenceinterlacedfieldpolarityintel _
              ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcmcesetsourceinterlacedfieldpolarityintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcrefconverttomcepayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcrefconverttomceresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcrefevaluatewithdualreferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcrefevaluatewithmultireferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcrefevaluatewithmultireferenceinterlacedintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcrefevaluatewithsinglereferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcrefsetbidirectionalmixdisableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcrefsetbilinearfilterenableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicconfigureipelumachromaintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationchromaintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicconfigureipelumaintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicconfigureskcintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicconverttomcepayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicconverttomceresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicevaluateipeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicevaluatewithdualreferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicevaluatewithmultireferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicevaluatewithmultireferenceinterlacedintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicevaluatewithsinglereferenceintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetbestipechromadistortionintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetbestipelumadistortionintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetinterrawsadsintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetipechromamodeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationchromaintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetipelumashapeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetmotionvectormaskintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetpackedipelumamodesintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetpackedskclumacountthresholdintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicgetpackedskclumasumthresholdintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicinitializeintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicsetbilinearfilterenableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicsetblockbasedrawskipsadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicsetintrachromamodecostfunctionintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationchromaintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicsetintralumamodecostfunctionintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel;
              Operand_kind.Payload.Capability.Subgroupavcmotionestimationintraintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicsetintralumashapepenaltyintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupavcsicsetskcforwardtransformenableintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optasksequenceasyncaltera _ ->
              [Operand_kind.Payload.Capability.Tasksequencealtera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optasksequencecreatealtera _ ->
              [Operand_kind.Payload.Capability.Tasksequencealtera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optasksequencegetaltera _ ->
              [Operand_kind.Payload.Capability.Tasksequencealtera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optasksequencereleasealtera _ ->
              [Operand_kind.Payload.Capability.Tasksequencealtera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcimedualreferencestreaminintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcimepayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcimeresultdualreferencestreamoutintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcimeresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcimeresultsinglereferencestreamoutintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcimesinglereferencestreaminintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcmcepayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcmceresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcrefpayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcrefresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcsicpayloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeavcsicresultintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypetasksequencealtera _ ->
              [Operand_kind.Payload.Capability.Tasksequencealtera] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypevmeimageintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opvmeimageintel _ ->
              [Operand_kind.Payload.Capability.Subgroupavcmotionestimationintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opwritepipeblockingaltera _ ->
              [Operand_kind.Payload.Capability.Blockingpipesaltera] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Extension =
      struct
        type t =
          | Opconditionalextensionintel of
          {
          condition: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t } 
          | Opextension of {
          name: Operand_kind.Payload.Literalstring.t } 
          | Opextinst of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          set: Operand_kind.Payload.Idref.t ;
          instruction: Operand_kind.Payload.Literalextinstinteger.t ;
          operand1operand2___: Operand_kind.Payload.Idref.t list } 
          | Opextinstimport of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          name: Operand_kind.Payload.Literalstring.t } 
          | Opextinstwithforwardrefskhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          set: Operand_kind.Payload.Idref.t ;
          instruction: Operand_kind.Payload.Literalextinstinteger.t ;
          operand1operand2___: Operand_kind.Payload.Idref.t list } [@@deriving
                                                                    compare, sexp_of]
        let provisional =
          function
          | Opconditionalextensionintel _ -> true
          | Opextension _ -> false
          | Opextinst _ -> false
          | Opextinstimport _ -> false
          | Opextinstwithforwardrefskhr _ -> false
        let value =
          function
          | Opconditionalextensionintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.condition;
                  Operand_kind.Payload.Literalstring.value t.name] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6248l in
              heading :: payload
          | Opextension t ->
              let payload =
                List.concat [Operand_kind.Payload.Literalstring.value t.name] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 10l in
              heading :: payload
          | Opextinst t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.set;
                  Operand_kind.Payload.Literalextinstinteger.value
                    t.instruction;
                  List.concat_map t.operand1operand2___
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 12l in
              heading :: payload
          | Opextinstimport t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalstring.value t.name] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 11l in
              heading :: payload
          | Opextinstwithforwardrefskhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.set;
                  Operand_kind.Payload.Literalextinstinteger.value
                    t.instruction;
                  List.concat_map t.operand1operand2___
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4433l in
              heading :: payload
        let any_required_version =
          function
          | Opconditionalextensionintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opextension _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opextinst _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opextinstimport _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opextinstwithforwardrefskhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opconditionalextensionintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opextension _ -> [] |> Requirements.Extension.Set.of_list
          | Opextinst _ -> [] |> Requirements.Extension.Set.of_list
          | Opextinstimport _ -> [] |> Requirements.Extension.Set.of_list
          | Opextinstwithforwardrefskhr _ ->
              [Requirements.Extension.Spv_khr_relaxed_extended_instruction]
                |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opconditionalextensionintel _ ->
              [Operand_kind.Payload.Capability.Specconditionalintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opextension _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opextinst _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opextinstimport _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opextinstwithforwardrefskhr _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Function =
      struct
        type t =
          | Opcooperativematrixperelementopnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          func: Operand_kind.Payload.Idref.t ;
          operands: Operand_kind.Payload.Idref.t list } 
          | Opfunction of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          functioncontrol: Operand_kind.Payload.Functioncontrol.t ;
          functiontype: Operand_kind.Payload.Idref.t } 
          | Opfunctioncall of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          function_: Operand_kind.Payload.Idref.t ;
          argument0argument1___: Operand_kind.Payload.Idref.t list } 
          | Opfunctionend 
          | Opfunctionparameter of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } [@@deriving
                                                        compare, sexp_of]
        let provisional =
          function
          | Opcooperativematrixperelementopnv _ -> false
          | Opfunction _ -> false
          | Opfunctioncall _ -> false
          | Opfunctionend -> false
          | Opfunctionparameter _ -> false
        let value =
          function
          | Opcooperativematrixperelementopnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.matrix;
                  Operand_kind.Payload.Idref.value t.func;
                  List.concat_map t.operands
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5369l in
              heading :: payload
          | Opfunction t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Functioncontrol.value
                    t.functioncontrol;
                  Operand_kind.Payload.Idref.value t.functiontype] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 54l in
              heading :: payload
          | Opfunctioncall t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.function_;
                  List.concat_map t.argument0argument1___
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 57l in
              heading :: payload
          | Opfunctionend ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 56l in
              [heading]
          | Opfunctionparameter t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 55l in
              heading :: payload
        let any_required_version =
          function
          | Opcooperativematrixperelementopnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunction _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunctioncall _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunctionend ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunctionparameter _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opcooperativematrixperelementopnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfunction _ -> [] |> Requirements.Extension.Set.of_list
          | Opfunctioncall _ -> [] |> Requirements.Extension.Set.of_list
          | Opfunctionend -> [] |> Requirements.Extension.Set.of_list
          | Opfunctionparameter _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opcooperativematrixperelementopnv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixperelementoperationsnv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunction _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunctioncall _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunctionend ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunctionparameter _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Graph =
      struct
        type t =
          | Opgrapharm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opgraphconstantarm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          graphconstantid: Operand_kind.Payload.Literalinteger.t } 
          | Opgraphendarm 
          | Opgraphentrypointarm of
          {
          graph: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t ;
          interface: Operand_kind.Payload.Idref.t list } 
          | Opgraphinputarm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          inputindex: Operand_kind.Payload.Idref.t ;
          elementindex: Operand_kind.Payload.Idref.t list } 
          | Opgraphsetoutputarm of
          {
          value: Operand_kind.Payload.Idref.t ;
          outputindex: Operand_kind.Payload.Idref.t ;
          elementindex: Operand_kind.Payload.Idref.t list } [@@deriving
                                                              compare, sexp_of]
        let provisional =
          function
          | Opgrapharm _ -> false
          | Opgraphconstantarm _ -> false
          | Opgraphendarm -> false
          | Opgraphentrypointarm _ -> false
          | Opgraphinputarm _ -> false
          | Opgraphsetoutputarm _ -> false
        let value =
          function
          | Opgrapharm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4183l in
              heading :: payload
          | Opgraphconstantarm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalinteger.value t.graphconstantid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4181l in
              heading :: payload
          | Opgraphendarm ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 4186l in
              [heading]
          | Opgraphentrypointarm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.graph;
                  Operand_kind.Payload.Literalstring.value t.name;
                  List.concat_map t.interface
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4182l in
              heading :: payload
          | Opgraphinputarm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.inputindex;
                  List.concat_map t.elementindex
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4184l in
              heading :: payload
          | Opgraphsetoutputarm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.outputindex;
                  List.concat_map t.elementindex
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4185l in
              heading :: payload
        let any_required_version =
          function
          | Opgrapharm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgraphconstantarm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgraphendarm ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgraphentrypointarm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgraphinputarm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgraphsetoutputarm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opgrapharm _ -> [] |> Requirements.Extension.Set.of_list
          | Opgraphconstantarm _ -> [] |> Requirements.Extension.Set.of_list
          | Opgraphendarm -> [] |> Requirements.Extension.Set.of_list
          | Opgraphentrypointarm _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgraphinputarm _ -> [] |> Requirements.Extension.Set.of_list
          | Opgraphsetoutputarm _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opgrapharm _ ->
              [Operand_kind.Payload.Capability.Grapharm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgraphconstantarm _ ->
              [Operand_kind.Payload.Capability.Grapharm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgraphendarm ->
              [Operand_kind.Payload.Capability.Grapharm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgraphentrypointarm _ ->
              [Operand_kind.Payload.Capability.Grapharm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgraphinputarm _ ->
              [Operand_kind.Payload.Capability.Grapharm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgraphsetoutputarm _ ->
              [Operand_kind.Payload.Capability.Grapharm] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Group =
      struct
        type t =
          | Opgroupall of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupany of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupasynccopy of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          destination: Operand_kind.Payload.Idref.t ;
          source: Operand_kind.Payload.Idref.t ;
          numelements: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t ;
          event: Operand_kind.Payload.Idref.t } 
          | Opgroupbitwiseandkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupbitwiseorkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupbitwisexorkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupbroadcast of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          localid: Operand_kind.Payload.Idref.t } 
          | Opgroupfadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfaddnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfmaxnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfminnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupfmulkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupiadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupiaddnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupimulkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgrouplogicalandkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgrouplogicalorkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgrouplogicalxorkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformrotatekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupsmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupsmaxnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupsmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupsminnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupumax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupumaxnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupumin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupuminnonuniformamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opgroupwaitevents of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          numevents: Operand_kind.Payload.Idref.t ;
          eventslist: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockloadintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dstpointer: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockloadtransformintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dstpointer: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockloadtransposeintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dstpointer: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockprefetchintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Opsubgroup2dblockstoreintel of
          {
          elementsize: Operand_kind.Payload.Idref.t ;
          blockwidth: Operand_kind.Payload.Idref.t ;
          blockheight: Operand_kind.Payload.Idref.t ;
          blockcount: Operand_kind.Payload.Idref.t ;
          srcpointer: Operand_kind.Payload.Idref.t ;
          dstbasepointer: Operand_kind.Payload.Idref.t ;
          memorywidth: Operand_kind.Payload.Idref.t ;
          memoryheight: Operand_kind.Payload.Idref.t ;
          memorypitch: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupallequalkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupallkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupanykhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupballotkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupblockprefetchintel of
          {
          ptr: Operand_kind.Payload.Idref.t ;
          numbytes: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opsubgroupblockreadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          ptr: Operand_kind.Payload.Idref.t } 
          | Opsubgroupblockwriteintel of
          {
          ptr: Operand_kind.Payload.Idref.t ;
          data: Operand_kind.Payload.Idref.t } 
          | Opsubgroupfirstinvocationkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opsubgroupimageblockreadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Opsubgroupimageblockwriteintel of
          {
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          data: Operand_kind.Payload.Idref.t } 
          | Opsubgroupimagemediablockreadintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          width: Operand_kind.Payload.Idref.t ;
          height: Operand_kind.Payload.Idref.t } 
          | Opsubgroupimagemediablockwriteintel of
          {
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          width: Operand_kind.Payload.Idref.t ;
          height: Operand_kind.Payload.Idref.t ;
          data: Operand_kind.Payload.Idref.t } 
          | Opsubgroupmatrixmultiplyaccumulateintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          kdim: Operand_kind.Payload.Idref.t ;
          matrixa: Operand_kind.Payload.Idref.t ;
          matrixb: Operand_kind.Payload.Idref.t ;
          matrixc: Operand_kind.Payload.Idref.t ;
          matrixmultiplyaccumulateoperands:
            Operand_kind.Payload.Matrixmultiplyaccumulateoperands.t option }
          
          | Opsubgroupreadinvocationkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opsubgroupshuffledownintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          current: Operand_kind.Payload.Idref.t ;
          next: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t } 
          | Opsubgroupshuffleintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          data: Operand_kind.Payload.Idref.t ;
          invocationid: Operand_kind.Payload.Idref.t } 
          | Opsubgroupshuffleupintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          previous: Operand_kind.Payload.Idref.t ;
          current: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t } 
          | Opsubgroupshufflexorintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          data: Operand_kind.Payload.Idref.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opuntypedgroupasynccopykhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idref.t ;
          destination: Operand_kind.Payload.Idref.t ;
          source: Operand_kind.Payload.Idref.t ;
          elementnumbytes: Operand_kind.Payload.Idref.t ;
          numelements: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t ;
          event: Operand_kind.Payload.Idref.t ;
          destinationmemoryoperands:
            Operand_kind.Payload.Memoryaccess.t option ;
          sourcememoryoperands: Operand_kind.Payload.Memoryaccess.t option } 
        [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opgroupall _ -> false
          | Opgroupany _ -> false
          | Opgroupasynccopy _ -> false
          | Opgroupbitwiseandkhr _ -> false
          | Opgroupbitwiseorkhr _ -> false
          | Opgroupbitwisexorkhr _ -> false
          | Opgroupbroadcast _ -> false
          | Opgroupfadd _ -> false
          | Opgroupfaddnonuniformamd _ -> false
          | Opgroupfmax _ -> false
          | Opgroupfmaxnonuniformamd _ -> false
          | Opgroupfmin _ -> false
          | Opgroupfminnonuniformamd _ -> false
          | Opgroupfmulkhr _ -> false
          | Opgroupiadd _ -> false
          | Opgroupiaddnonuniformamd _ -> false
          | Opgroupimulkhr _ -> false
          | Opgrouplogicalandkhr _ -> false
          | Opgrouplogicalorkhr _ -> false
          | Opgrouplogicalxorkhr _ -> false
          | Opgroupnonuniformrotatekhr _ -> false
          | Opgroupsmax _ -> false
          | Opgroupsmaxnonuniformamd _ -> false
          | Opgroupsmin _ -> false
          | Opgroupsminnonuniformamd _ -> false
          | Opgroupumax _ -> false
          | Opgroupumaxnonuniformamd _ -> false
          | Opgroupumin _ -> false
          | Opgroupuminnonuniformamd _ -> false
          | Opgroupwaitevents _ -> false
          | Opsubgroup2dblockloadintel _ -> false
          | Opsubgroup2dblockloadtransformintel _ -> false
          | Opsubgroup2dblockloadtransposeintel _ -> false
          | Opsubgroup2dblockprefetchintel _ -> false
          | Opsubgroup2dblockstoreintel _ -> false
          | Opsubgroupallequalkhr _ -> false
          | Opsubgroupallkhr _ -> false
          | Opsubgroupanykhr _ -> false
          | Opsubgroupballotkhr _ -> false
          | Opsubgroupblockprefetchintel _ -> false
          | Opsubgroupblockreadintel _ -> false
          | Opsubgroupblockwriteintel _ -> false
          | Opsubgroupfirstinvocationkhr _ -> false
          | Opsubgroupimageblockreadintel _ -> false
          | Opsubgroupimageblockwriteintel _ -> false
          | Opsubgroupimagemediablockreadintel _ -> false
          | Opsubgroupimagemediablockwriteintel _ -> false
          | Opsubgroupmatrixmultiplyaccumulateintel _ -> false
          | Opsubgroupreadinvocationkhr _ -> false
          | Opsubgroupshuffledownintel _ -> false
          | Opsubgroupshuffleintel _ -> false
          | Opsubgroupshuffleupintel _ -> false
          | Opsubgroupshufflexorintel _ -> false
          | Opuntypedgroupasynccopykhr _ -> false
        let value =
          function
          | Opgroupall t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 261l in
              heading :: payload
          | Opgroupany t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 262l in
              heading :: payload
          | Opgroupasynccopy t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.destination;
                  Operand_kind.Payload.Idref.value t.source;
                  Operand_kind.Payload.Idref.value t.numelements;
                  Operand_kind.Payload.Idref.value t.stride;
                  Operand_kind.Payload.Idref.value t.event] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 259l in
              heading :: payload
          | Opgroupbitwiseandkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6403l in
              heading :: payload
          | Opgroupbitwiseorkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6404l in
              heading :: payload
          | Opgroupbitwisexorkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6405l in
              heading :: payload
          | Opgroupbroadcast t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.localid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 263l in
              heading :: payload
          | Opgroupfadd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 265l in
              heading :: payload
          | Opgroupfaddnonuniformamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5001l in
              heading :: payload
          | Opgroupfmax t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 269l in
              heading :: payload
          | Opgroupfmaxnonuniformamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5005l in
              heading :: payload
          | Opgroupfmin t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 266l in
              heading :: payload
          | Opgroupfminnonuniformamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5002l in
              heading :: payload
          | Opgroupfmulkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6402l in
              heading :: payload
          | Opgroupiadd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 264l in
              heading :: payload
          | Opgroupiaddnonuniformamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5000l in
              heading :: payload
          | Opgroupimulkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6401l in
              heading :: payload
          | Opgrouplogicalandkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6406l in
              heading :: payload
          | Opgrouplogicalorkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6407l in
              heading :: payload
          | Opgrouplogicalxorkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6408l in
              heading :: payload
          | Opgroupnonuniformrotatekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.delta;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4431l in
              heading :: payload
          | Opgroupsmax t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 271l in
              heading :: payload
          | Opgroupsmaxnonuniformamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5007l in
              heading :: payload
          | Opgroupsmin t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 268l in
              heading :: payload
          | Opgroupsminnonuniformamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5004l in
              heading :: payload
          | Opgroupumax t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 270l in
              heading :: payload
          | Opgroupumaxnonuniformamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5006l in
              heading :: payload
          | Opgroupumin t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 267l in
              heading :: payload
          | Opgroupuminnonuniformamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5003l in
              heading :: payload
          | Opgroupwaitevents t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.numevents;
                  Operand_kind.Payload.Idref.value t.eventslist] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 260l in
              heading :: payload
          | Opsubgroup2dblockloadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.elementsize;
                  Operand_kind.Payload.Idref.value t.blockwidth;
                  Operand_kind.Payload.Idref.value t.blockheight;
                  Operand_kind.Payload.Idref.value t.blockcount;
                  Operand_kind.Payload.Idref.value t.srcbasepointer;
                  Operand_kind.Payload.Idref.value t.memorywidth;
                  Operand_kind.Payload.Idref.value t.memoryheight;
                  Operand_kind.Payload.Idref.value t.memorypitch;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dstpointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6231l in
              heading :: payload
          | Opsubgroup2dblockloadtransformintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.elementsize;
                  Operand_kind.Payload.Idref.value t.blockwidth;
                  Operand_kind.Payload.Idref.value t.blockheight;
                  Operand_kind.Payload.Idref.value t.blockcount;
                  Operand_kind.Payload.Idref.value t.srcbasepointer;
                  Operand_kind.Payload.Idref.value t.memorywidth;
                  Operand_kind.Payload.Idref.value t.memoryheight;
                  Operand_kind.Payload.Idref.value t.memorypitch;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dstpointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6232l in
              heading :: payload
          | Opsubgroup2dblockloadtransposeintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.elementsize;
                  Operand_kind.Payload.Idref.value t.blockwidth;
                  Operand_kind.Payload.Idref.value t.blockheight;
                  Operand_kind.Payload.Idref.value t.blockcount;
                  Operand_kind.Payload.Idref.value t.srcbasepointer;
                  Operand_kind.Payload.Idref.value t.memorywidth;
                  Operand_kind.Payload.Idref.value t.memoryheight;
                  Operand_kind.Payload.Idref.value t.memorypitch;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dstpointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6233l in
              heading :: payload
          | Opsubgroup2dblockprefetchintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.elementsize;
                  Operand_kind.Payload.Idref.value t.blockwidth;
                  Operand_kind.Payload.Idref.value t.blockheight;
                  Operand_kind.Payload.Idref.value t.blockcount;
                  Operand_kind.Payload.Idref.value t.srcbasepointer;
                  Operand_kind.Payload.Idref.value t.memorywidth;
                  Operand_kind.Payload.Idref.value t.memoryheight;
                  Operand_kind.Payload.Idref.value t.memorypitch;
                  Operand_kind.Payload.Idref.value t.coordinate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6234l in
              heading :: payload
          | Opsubgroup2dblockstoreintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.elementsize;
                  Operand_kind.Payload.Idref.value t.blockwidth;
                  Operand_kind.Payload.Idref.value t.blockheight;
                  Operand_kind.Payload.Idref.value t.blockcount;
                  Operand_kind.Payload.Idref.value t.srcpointer;
                  Operand_kind.Payload.Idref.value t.dstbasepointer;
                  Operand_kind.Payload.Idref.value t.memorywidth;
                  Operand_kind.Payload.Idref.value t.memoryheight;
                  Operand_kind.Payload.Idref.value t.memorypitch;
                  Operand_kind.Payload.Idref.value t.coordinate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6235l in
              heading :: payload
          | Opsubgroupallequalkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4430l in
              heading :: payload
          | Opsubgroupallkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4428l in
              heading :: payload
          | Opsubgroupanykhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4429l in
              heading :: payload
          | Opsubgroupballotkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4421l in
              heading :: payload
          | Opsubgroupblockprefetchintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.ptr;
                  Operand_kind.Payload.Idref.value t.numbytes;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6221l in
              heading :: payload
          | Opsubgroupblockreadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.ptr] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5575l in
              heading :: payload
          | Opsubgroupblockwriteintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.ptr;
                  Operand_kind.Payload.Idref.value t.data] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5576l in
              heading :: payload
          | Opsubgroupfirstinvocationkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4422l in
              heading :: payload
          | Opsubgroupimageblockreadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5577l in
              heading :: payload
          | Opsubgroupimageblockwriteintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.data] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5578l in
              heading :: payload
          | Opsubgroupimagemediablockreadintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.width;
                  Operand_kind.Payload.Idref.value t.height] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5580l in
              heading :: payload
          | Opsubgroupimagemediablockwriteintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.width;
                  Operand_kind.Payload.Idref.value t.height;
                  Operand_kind.Payload.Idref.value t.data] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5581l in
              heading :: payload
          | Opsubgroupmatrixmultiplyaccumulateintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.kdim;
                  Operand_kind.Payload.Idref.value t.matrixa;
                  Operand_kind.Payload.Idref.value t.matrixb;
                  Operand_kind.Payload.Idref.value t.matrixc;
                  (t.matrixmultiplyaccumulateoperands |>
                     (Option.map
                        ~f:Operand_kind.Payload.Matrixmultiplyaccumulateoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6237l in
              heading :: payload
          | Opsubgroupreadinvocationkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.index] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4432l in
              heading :: payload
          | Opsubgroupshuffledownintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.current;
                  Operand_kind.Payload.Idref.value t.next;
                  Operand_kind.Payload.Idref.value t.delta] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5572l in
              heading :: payload
          | Opsubgroupshuffleintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.data;
                  Operand_kind.Payload.Idref.value t.invocationid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5571l in
              heading :: payload
          | Opsubgroupshuffleupintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.previous;
                  Operand_kind.Payload.Idref.value t.current;
                  Operand_kind.Payload.Idref.value t.delta] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5573l in
              heading :: payload
          | Opsubgroupshufflexorintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.data;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5574l in
              heading :: payload
          | Opuntypedgroupasynccopykhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.execution;
                  Operand_kind.Payload.Idref.value t.destination;
                  Operand_kind.Payload.Idref.value t.source;
                  Operand_kind.Payload.Idref.value t.elementnumbytes;
                  Operand_kind.Payload.Idref.value t.numelements;
                  Operand_kind.Payload.Idref.value t.stride;
                  Operand_kind.Payload.Idref.value t.event;
                  (t.destinationmemoryoperands |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[]);
                  (t.sourcememoryoperands |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4434l in
              heading :: payload
        let any_required_version =
          function
          | Opgroupall _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupany _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupasynccopy _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupbitwiseandkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupbitwiseorkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupbitwisexorkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupbroadcast _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupfadd _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupfaddnonuniformamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupfmax _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupfmaxnonuniformamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupfmin _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupfminnonuniformamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupfmulkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupiadd _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupiaddnonuniformamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupimulkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgrouplogicalandkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgrouplogicalorkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgrouplogicalxorkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformrotatekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupsmax _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupsmaxnonuniformamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupsmin _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupsminnonuniformamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupumax _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupumaxnonuniformamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupumin _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupuminnonuniformamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupwaitevents _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroup2dblockloadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroup2dblockloadtransformintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroup2dblockloadtransposeintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroup2dblockprefetchintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroup2dblockstoreintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupallequalkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupallkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupanykhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupballotkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupblockprefetchintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupblockreadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupblockwriteintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupfirstinvocationkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupimageblockreadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupimageblockwriteintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupimagemediablockreadintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupimagemediablockwriteintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupmatrixmultiplyaccumulateintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupreadinvocationkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupshuffledownintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupshuffleintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupshuffleupintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsubgroupshufflexorintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedgroupasynccopykhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opgroupall _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupany _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupasynccopy _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupbitwiseandkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupbitwiseorkhr _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupbitwisexorkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupbroadcast _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupfadd _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupfaddnonuniformamd _ ->
              [Requirements.Extension.Spv_amd_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opgroupfmax _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupfmaxnonuniformamd _ ->
              [Requirements.Extension.Spv_amd_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opgroupfmin _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupfminnonuniformamd _ ->
              [Requirements.Extension.Spv_amd_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opgroupfmulkhr _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupiadd _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupiaddnonuniformamd _ ->
              [Requirements.Extension.Spv_amd_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opgroupimulkhr _ -> [] |> Requirements.Extension.Set.of_list
          | Opgrouplogicalandkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgrouplogicalorkhr _ -> [] |> Requirements.Extension.Set.of_list
          | Opgrouplogicalxorkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformrotatekhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupsmax _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupsmaxnonuniformamd _ ->
              [Requirements.Extension.Spv_amd_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opgroupsmin _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupsminnonuniformamd _ ->
              [Requirements.Extension.Spv_amd_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opgroupumax _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupumaxnonuniformamd _ ->
              [Requirements.Extension.Spv_amd_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opgroupumin _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupuminnonuniformamd _ ->
              [Requirements.Extension.Spv_amd_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opgroupwaitevents _ -> [] |> Requirements.Extension.Set.of_list
          | Opsubgroup2dblockloadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroup2dblockloadtransformintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroup2dblockloadtransposeintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroup2dblockprefetchintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroup2dblockstoreintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupallequalkhr _ ->
              [Requirements.Extension.Spv_khr_subgroup_vote] |>
                Requirements.Extension.Set.of_list
          | Opsubgroupallkhr _ ->
              [Requirements.Extension.Spv_khr_subgroup_vote] |>
                Requirements.Extension.Set.of_list
          | Opsubgroupanykhr _ ->
              [Requirements.Extension.Spv_khr_subgroup_vote] |>
                Requirements.Extension.Set.of_list
          | Opsubgroupballotkhr _ ->
              [Requirements.Extension.Spv_khr_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opsubgroupblockprefetchintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupblockreadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupblockwriteintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupfirstinvocationkhr _ ->
              [Requirements.Extension.Spv_khr_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opsubgroupimageblockreadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupimageblockwriteintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupimagemediablockreadintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupimagemediablockwriteintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupmatrixmultiplyaccumulateintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupreadinvocationkhr _ ->
              [Requirements.Extension.Spv_khr_shader_ballot] |>
                Requirements.Extension.Set.of_list
          | Opsubgroupshuffledownintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupshuffleintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupshuffleupintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsubgroupshufflexorintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuntypedgroupasynccopykhr _ ->
              [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opgroupall _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupany _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupasynccopy _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupbitwiseandkhr _ ->
              [Operand_kind.Payload.Capability.Groupuniformarithmetickhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupbitwiseorkhr _ ->
              [Operand_kind.Payload.Capability.Groupuniformarithmetickhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupbitwisexorkhr _ ->
              [Operand_kind.Payload.Capability.Groupuniformarithmetickhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupbroadcast _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupfadd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupfaddnonuniformamd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupfmax _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupfmaxnonuniformamd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupfmin _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupfminnonuniformamd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupfmulkhr _ ->
              [Operand_kind.Payload.Capability.Groupuniformarithmetickhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupiadd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupiaddnonuniformamd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupimulkhr _ ->
              [Operand_kind.Payload.Capability.Groupuniformarithmetickhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgrouplogicalandkhr _ ->
              [Operand_kind.Payload.Capability.Groupuniformarithmetickhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgrouplogicalorkhr _ ->
              [Operand_kind.Payload.Capability.Groupuniformarithmetickhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgrouplogicalxorkhr _ ->
              [Operand_kind.Payload.Capability.Groupuniformarithmetickhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformrotatekhr _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformrotatekhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupsmax _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupsmaxnonuniformamd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupsmin _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupsminnonuniformamd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupumax _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupumaxnonuniformamd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupumin _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupuminnonuniformamd _ ->
              [Operand_kind.Payload.Capability.Groups] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupwaitevents _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroup2dblockloadintel _ ->
              [Operand_kind.Payload.Capability.Subgroup2dblockiointel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroup2dblockloadtransformintel _ ->
              [Operand_kind.Payload.Capability.Subgroup2dblocktransformintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroup2dblockloadtransposeintel _ ->
              [Operand_kind.Payload.Capability.Subgroup2dblocktransposeintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroup2dblockprefetchintel _ ->
              [Operand_kind.Payload.Capability.Subgroup2dblockiointel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroup2dblockstoreintel _ ->
              [Operand_kind.Payload.Capability.Subgroup2dblockiointel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupallequalkhr _ ->
              [Operand_kind.Payload.Capability.Subgroupvotekhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupallkhr _ ->
              [Operand_kind.Payload.Capability.Subgroupvotekhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupanykhr _ ->
              [Operand_kind.Payload.Capability.Subgroupvotekhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupballotkhr _ ->
              [Operand_kind.Payload.Capability.Subgroupballotkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupblockprefetchintel _ ->
              [Operand_kind.Payload.Capability.Subgroupbufferprefetchintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupblockreadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupbufferblockiointel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupblockwriteintel _ ->
              [Operand_kind.Payload.Capability.Subgroupbufferblockiointel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupfirstinvocationkhr _ ->
              [Operand_kind.Payload.Capability.Subgroupballotkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupimageblockreadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupimageblockiointel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupimageblockwriteintel _ ->
              [Operand_kind.Payload.Capability.Subgroupimageblockiointel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupimagemediablockreadintel _ ->
              [Operand_kind.Payload.Capability.Subgroupimagemediablockiointel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupimagemediablockwriteintel _ ->
              [Operand_kind.Payload.Capability.Subgroupimagemediablockiointel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupmatrixmultiplyaccumulateintel _ ->
              [Operand_kind.Payload.Capability.Subgroupmatrixmultiplyaccumulateintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupreadinvocationkhr _ ->
              [Operand_kind.Payload.Capability.Subgroupballotkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupshuffledownintel _ ->
              [Operand_kind.Payload.Capability.Subgroupshuffleintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupshuffleintel _ ->
              [Operand_kind.Payload.Capability.Subgroupshuffleintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupshuffleupintel _ ->
              [Operand_kind.Payload.Capability.Subgroupshuffleintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsubgroupshufflexorintel _ ->
              [Operand_kind.Payload.Capability.Subgroupshuffleintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedgroupasynccopykhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Image =
      struct
        type t =
          | Opcolorattachmentreadext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          attachment: Operand_kind.Payload.Idref.t ;
          sample: Operand_kind.Payload.Idref.t option } 
          | Opconverthandletoimageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconverthandletosampledimageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconverthandletosamplerintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opdepthattachmentreadext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sample: Operand_kind.Payload.Idref.t option } 
          | Opimage of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchgathersadqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          targetsampledimage: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          referencesampledimage: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchgatherssdqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          targetsampledimage: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          referencesampledimage: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchsadqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          target: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          reference: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchssdqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          target: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          reference: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchwindowsadqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          targetsampledimage: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          referencesampledimage: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageblockmatchwindowssdqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          targetsampledimage: Operand_kind.Payload.Idref.t ;
          targetcoordinates: Operand_kind.Payload.Idref.t ;
          referencesampledimage: Operand_kind.Payload.Idref.t ;
          referencecoordinates: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t } 
          | Opimageboxfilterqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          texture: Operand_kind.Payload.Idref.t ;
          coordinates: Operand_kind.Payload.Idref.t ;
          boxsize: Operand_kind.Payload.Idref.t } 
          | Opimagedrefgather of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagefetch of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagegather of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          component: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagequeryformat of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerylevels of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerylod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Opimagequeryorder of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerysamples of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerysize of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t } 
          | Opimagequerysizelod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          levelofdetail: Operand_kind.Payload.Idref.t } 
          | Opimageread of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampledrefexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesampledrefimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesamplefootprintnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          granularity: Operand_kind.Payload.Idref.t ;
          coarse: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleprojdrefexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesampleprojdrefimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleprojexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesampleprojimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesampleweightedqcom of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          texture: Operand_kind.Payload.Idref.t ;
          coordinates: Operand_kind.Payload.Idref.t ;
          weights: Operand_kind.Payload.Idref.t } 
          | Opimagesparsedrefgather of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsefetch of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsegather of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          component: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparseread of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsesampledrefexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesparsesampledrefimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsesampleexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesparsesampleimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsesampleprojdrefexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesparsesampleprojdrefimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          dref: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsesampleprojexplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t } 
          | Opimagesparsesampleprojimplicitlod of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledimage: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opimagesparsetexelsresident of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          residentcode: Operand_kind.Payload.Idref.t } 
          | Opimagewrite of
          {
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          texel: Operand_kind.Payload.Idref.t ;
          imageoperands: Operand_kind.Payload.Imageoperands.t option } 
          | Opsampledimage of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          sampler: Operand_kind.Payload.Idref.t } 
          | Opstencilattachmentreadext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          sample: Operand_kind.Payload.Idref.t option } [@@deriving
                                                          compare, sexp_of]
        let provisional =
          function
          | Opcolorattachmentreadext _ -> false
          | Opconverthandletoimageintel _ -> true
          | Opconverthandletosampledimageintel _ -> true
          | Opconverthandletosamplerintel _ -> true
          | Opdepthattachmentreadext _ -> false
          | Opimage _ -> false
          | Opimageblockmatchgathersadqcom _ -> false
          | Opimageblockmatchgatherssdqcom _ -> false
          | Opimageblockmatchsadqcom _ -> false
          | Opimageblockmatchssdqcom _ -> false
          | Opimageblockmatchwindowsadqcom _ -> false
          | Opimageblockmatchwindowssdqcom _ -> false
          | Opimageboxfilterqcom _ -> false
          | Opimagedrefgather _ -> false
          | Opimagefetch _ -> false
          | Opimagegather _ -> false
          | Opimagequeryformat _ -> false
          | Opimagequerylevels _ -> false
          | Opimagequerylod _ -> false
          | Opimagequeryorder _ -> false
          | Opimagequerysamples _ -> false
          | Opimagequerysize _ -> false
          | Opimagequerysizelod _ -> false
          | Opimageread _ -> false
          | Opimagesampledrefexplicitlod _ -> false
          | Opimagesampledrefimplicitlod _ -> false
          | Opimagesampleexplicitlod _ -> false
          | Opimagesamplefootprintnv _ -> false
          | Opimagesampleimplicitlod _ -> false
          | Opimagesampleprojdrefexplicitlod _ -> false
          | Opimagesampleprojdrefimplicitlod _ -> false
          | Opimagesampleprojexplicitlod _ -> false
          | Opimagesampleprojimplicitlod _ -> false
          | Opimagesampleweightedqcom _ -> false
          | Opimagesparsedrefgather _ -> false
          | Opimagesparsefetch _ -> false
          | Opimagesparsegather _ -> false
          | Opimagesparseread _ -> false
          | Opimagesparsesampledrefexplicitlod _ -> false
          | Opimagesparsesampledrefimplicitlod _ -> false
          | Opimagesparsesampleexplicitlod _ -> false
          | Opimagesparsesampleimplicitlod _ -> false
          | Opimagesparsesampleprojdrefexplicitlod _ -> false
          | Opimagesparsesampleprojdrefimplicitlod _ -> false
          | Opimagesparsesampleprojexplicitlod _ -> false
          | Opimagesparsesampleprojimplicitlod _ -> false
          | Opimagesparsetexelsresident _ -> false
          | Opimagewrite _ -> false
          | Opsampledimage _ -> false
          | Opstencilattachmentreadext _ -> false
        let value =
          function
          | Opcolorattachmentreadext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.attachment;
                  (t.sample |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4160l in
              heading :: payload
          | Opconverthandletoimageintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6529l in
              heading :: payload
          | Opconverthandletosampledimageintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6531l in
              heading :: payload
          | Opconverthandletosamplerintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6530l in
              heading :: payload
          | Opdepthattachmentreadext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  (t.sample |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4161l in
              heading :: payload
          | Opimage t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 100l in
              heading :: payload
          | Opimageblockmatchgathersadqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.targetsampledimage;
                  Operand_kind.Payload.Idref.value t.targetcoordinates;
                  Operand_kind.Payload.Idref.value t.referencesampledimage;
                  Operand_kind.Payload.Idref.value t.referencecoordinates;
                  Operand_kind.Payload.Idref.value t.blocksize] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4503l in
              heading :: payload
          | Opimageblockmatchgatherssdqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.targetsampledimage;
                  Operand_kind.Payload.Idref.value t.targetcoordinates;
                  Operand_kind.Payload.Idref.value t.referencesampledimage;
                  Operand_kind.Payload.Idref.value t.referencecoordinates;
                  Operand_kind.Payload.Idref.value t.blocksize] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4502l in
              heading :: payload
          | Opimageblockmatchsadqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Idref.value t.targetcoordinates;
                  Operand_kind.Payload.Idref.value t.reference;
                  Operand_kind.Payload.Idref.value t.referencecoordinates;
                  Operand_kind.Payload.Idref.value t.blocksize] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4483l in
              heading :: payload
          | Opimageblockmatchssdqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Idref.value t.targetcoordinates;
                  Operand_kind.Payload.Idref.value t.reference;
                  Operand_kind.Payload.Idref.value t.referencecoordinates;
                  Operand_kind.Payload.Idref.value t.blocksize] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4482l in
              heading :: payload
          | Opimageblockmatchwindowsadqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.targetsampledimage;
                  Operand_kind.Payload.Idref.value t.targetcoordinates;
                  Operand_kind.Payload.Idref.value t.referencesampledimage;
                  Operand_kind.Payload.Idref.value t.referencecoordinates;
                  Operand_kind.Payload.Idref.value t.blocksize] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4501l in
              heading :: payload
          | Opimageblockmatchwindowssdqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.targetsampledimage;
                  Operand_kind.Payload.Idref.value t.targetcoordinates;
                  Operand_kind.Payload.Idref.value t.referencesampledimage;
                  Operand_kind.Payload.Idref.value t.referencecoordinates;
                  Operand_kind.Payload.Idref.value t.blocksize] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4500l in
              heading :: payload
          | Opimageboxfilterqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.texture;
                  Operand_kind.Payload.Idref.value t.coordinates;
                  Operand_kind.Payload.Idref.value t.boxsize] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4481l in
              heading :: payload
          | Opimagedrefgather t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 97l in
              heading :: payload
          | Opimagefetch t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 95l in
              heading :: payload
          | Opimagegather t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.component;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 96l in
              heading :: payload
          | Opimagequeryformat t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 101l in
              heading :: payload
          | Opimagequerylevels t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 106l in
              heading :: payload
          | Opimagequerylod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 105l in
              heading :: payload
          | Opimagequeryorder t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 102l in
              heading :: payload
          | Opimagequerysamples t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 107l in
              heading :: payload
          | Opimagequerysize t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 104l in
              heading :: payload
          | Opimagequerysizelod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.levelofdetail] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 103l in
              heading :: payload
          | Opimageread t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 98l in
              heading :: payload
          | Opimagesampledrefexplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  Operand_kind.Payload.Imageoperands.value t.imageoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 90l in
              heading :: payload
          | Opimagesampledrefimplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 89l in
              heading :: payload
          | Opimagesampleexplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Imageoperands.value t.imageoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 88l in
              heading :: payload
          | Opimagesamplefootprintnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.granularity;
                  Operand_kind.Payload.Idref.value t.coarse;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5283l in
              heading :: payload
          | Opimagesampleimplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 87l in
              heading :: payload
          | Opimagesampleprojdrefexplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  Operand_kind.Payload.Imageoperands.value t.imageoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 94l in
              heading :: payload
          | Opimagesampleprojdrefimplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 93l in
              heading :: payload
          | Opimagesampleprojexplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Imageoperands.value t.imageoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 92l in
              heading :: payload
          | Opimagesampleprojimplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 91l in
              heading :: payload
          | Opimagesampleweightedqcom t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.texture;
                  Operand_kind.Payload.Idref.value t.coordinates;
                  Operand_kind.Payload.Idref.value t.weights] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4480l in
              heading :: payload
          | Opimagesparsedrefgather t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 315l in
              heading :: payload
          | Opimagesparsefetch t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 313l in
              heading :: payload
          | Opimagesparsegather t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.component;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 314l in
              heading :: payload
          | Opimagesparseread t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 320l in
              heading :: payload
          | Opimagesparsesampledrefexplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  Operand_kind.Payload.Imageoperands.value t.imageoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 308l in
              heading :: payload
          | Opimagesparsesampledrefimplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 307l in
              heading :: payload
          | Opimagesparsesampleexplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Imageoperands.value t.imageoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 306l in
              heading :: payload
          | Opimagesparsesampleimplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 305l in
              heading :: payload
          | Opimagesparsesampleprojdrefexplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  Operand_kind.Payload.Imageoperands.value t.imageoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 312l in
              heading :: payload
          | Opimagesparsesampleprojdrefimplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.dref;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 311l in
              heading :: payload
          | Opimagesparsesampleprojexplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Imageoperands.value t.imageoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 310l in
              heading :: payload
          | Opimagesparsesampleprojimplicitlod t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledimage;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 309l in
              heading :: payload
          | Opimagesparsetexelsresident t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.residentcode] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 316l in
              heading :: payload
          | Opimagewrite t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.texel;
                  (t.imageoperands |>
                     (Option.map ~f:Operand_kind.Payload.Imageoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 99l in
              heading :: payload
          | Opsampledimage t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.sampler] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 86l in
              heading :: payload
          | Opstencilattachmentreadext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  (t.sample |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4162l in
              heading :: payload
        let any_required_version =
          function
          | Opcolorattachmentreadext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconverthandletoimageintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconverthandletosampledimageintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconverthandletosamplerintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opdepthattachmentreadext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimage _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimageblockmatchgathersadqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimageblockmatchgatherssdqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimageblockmatchsadqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimageblockmatchssdqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimageblockmatchwindowsadqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimageblockmatchwindowssdqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimageboxfilterqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagedrefgather _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagefetch _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagegather _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagequeryformat _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagequerylevels _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagequerylod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagequeryorder _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagequerysamples _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagequerysize _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagequerysizelod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimageread _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampledrefexplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampledrefimplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampleexplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesamplefootprintnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampleimplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampleprojdrefexplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampleprojdrefimplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampleprojexplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampleprojimplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesampleweightedqcom _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsedrefgather _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsefetch _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsegather _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparseread _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsesampledrefexplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsesampledrefimplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsesampleexplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsesampleimplicitlod _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsesampleprojdrefexplicitlod _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsesampleprojdrefimplicitlod _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsesampleprojexplicitlod _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsesampleprojimplicitlod _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagesparsetexelsresident _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagewrite _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsampledimage _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opstencilattachmentreadext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opcolorattachmentreadext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconverthandletoimageintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconverthandletosampledimageintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconverthandletosamplerintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opdepthattachmentreadext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimage _ -> [] |> Requirements.Extension.Set.of_list
          | Opimageblockmatchgathersadqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimageblockmatchgatherssdqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimageblockmatchsadqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimageblockmatchssdqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimageblockmatchwindowsadqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimageblockmatchwindowssdqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimageboxfilterqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagedrefgather _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagefetch _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagegather _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagequeryformat _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagequerylevels _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagequerylod _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagequeryorder _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagequerysamples _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagequerysize _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagequerysizelod _ -> [] |> Requirements.Extension.Set.of_list
          | Opimageread _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagesampledrefexplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesampledrefimplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesampleexplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesamplefootprintnv _ ->
              [Requirements.Extension.Spv_nv_shader_image_footprint] |>
                Requirements.Extension.Set.of_list
          | Opimagesampleimplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesampleprojdrefexplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesampleprojdrefimplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesampleprojexplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesampleprojimplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesampleweightedqcom _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsedrefgather _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsefetch _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagesparsegather _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagesparseread _ -> [] |> Requirements.Extension.Set.of_list
          | Opimagesparsesampledrefexplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsesampledrefimplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsesampleexplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsesampleimplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsesampleprojdrefexplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsesampleprojdrefimplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsesampleprojexplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsesampleprojimplicitlod _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagesparsetexelsresident _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagewrite _ -> [] |> Requirements.Extension.Set.of_list
          | Opsampledimage _ -> [] |> Requirements.Extension.Set.of_list
          | Opstencilattachmentreadext _ ->
              [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opcolorattachmentreadext _ ->
              [Operand_kind.Payload.Capability.Tileimagecolorreadaccessext]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opconverthandletoimageintel _ ->
              [Operand_kind.Payload.Capability.Bindlessimagesintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconverthandletosampledimageintel _ ->
              [Operand_kind.Payload.Capability.Bindlessimagesintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconverthandletosamplerintel _ ->
              [Operand_kind.Payload.Capability.Bindlessimagesintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opdepthattachmentreadext _ ->
              [Operand_kind.Payload.Capability.Tileimagedepthreadaccessext]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opimage _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opimageblockmatchgathersadqcom _ ->
              [Operand_kind.Payload.Capability.Textureblockmatch2qcom] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimageblockmatchgatherssdqcom _ ->
              [Operand_kind.Payload.Capability.Textureblockmatch2qcom] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimageblockmatchsadqcom _ ->
              [Operand_kind.Payload.Capability.Textureblockmatchqcom] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimageblockmatchssdqcom _ ->
              [Operand_kind.Payload.Capability.Textureblockmatchqcom] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimageblockmatchwindowsadqcom _ ->
              [Operand_kind.Payload.Capability.Textureblockmatch2qcom] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimageblockmatchwindowssdqcom _ ->
              [Operand_kind.Payload.Capability.Textureblockmatch2qcom] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimageboxfilterqcom _ ->
              [Operand_kind.Payload.Capability.Textureboxfilterqcom] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagedrefgather _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagefetch _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opimagegather _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagequeryformat _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagequerylevels _ ->
              [Operand_kind.Payload.Capability.Kernel;
              Operand_kind.Payload.Capability.Imagequery] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagequerylod _ ->
              [Operand_kind.Payload.Capability.Imagequery] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagequeryorder _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagequerysamples _ ->
              [Operand_kind.Payload.Capability.Kernel;
              Operand_kind.Payload.Capability.Imagequery] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagequerysize _ ->
              [Operand_kind.Payload.Capability.Kernel;
              Operand_kind.Payload.Capability.Imagequery] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagequerysizelod _ ->
              [Operand_kind.Payload.Capability.Kernel;
              Operand_kind.Payload.Capability.Imagequery] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimageread _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampledrefexplicitlod _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampledrefimplicitlod _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampleexplicitlod _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opimagesamplefootprintnv _ ->
              [Operand_kind.Payload.Capability.Imagefootprintnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampleimplicitlod _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampleprojdrefexplicitlod _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampleprojdrefimplicitlod _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampleprojexplicitlod _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampleprojimplicitlod _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesampleweightedqcom _ ->
              [Operand_kind.Payload.Capability.Texturesampleweightedqcom] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsedrefgather _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsefetch _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsegather _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparseread _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsesampledrefexplicitlod _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsesampledrefimplicitlod _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsesampleexplicitlod _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsesampleimplicitlod _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsesampleprojdrefexplicitlod _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsesampleprojdrefimplicitlod _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsesampleprojexplicitlod _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsesampleprojimplicitlod _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagesparsetexelsresident _ ->
              [Operand_kind.Payload.Capability.Sparseresidency] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagewrite _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsampledimage _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opstencilattachmentreadext _ ->
              [Operand_kind.Payload.Capability.Tileimagestencilreadaccessext]
                |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Memory =
      struct
        type t =
          | Opaccesschain of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Oparraylength of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          structure: Operand_kind.Payload.Idref.t ;
          arraymember: Operand_kind.Payload.Literalinteger.t } 
          | Opcooperativematrixloadkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t option ;
          memoryoperand: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativematrixloadtensornv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          memoryoperand: Operand_kind.Payload.Memoryaccess.t ;
          tensoraddressingoperands:
            Operand_kind.Payload.Tensoraddressingoperands.t }
          
          | Opcooperativematrixstorekhr of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t option ;
          memoryoperand: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativematrixstoretensornv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          memoryoperand: Operand_kind.Payload.Memoryaccess.t ;
          tensoraddressingoperands:
            Operand_kind.Payload.Tensoraddressingoperands.t }
          
          | Opcooperativevectorloadnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativevectorstorenv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcopymemory of
          {
          target: Operand_kind.Payload.Idref.t ;
          source: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option ;
          memoryaccess2: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcopymemorysized of
          {
          target: Operand_kind.Payload.Idref.t ;
          source: Operand_kind.Payload.Idref.t ;
          size: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option ;
          memoryaccess2: Operand_kind.Payload.Memoryaccess.t option } 
          | Opgenericptrmemsemantics of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opimagetexelpointer of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          sample: Operand_kind.Payload.Idref.t } 
          | Opinboundsaccesschain of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opinboundsptraccesschain of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          element: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opload of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opmaskedgatherintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          ptrvector: Operand_kind.Payload.Idref.t ;
          alignment: Operand_kind.Payload.Literalinteger.t ;
          mask: Operand_kind.Payload.Idref.t ;
          fillempty: Operand_kind.Payload.Idref.t } 
          | Opmaskedscatterintel of
          {
          inputvector: Operand_kind.Payload.Idref.t ;
          ptrvector: Operand_kind.Payload.Idref.t ;
          alignment: Operand_kind.Payload.Literalinteger.t ;
          mask: Operand_kind.Payload.Idref.t } 
          | Opptraccesschain of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          element: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opptrdiff of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opptrequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opptrnotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oprawaccesschainnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          base: Operand_kind.Payload.Idref.t ;
          bytestride: Operand_kind.Payload.Idref.t ;
          elementindex: Operand_kind.Payload.Idref.t ;
          byteoffset: Operand_kind.Payload.Idref.t ;
          rawaccesschainoperands:
            Operand_kind.Payload.Rawaccesschainoperands.t option }
          
          | Oprestorememoryintel of {
          ptr: Operand_kind.Payload.Idref.t } 
          | Opsavememoryintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opstore of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opuntypedaccesschainkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          basetype: Operand_kind.Payload.Idref.t ;
          base: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opuntypedarraylengthkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          structure: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          arraymember: Operand_kind.Payload.Literalinteger.t } 
          | Opuntypedinboundsaccesschainkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          basetype: Operand_kind.Payload.Idref.t ;
          base: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opuntypedinboundsptraccesschainkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          basetype: Operand_kind.Payload.Idref.t ;
          base: Operand_kind.Payload.Idref.t ;
          element: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opuntypedprefetchkhr of
          {
          pointertype: Operand_kind.Payload.Idref.t ;
          numbytes: Operand_kind.Payload.Idref.t ;
          rw: Operand_kind.Payload.Idref.t option ;
          locality: Operand_kind.Payload.Idref.t option ;
          cachetype: Operand_kind.Payload.Idref.t option } 
          | Opuntypedptraccesschainkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          basetype: Operand_kind.Payload.Idref.t ;
          base: Operand_kind.Payload.Idref.t ;
          element: Operand_kind.Payload.Idref.t ;
          indexes: Operand_kind.Payload.Idref.t list } 
          | Opuntypedvariablekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          storageclass: Operand_kind.Payload.Storageclass.t ;
          datatype: Operand_kind.Payload.Idref.t option ;
          initializer_: Operand_kind.Payload.Idref.t option } 
          | Opuntypedvariablelengtharrayintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          elementtype: Operand_kind.Payload.Idref.t ;
          length: Operand_kind.Payload.Idref.t } 
          | Opvariable of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          storageclass: Operand_kind.Payload.Storageclass.t ;
          initializer_: Operand_kind.Payload.Idref.t option } 
          | Opvariablelengtharrayintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          length: Operand_kind.Payload.Idref.t } [@@deriving
                                                   compare, sexp_of]
        let provisional =
          function
          | Opaccesschain _ -> false
          | Oparraylength _ -> false
          | Opcooperativematrixloadkhr _ -> false
          | Opcooperativematrixloadtensornv _ -> false
          | Opcooperativematrixstorekhr _ -> false
          | Opcooperativematrixstoretensornv _ -> false
          | Opcooperativevectorloadnv _ -> false
          | Opcooperativevectorstorenv _ -> false
          | Opcopymemory _ -> false
          | Opcopymemorysized _ -> false
          | Opgenericptrmemsemantics _ -> false
          | Opimagetexelpointer _ -> false
          | Opinboundsaccesschain _ -> false
          | Opinboundsptraccesschain _ -> false
          | Opload _ -> false
          | Opmaskedgatherintel _ -> false
          | Opmaskedscatterintel _ -> false
          | Opptraccesschain _ -> false
          | Opptrdiff _ -> false
          | Opptrequal _ -> false
          | Opptrnotequal _ -> false
          | Oprawaccesschainnv _ -> false
          | Oprestorememoryintel _ -> false
          | Opsavememoryintel _ -> false
          | Opstore _ -> false
          | Opuntypedaccesschainkhr _ -> false
          | Opuntypedarraylengthkhr _ -> false
          | Opuntypedinboundsaccesschainkhr _ -> false
          | Opuntypedinboundsptraccesschainkhr _ -> false
          | Opuntypedprefetchkhr _ -> false
          | Opuntypedptraccesschainkhr _ -> false
          | Opuntypedvariablekhr _ -> false
          | Opuntypedvariablelengtharrayintel _ -> false
          | Opvariable _ -> false
          | Opvariablelengtharrayintel _ -> false
        let value =
          function
          | Opaccesschain t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 65l in
              heading :: payload
          | Oparraylength t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.structure;
                  Operand_kind.Payload.Literalinteger.value t.arraymember] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 68l in
              heading :: payload
          | Opcooperativematrixloadkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.memorylayout;
                  (t.stride |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.memoryoperand |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4457l in
              heading :: payload
          | Opcooperativematrixloadtensornv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.object_;
                  Operand_kind.Payload.Idref.value t.tensorlayout;
                  Operand_kind.Payload.Memoryaccess.value t.memoryoperand;
                  Operand_kind.Payload.Tensoraddressingoperands.value
                    t.tensoraddressingoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5367l in
              heading :: payload
          | Opcooperativematrixstorekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.object_;
                  Operand_kind.Payload.Idref.value t.memorylayout;
                  (t.stride |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.memoryoperand |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4458l in
              heading :: payload
          | Opcooperativematrixstoretensornv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.object_;
                  Operand_kind.Payload.Idref.value t.tensorlayout;
                  Operand_kind.Payload.Memoryaccess.value t.memoryoperand;
                  Operand_kind.Payload.Tensoraddressingoperands.value
                    t.tensoraddressingoperands] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5368l in
              heading :: payload
          | Opcooperativevectorloadnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.offset;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5302l in
              heading :: payload
          | Opcooperativevectorstorenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.offset;
                  Operand_kind.Payload.Idref.value t.object_;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5303l in
              heading :: payload
          | Opcopymemory t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Idref.value t.source;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[]);
                  (t.memoryaccess2 |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 63l in
              heading :: payload
          | Opcopymemorysized t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.target;
                  Operand_kind.Payload.Idref.value t.source;
                  Operand_kind.Payload.Idref.value t.size;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[]);
                  (t.memoryaccess2 |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 64l in
              heading :: payload
          | Opgenericptrmemsemantics t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 69l in
              heading :: payload
          | Opimagetexelpointer t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.sample] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 60l in
              heading :: payload
          | Opinboundsaccesschain t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 66l in
              heading :: payload
          | Opinboundsptraccesschain t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.element;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 70l in
              heading :: payload
          | Opload t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 61l in
              heading :: payload
          | Opmaskedgatherintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.ptrvector;
                  Operand_kind.Payload.Literalinteger.value t.alignment;
                  Operand_kind.Payload.Idref.value t.mask;
                  Operand_kind.Payload.Idref.value t.fillempty] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6428l in
              heading :: payload
          | Opmaskedscatterintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.inputvector;
                  Operand_kind.Payload.Idref.value t.ptrvector;
                  Operand_kind.Payload.Literalinteger.value t.alignment;
                  Operand_kind.Payload.Idref.value t.mask] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6429l in
              heading :: payload
          | Opptraccesschain t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.element;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 67l in
              heading :: payload
          | Opptrdiff t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 403l in
              heading :: payload
          | Opptrequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 401l in
              heading :: payload
          | Opptrnotequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 402l in
              heading :: payload
          | Oprawaccesschainnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.bytestride;
                  Operand_kind.Payload.Idref.value t.elementindex;
                  Operand_kind.Payload.Idref.value t.byteoffset;
                  (t.rawaccesschainoperands |>
                     (Option.map
                        ~f:Operand_kind.Payload.Rawaccesschainoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5398l in
              heading :: payload
          | Oprestorememoryintel t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.ptr] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5820l in
              heading :: payload
          | Opsavememoryintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5819l in
              heading :: payload
          | Opstore t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.object_;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 62l in
              heading :: payload
          | Opuntypedaccesschainkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.basetype;
                  Operand_kind.Payload.Idref.value t.base;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4419l in
              heading :: payload
          | Opuntypedarraylengthkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.structure;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Literalinteger.value t.arraymember] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4425l in
              heading :: payload
          | Opuntypedinboundsaccesschainkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.basetype;
                  Operand_kind.Payload.Idref.value t.base;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4420l in
              heading :: payload
          | Opuntypedinboundsptraccesschainkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.basetype;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.element;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4424l in
              heading :: payload
          | Opuntypedprefetchkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointertype;
                  Operand_kind.Payload.Idref.value t.numbytes;
                  (t.rw |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.locality |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.cachetype |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4426l in
              heading :: payload
          | Opuntypedptraccesschainkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.basetype;
                  Operand_kind.Payload.Idref.value t.base;
                  Operand_kind.Payload.Idref.value t.element;
                  List.concat_map t.indexes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4423l in
              heading :: payload
          | Opuntypedvariablekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Storageclass.value t.storageclass;
                  (t.datatype |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.initializer_ |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4418l in
              heading :: payload
          | Opuntypedvariablelengtharrayintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.elementtype;
                  Operand_kind.Payload.Idref.value t.length] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6244l in
              heading :: payload
          | Opvariable t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Storageclass.value t.storageclass;
                  (t.initializer_ |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 59l in
              heading :: payload
          | Opvariablelengtharrayintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.length] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5818l in
              heading :: payload
        let any_required_version =
          function
          | Opaccesschain _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oparraylength _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixloadkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixloadtensornv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixstorekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixstoretensornv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativevectorloadnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativevectorstorenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcopymemory _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcopymemorysized _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgenericptrmemsemantics _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimagetexelpointer _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opinboundsaccesschain _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opinboundsptraccesschain _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opload _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmaskedgatherintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmaskedscatterintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opptraccesschain _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opptrdiff _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_4)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opptrequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_4)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opptrnotequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_4)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprawaccesschainnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprestorememoryintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsavememoryintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opstore _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedaccesschainkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedarraylengthkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedinboundsaccesschainkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedinboundsptraccesschainkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedprefetchkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedptraccesschainkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedvariablekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuntypedvariablelengtharrayintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opvariable _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opvariablelengtharrayintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opaccesschain _ -> [] |> Requirements.Extension.Set.of_list
          | Oparraylength _ -> [] |> Requirements.Extension.Set.of_list
          | Opcooperativematrixloadkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativematrixloadtensornv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativematrixstorekhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativematrixstoretensornv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativevectorloadnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativevectorstorenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcopymemory _ -> [] |> Requirements.Extension.Set.of_list
          | Opcopymemorysized _ -> [] |> Requirements.Extension.Set.of_list
          | Opgenericptrmemsemantics _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opimagetexelpointer _ -> [] |> Requirements.Extension.Set.of_list
          | Opinboundsaccesschain _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opinboundsptraccesschain _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opload _ -> [] |> Requirements.Extension.Set.of_list
          | Opmaskedgatherintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opmaskedscatterintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opptraccesschain _ -> [] |> Requirements.Extension.Set.of_list
          | Opptrdiff _ -> [] |> Requirements.Extension.Set.of_list
          | Opptrequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opptrnotequal _ -> [] |> Requirements.Extension.Set.of_list
          | Oprawaccesschainnv _ -> [] |> Requirements.Extension.Set.of_list
          | Oprestorememoryintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsavememoryintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opstore _ -> [] |> Requirements.Extension.Set.of_list
          | Opuntypedaccesschainkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuntypedarraylengthkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuntypedinboundsaccesschainkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuntypedinboundsptraccesschainkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuntypedprefetchkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuntypedptraccesschainkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuntypedvariablekhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuntypedvariablelengtharrayintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opvariable _ -> [] |> Requirements.Extension.Set.of_list
          | Opvariablelengtharrayintel _ ->
              [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opaccesschain _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Oparraylength _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixloadkhr _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixloadtensornv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixtensoraddressingnv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixstorekhr _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixstoretensornv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixtensoraddressingnv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativevectorloadnv _ ->
              [Operand_kind.Payload.Capability.Cooperativevectornv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativevectorstorenv _ ->
              [Operand_kind.Payload.Capability.Cooperativevectornv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcopymemory _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opcopymemorysized _ ->
              [Operand_kind.Payload.Capability.Addresses;
              Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgenericptrmemsemantics _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimagetexelpointer _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opinboundsaccesschain _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opinboundsptraccesschain _ ->
              [Operand_kind.Payload.Capability.Addresses] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opload _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opmaskedgatherintel _ ->
              [Operand_kind.Payload.Capability.Maskedgatherscatterintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opmaskedscatterintel _ ->
              [Operand_kind.Payload.Capability.Maskedgatherscatterintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opptraccesschain _ ->
              [Operand_kind.Payload.Capability.Addresses;
              Operand_kind.Payload.Capability.Variablepointers;
              Operand_kind.Payload.Capability.Variablepointersstoragebuffer;
              Operand_kind.Payload.Capability.Physicalstoragebufferaddresses]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opptrdiff _ ->
              [Operand_kind.Payload.Capability.Addresses;
              Operand_kind.Payload.Capability.Variablepointers;
              Operand_kind.Payload.Capability.Variablepointersstoragebuffer]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opptrequal _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opptrnotequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Oprawaccesschainnv _ ->
              [Operand_kind.Payload.Capability.Rawaccesschainsnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprestorememoryintel _ ->
              [Operand_kind.Payload.Capability.Variablelengtharrayintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsavememoryintel _ ->
              [Operand_kind.Payload.Capability.Variablelengtharrayintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opstore _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedaccesschainkhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedarraylengthkhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedinboundsaccesschainkhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedinboundsptraccesschainkhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedprefetchkhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedptraccesschainkhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedvariablekhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuntypedvariablelengtharrayintel _ ->
              [Operand_kind.Payload.Capability.Untypedvariablelengtharrayintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opvariable _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opvariablelengtharrayintel _ ->
              [Operand_kind.Payload.Capability.Variablelengtharrayintel] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Miscellaneous =
      struct
        type t =
          | Oparithmeticfenceext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          target: Operand_kind.Payload.Idref.t } 
          | Opassumetruekhr of {
          condition: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixlengthkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          type_: Operand_kind.Payload.Idref.t } 
          | Opexpectkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t ;
          expectedvalue: Operand_kind.Payload.Idref.t } 
          | Opnop 
          | Opsizeof of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t } 
          | Opundef of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } [@@deriving
                                                        compare, sexp_of]
        let provisional =
          function
          | Oparithmeticfenceext _ -> false
          | Opassumetruekhr _ -> false
          | Opcooperativematrixlengthkhr _ -> false
          | Opexpectkhr _ -> false
          | Opnop -> false
          | Opsizeof _ -> false
          | Opundef _ -> false
        let value =
          function
          | Oparithmeticfenceext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.target] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6145l in
              heading :: payload
          | Opassumetruekhr t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.condition] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5630l in
              heading :: payload
          | Opcooperativematrixlengthkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.type_] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4460l in
              heading :: payload
          | Opexpectkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.expectedvalue] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5631l in
              heading :: payload
          | Opnop ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 0l in
              [heading]
          | Opsizeof t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 321l in
              heading :: payload
          | Opundef t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 1l in
              heading :: payload
        let any_required_version =
          function
          | Oparithmeticfenceext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opassumetruekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixlengthkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opexpectkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opnop ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsizeof _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opundef _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Oparithmeticfenceext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opassumetruekhr _ ->
              [Requirements.Extension.Spv_khr_expect_assume] |>
                Requirements.Extension.Set.of_list
          | Opcooperativematrixlengthkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opexpectkhr _ ->
              [Requirements.Extension.Spv_khr_expect_assume] |>
                Requirements.Extension.Set.of_list
          | Opnop -> [] |> Requirements.Extension.Set.of_list
          | Opsizeof _ -> [] |> Requirements.Extension.Set.of_list
          | Opundef _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Oparithmeticfenceext _ ->
              [Operand_kind.Payload.Capability.Arithmeticfenceext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opassumetruekhr _ ->
              [Operand_kind.Payload.Capability.Expectassumekhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixlengthkhr _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opexpectkhr _ ->
              [Operand_kind.Payload.Capability.Expectassumekhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opnop -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsizeof _ ->
              [Operand_kind.Payload.Capability.Addresses] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opundef _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Mode_setting =
      struct
        type t =
          | Opcapability of {
          capability: Operand_kind.Payload.Capability.t } 
          | Opconditionalcapabilityintel of
          {
          condition: Operand_kind.Payload.Idref.t ;
          capability: Operand_kind.Payload.Capability.t } 
          | Opconditionalentrypointintel of
          {
          condition: Operand_kind.Payload.Idref.t ;
          executionmodel: Operand_kind.Payload.Executionmodel.t ;
          entrypoint: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t ;
          interface: Operand_kind.Payload.Idref.t list } 
          | Opentrypoint of
          {
          executionmodel: Operand_kind.Payload.Executionmodel.t ;
          entrypoint: Operand_kind.Payload.Idref.t ;
          name: Operand_kind.Payload.Literalstring.t ;
          interface: Operand_kind.Payload.Idref.t list } 
          | Opexecutionmode of
          {
          entrypoint: Operand_kind.Payload.Idref.t ;
          mode: Operand_kind.Payload.Executionmode.t } 
          | Opexecutionmodeid of
          {
          entrypoint: Operand_kind.Payload.Idref.t ;
          mode: Operand_kind.Payload.Executionmode.t } 
          | Opmemorymodel of
          {
          addressingmodel: Operand_kind.Payload.Addressingmodel.t ;
          memorymodel: Operand_kind.Payload.Memorymodel.t } [@@deriving
                                                              compare, sexp_of]
        let provisional =
          function
          | Opcapability _ -> false
          | Opconditionalcapabilityintel _ -> true
          | Opconditionalentrypointintel _ -> true
          | Opentrypoint _ -> false
          | Opexecutionmode _ -> false
          | Opexecutionmodeid _ -> false
          | Opmemorymodel _ -> false
        let value =
          function
          | Opcapability t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Capability.value t.capability] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 17l in
              heading :: payload
          | Opconditionalcapabilityintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.condition;
                  Operand_kind.Payload.Capability.value t.capability] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6250l in
              heading :: payload
          | Opconditionalentrypointintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.condition;
                  Operand_kind.Payload.Executionmodel.value t.executionmodel;
                  Operand_kind.Payload.Idref.value t.entrypoint;
                  Operand_kind.Payload.Literalstring.value t.name;
                  List.concat_map t.interface
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6249l in
              heading :: payload
          | Opentrypoint t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Executionmodel.value t.executionmodel;
                  Operand_kind.Payload.Idref.value t.entrypoint;
                  Operand_kind.Payload.Literalstring.value t.name;
                  List.concat_map t.interface
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 15l in
              heading :: payload
          | Opexecutionmode t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.entrypoint;
                  Operand_kind.Payload.Executionmode.value t.mode] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 16l in
              heading :: payload
          | Opexecutionmodeid t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.entrypoint;
                  Operand_kind.Payload.Executionmode.value t.mode] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 331l in
              heading :: payload
          | Opmemorymodel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Addressingmodel.value
                     t.addressingmodel;
                  Operand_kind.Payload.Memorymodel.value t.memorymodel] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 14l in
              heading :: payload
        let any_required_version =
          function
          | Opcapability _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconditionalcapabilityintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconditionalentrypointintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opentrypoint _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opexecutionmode _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opexecutionmodeid _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_2)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opmemorymodel _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opcapability _ -> [] |> Requirements.Extension.Set.of_list
          | Opconditionalcapabilityintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconditionalentrypointintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opentrypoint _ -> [] |> Requirements.Extension.Set.of_list
          | Opexecutionmode _ -> [] |> Requirements.Extension.Set.of_list
          | Opexecutionmodeid _ -> [] |> Requirements.Extension.Set.of_list
          | Opmemorymodel _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opcapability _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opconditionalcapabilityintel _ ->
              [Operand_kind.Payload.Capability.Specconditionalintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconditionalentrypointintel _ ->
              [Operand_kind.Payload.Capability.Specconditionalintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opentrypoint _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opexecutionmode _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opexecutionmodeid _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opmemorymodel _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Non_uniform =
      struct
        type t =
          | Opgroupnonuniformall of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformallequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformany of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballotbitcount of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballotbitextract of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballotfindlsb of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformballotfindmsb of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformbitwiseand of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformbitwiseor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformbitwisexor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformbroadcast of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          invocationid: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformbroadcastfirst of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformelect of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t } 
          | Opgroupnonuniformfadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformfmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformfmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformfmul of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformiadd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformimul of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniforminverseballot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformlogicaland of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformlogicalor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformlogicalxor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformpartitionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformquadallkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformquadanykhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          predicate: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformquadbroadcast of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformquadswap of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformshuffle of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          invocationid: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformshuffledown of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformshuffleup of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          delta: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformshufflexor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          value: Operand_kind.Payload.Idref.t ;
          mask: Operand_kind.Payload.Idref.t } 
          | Opgroupnonuniformsmax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformsmin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformumax of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } 
          | Opgroupnonuniformumin of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          operation: Operand_kind.Payload.Groupoperation.t ;
          value: Operand_kind.Payload.Idref.t ;
          clustersize: Operand_kind.Payload.Idref.t option } [@@deriving
                                                               compare, sexp_of]
        let provisional =
          function
          | Opgroupnonuniformall _ -> false
          | Opgroupnonuniformallequal _ -> false
          | Opgroupnonuniformany _ -> false
          | Opgroupnonuniformballot _ -> false
          | Opgroupnonuniformballotbitcount _ -> false
          | Opgroupnonuniformballotbitextract _ -> false
          | Opgroupnonuniformballotfindlsb _ -> false
          | Opgroupnonuniformballotfindmsb _ -> false
          | Opgroupnonuniformbitwiseand _ -> false
          | Opgroupnonuniformbitwiseor _ -> false
          | Opgroupnonuniformbitwisexor _ -> false
          | Opgroupnonuniformbroadcast _ -> false
          | Opgroupnonuniformbroadcastfirst _ -> false
          | Opgroupnonuniformelect _ -> false
          | Opgroupnonuniformfadd _ -> false
          | Opgroupnonuniformfmax _ -> false
          | Opgroupnonuniformfmin _ -> false
          | Opgroupnonuniformfmul _ -> false
          | Opgroupnonuniformiadd _ -> false
          | Opgroupnonuniformimul _ -> false
          | Opgroupnonuniforminverseballot _ -> false
          | Opgroupnonuniformlogicaland _ -> false
          | Opgroupnonuniformlogicalor _ -> false
          | Opgroupnonuniformlogicalxor _ -> false
          | Opgroupnonuniformpartitionnv _ -> false
          | Opgroupnonuniformquadallkhr _ -> false
          | Opgroupnonuniformquadanykhr _ -> false
          | Opgroupnonuniformquadbroadcast _ -> false
          | Opgroupnonuniformquadswap _ -> false
          | Opgroupnonuniformshuffle _ -> false
          | Opgroupnonuniformshuffledown _ -> false
          | Opgroupnonuniformshuffleup _ -> false
          | Opgroupnonuniformshufflexor _ -> false
          | Opgroupnonuniformsmax _ -> false
          | Opgroupnonuniformsmin _ -> false
          | Opgroupnonuniformumax _ -> false
          | Opgroupnonuniformumin _ -> false
        let value =
          function
          | Opgroupnonuniformall t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 334l in
              heading :: payload
          | Opgroupnonuniformallequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 336l in
              heading :: payload
          | Opgroupnonuniformany t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 335l in
              heading :: payload
          | Opgroupnonuniformballot t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 339l in
              heading :: payload
          | Opgroupnonuniformballotbitcount t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 342l in
              heading :: payload
          | Opgroupnonuniformballotbitextract t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.index] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 341l in
              heading :: payload
          | Opgroupnonuniformballotfindlsb t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 343l in
              heading :: payload
          | Opgroupnonuniformballotfindmsb t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 344l in
              heading :: payload
          | Opgroupnonuniformbitwiseand t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 359l in
              heading :: payload
          | Opgroupnonuniformbitwiseor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 360l in
              heading :: payload
          | Opgroupnonuniformbitwisexor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 361l in
              heading :: payload
          | Opgroupnonuniformbroadcast t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.invocationid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 337l in
              heading :: payload
          | Opgroupnonuniformbroadcastfirst t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 338l in
              heading :: payload
          | Opgroupnonuniformelect t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 333l in
              heading :: payload
          | Opgroupnonuniformfadd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 350l in
              heading :: payload
          | Opgroupnonuniformfmax t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 358l in
              heading :: payload
          | Opgroupnonuniformfmin t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 355l in
              heading :: payload
          | Opgroupnonuniformfmul t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 352l in
              heading :: payload
          | Opgroupnonuniformiadd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 349l in
              heading :: payload
          | Opgroupnonuniformimul t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 351l in
              heading :: payload
          | Opgroupnonuniforminverseballot t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 340l in
              heading :: payload
          | Opgroupnonuniformlogicaland t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 362l in
              heading :: payload
          | Opgroupnonuniformlogicalor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 363l in
              heading :: payload
          | Opgroupnonuniformlogicalxor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 364l in
              heading :: payload
          | Opgroupnonuniformpartitionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5296l in
              heading :: payload
          | Opgroupnonuniformquadallkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5110l in
              heading :: payload
          | Opgroupnonuniformquadanykhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.predicate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5111l in
              heading :: payload
          | Opgroupnonuniformquadbroadcast t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.index] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 365l in
              heading :: payload
          | Opgroupnonuniformquadswap t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.direction] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 366l in
              heading :: payload
          | Opgroupnonuniformshuffle t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.invocationid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 345l in
              heading :: payload
          | Opgroupnonuniformshuffledown t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.delta] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 348l in
              heading :: payload
          | Opgroupnonuniformshuffleup t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.delta] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 347l in
              heading :: payload
          | Opgroupnonuniformshufflexor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.value;
                  Operand_kind.Payload.Idref.value t.mask] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 346l in
              heading :: payload
          | Opgroupnonuniformsmax t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 356l in
              heading :: payload
          | Opgroupnonuniformsmin t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 353l in
              heading :: payload
          | Opgroupnonuniformumax t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 357l in
              heading :: payload
          | Opgroupnonuniformumin t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Groupoperation.value t.operation;
                  Operand_kind.Payload.Idref.value t.value;
                  (t.clustersize |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 354l in
              heading :: payload
        let any_required_version =
          function
          | Opgroupnonuniformall _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformallequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformany _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformballot _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformballotbitcount _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformballotbitextract _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformballotfindlsb _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformballotfindmsb _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformbitwiseand _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformbitwiseor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformbitwisexor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformbroadcast _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformbroadcastfirst _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformelect _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformfadd _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformfmax _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformfmin _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformfmul _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformiadd _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformimul _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniforminverseballot _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformlogicaland _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformlogicalor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformlogicalxor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformpartitionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformquadallkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformquadanykhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformquadbroadcast _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformquadswap _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformshuffle _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformshuffledown _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformshuffleup _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformshufflexor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformsmax _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformsmin _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformumax _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupnonuniformumin _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_3)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opgroupnonuniformall _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformallequal _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformany _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformballot _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformballotbitcount _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformballotbitextract _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformballotfindlsb _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformballotfindmsb _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformbitwiseand _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformbitwiseor _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformbitwisexor _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformbroadcast _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformbroadcastfirst _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformelect _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformfadd _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformfmax _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformfmin _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformfmul _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformiadd _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformimul _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniforminverseballot _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformlogicaland _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformlogicalor _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformlogicalxor _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformpartitionnv _ ->
              [Requirements.Extension.Spv_nv_shader_subgroup_partitioned] |>
                Requirements.Extension.Set.of_list
          | Opgroupnonuniformquadallkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformquadanykhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformquadbroadcast _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformquadswap _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformshuffle _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformshuffledown _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformshuffleup _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformshufflexor _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformsmax _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformsmin _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformumax _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupnonuniformumin _ ->
              [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opgroupnonuniformall _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformvote] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformallequal _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformvote] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformany _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformvote] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformballot _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformballot] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformballotbitcount _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformballot] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformballotbitextract _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformballot] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformballotfindlsb _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformballot] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformballotfindmsb _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformballot] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformbitwiseand _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformbitwiseor _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformbitwisexor _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformbroadcast _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformballot] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformbroadcastfirst _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformballot] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformelect _ ->
              [Operand_kind.Payload.Capability.Groupnonuniform] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformfadd _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformfmax _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformfmin _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformfmul _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformiadd _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformimul _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniforminverseballot _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformballot] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformlogicaland _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformlogicalor _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformlogicalxor _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformpartitionnv _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformquadallkhr _ ->
              [Operand_kind.Payload.Capability.Quadcontrolkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformquadanykhr _ ->
              [Operand_kind.Payload.Capability.Quadcontrolkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformquadbroadcast _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformquad] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformquadswap _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformquad] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformshuffle _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformshuffle] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformshuffledown _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformshufflerelative]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformshuffleup _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformshufflerelative]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformshufflexor _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformshuffle] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformsmax _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformsmin _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformumax _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opgroupnonuniformumin _ ->
              [Operand_kind.Payload.Capability.Groupnonuniformarithmetic;
              Operand_kind.Payload.Capability.Groupnonuniformclustered;
              Operand_kind.Payload.Capability.Groupnonuniformpartitionednv]
                |> Operand_kind.Payload.Capability.Set.of_list
      end
    module Pipe =
      struct
        type t =
          | Opcommitreadpipe of
          {
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opcommitwritepipe of
          {
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opconstantpipestorage of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          packetsize: Operand_kind.Payload.Literalinteger.t ;
          packetalignment: Operand_kind.Payload.Literalinteger.t ;
          capacity: Operand_kind.Payload.Literalinteger.t } 
          | Opcreatepipefrompipestorage of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipestorage: Operand_kind.Payload.Idref.t } 
          | Opgetmaxpipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgetnumpipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgroupcommitreadpipe of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgroupcommitwritepipe of
          {
          execution: Operand_kind.Payload.Idscope.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgroupreservereadpipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          numpackets: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opgroupreservewritepipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          numpackets: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opisvalidreserveid of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          reserveid: Operand_kind.Payload.Idref.t } 
          | Opreadpipe of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opreservedreadpipe of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opreservedwritepipe of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          reserveid: Operand_kind.Payload.Idref.t ;
          index: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opreservereadpipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          numpackets: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opreservewritepipepackets of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          numpackets: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } 
          | Opwritepipe of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pipe: Operand_kind.Payload.Idref.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          packetsize: Operand_kind.Payload.Idref.t ;
          packetalignment: Operand_kind.Payload.Idref.t } [@@deriving
                                                            compare, sexp_of]
        let provisional =
          function
          | Opcommitreadpipe _ -> false
          | Opcommitwritepipe _ -> false
          | Opconstantpipestorage _ -> false
          | Opcreatepipefrompipestorage _ -> false
          | Opgetmaxpipepackets _ -> false
          | Opgetnumpipepackets _ -> false
          | Opgroupcommitreadpipe _ -> false
          | Opgroupcommitwritepipe _ -> false
          | Opgroupreservereadpipepackets _ -> false
          | Opgroupreservewritepipepackets _ -> false
          | Opisvalidreserveid _ -> false
          | Opreadpipe _ -> false
          | Opreservedreadpipe _ -> false
          | Opreservedwritepipe _ -> false
          | Opreservereadpipepackets _ -> false
          | Opreservewritepipepackets _ -> false
          | Opwritepipe _ -> false
        let value =
          function
          | Opcommitreadpipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.reserveid;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 280l in
              heading :: payload
          | Opcommitwritepipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.reserveid;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 281l in
              heading :: payload
          | Opconstantpipestorage t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalinteger.value t.packetsize;
                  Operand_kind.Payload.Literalinteger.value t.packetalignment;
                  Operand_kind.Payload.Literalinteger.value t.capacity] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 323l in
              heading :: payload
          | Opcreatepipefrompipestorage t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipestorage] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 324l in
              heading :: payload
          | Opgetmaxpipepackets t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 284l in
              heading :: payload
          | Opgetnumpipepackets t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 283l in
              heading :: payload
          | Opgroupcommitreadpipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.reserveid;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 287l in
              heading :: payload
          | Opgroupcommitwritepipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.reserveid;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 288l in
              heading :: payload
          | Opgroupreservereadpipepackets t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.numpackets;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 285l in
              heading :: payload
          | Opgroupreservewritepipepackets t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.numpackets;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 286l in
              heading :: payload
          | Opisvalidreserveid t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.reserveid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 282l in
              heading :: payload
          | Opreadpipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 274l in
              heading :: payload
          | Opreservedreadpipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.reserveid;
                  Operand_kind.Payload.Idref.value t.index;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 276l in
              heading :: payload
          | Opreservedwritepipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.reserveid;
                  Operand_kind.Payload.Idref.value t.index;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 277l in
              heading :: payload
          | Opreservereadpipepackets t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.numpackets;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 278l in
              heading :: payload
          | Opreservewritepipepackets t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.numpackets;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 279l in
              heading :: payload
          | Opwritepipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pipe;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.packetsize;
                  Operand_kind.Payload.Idref.value t.packetalignment] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 275l in
              heading :: payload
        let any_required_version =
          function
          | Opcommitreadpipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcommitwritepipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantpipestorage _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcreatepipefrompipestorage _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetmaxpipepackets _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgetnumpipepackets _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupcommitreadpipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupcommitwritepipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupreservereadpipepackets _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opgroupreservewritepipepackets _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisvalidreserveid _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreadpipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreservedreadpipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreservedwritepipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreservereadpipepackets _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreservewritepipepackets _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opwritepipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opcommitreadpipe _ -> [] |> Requirements.Extension.Set.of_list
          | Opcommitwritepipe _ -> [] |> Requirements.Extension.Set.of_list
          | Opconstantpipestorage _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcreatepipefrompipestorage _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgetmaxpipepackets _ -> [] |> Requirements.Extension.Set.of_list
          | Opgetnumpipepackets _ -> [] |> Requirements.Extension.Set.of_list
          | Opgroupcommitreadpipe _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupcommitwritepipe _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupreservereadpipepackets _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opgroupreservewritepipepackets _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opisvalidreserveid _ -> [] |> Requirements.Extension.Set.of_list
          | Opreadpipe _ -> [] |> Requirements.Extension.Set.of_list
          | Opreservedreadpipe _ -> [] |> Requirements.Extension.Set.of_list
          | Opreservedwritepipe _ -> [] |> Requirements.Extension.Set.of_list
          | Opreservereadpipepackets _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opreservewritepipepackets _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opwritepipe _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opcommitreadpipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcommitwritepipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconstantpipestorage _ ->
              [Operand_kind.Payload.Capability.Pipestorage] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcreatepipefrompipestorage _ ->
              [Operand_kind.Payload.Capability.Pipestorage] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetmaxpipepackets _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgetnumpipepackets _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupcommitreadpipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupcommitwritepipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupreservereadpipepackets _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opgroupreservewritepipepackets _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opisvalidreserveid _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreadpipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreservedreadpipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreservedwritepipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreservereadpipepackets _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreservewritepipepackets _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opwritepipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Primitive =
      struct
        type t =
          | Opemitstreamvertex of {
          stream: Operand_kind.Payload.Idref.t } 
          | Opemitvertex 
          | Opendprimitive 
          | Opendstreamprimitive of {
          stream: Operand_kind.Payload.Idref.t } [@@deriving
                                                   compare, sexp_of]
        let provisional =
          function
          | Opemitstreamvertex _ -> false
          | Opemitvertex -> false
          | Opendprimitive -> false
          | Opendstreamprimitive _ -> false
        let value =
          function
          | Opemitstreamvertex t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.stream] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 220l in
              heading :: payload
          | Opemitvertex ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 218l in
              [heading]
          | Opendprimitive ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 219l in
              [heading]
          | Opendstreamprimitive t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.stream] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 221l in
              heading :: payload
        let any_required_version =
          function
          | Opemitstreamvertex _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opemitvertex ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opendprimitive ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opendstreamprimitive _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opemitstreamvertex _ -> [] |> Requirements.Extension.Set.of_list
          | Opemitvertex -> [] |> Requirements.Extension.Set.of_list
          | Opendprimitive -> [] |> Requirements.Extension.Set.of_list
          | Opendstreamprimitive _ ->
              [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opemitstreamvertex _ ->
              [Operand_kind.Payload.Capability.Geometrystreams] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opemitvertex ->
              [Operand_kind.Payload.Capability.Geometry] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opendprimitive ->
              [Operand_kind.Payload.Capability.Geometry] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opendstreamprimitive _ ->
              [Operand_kind.Payload.Capability.Geometrystreams] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Relational_and_logical =
      struct
        type t =
          | Opall of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t } 
          | Opany of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          vector: Operand_kind.Payload.Idref.t } 
          | Opfordequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordgreaterthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordgreaterthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordlessthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordlessthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfordnotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordgreaterthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordgreaterthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordlessthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordlessthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opfunordnotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opinotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opisfinite of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opisinf of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opisnan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opisnormal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Oplessorgreater of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t ;
          y: Operand_kind.Payload.Idref.t } 
          | Oplogicaland of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oplogicalequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oplogicalnot of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Oplogicalnotequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oplogicalor of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opordered of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t ;
          y: Operand_kind.Payload.Idref.t } 
          | Opselect of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          condition: Operand_kind.Payload.Idref.t ;
          object1: Operand_kind.Payload.Idref.t ;
          object2: Operand_kind.Payload.Idref.t } 
          | Opsgreaterthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsgreaterthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opsignbitset of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t } 
          | Opslessthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opslessthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opugreaterthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opugreaterthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opulessthan of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opulessthanequal of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opunordered of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          x: Operand_kind.Payload.Idref.t ;
          y: Operand_kind.Payload.Idref.t } [@@deriving compare, sexp_of]
        let provisional =
          function
          | Opall _ -> false
          | Opany _ -> false
          | Opfordequal _ -> false
          | Opfordgreaterthan _ -> false
          | Opfordgreaterthanequal _ -> false
          | Opfordlessthan _ -> false
          | Opfordlessthanequal _ -> false
          | Opfordnotequal _ -> false
          | Opfunordequal _ -> false
          | Opfunordgreaterthan _ -> false
          | Opfunordgreaterthanequal _ -> false
          | Opfunordlessthan _ -> false
          | Opfunordlessthanequal _ -> false
          | Opfunordnotequal _ -> false
          | Opiequal _ -> false
          | Opinotequal _ -> false
          | Opisfinite _ -> false
          | Opisinf _ -> false
          | Opisnan _ -> false
          | Opisnormal _ -> false
          | Oplessorgreater _ -> false
          | Oplogicaland _ -> false
          | Oplogicalequal _ -> false
          | Oplogicalnot _ -> false
          | Oplogicalnotequal _ -> false
          | Oplogicalor _ -> false
          | Opordered _ -> false
          | Opselect _ -> false
          | Opsgreaterthan _ -> false
          | Opsgreaterthanequal _ -> false
          | Opsignbitset _ -> false
          | Opslessthan _ -> false
          | Opslessthanequal _ -> false
          | Opugreaterthan _ -> false
          | Opugreaterthanequal _ -> false
          | Opulessthan _ -> false
          | Opulessthanequal _ -> false
          | Opunordered _ -> false
        let value =
          function
          | Opall t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 155l in
              heading :: payload
          | Opany t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.vector] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 154l in
              heading :: payload
          | Opfordequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 180l in
              heading :: payload
          | Opfordgreaterthan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 186l in
              heading :: payload
          | Opfordgreaterthanequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 190l in
              heading :: payload
          | Opfordlessthan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 184l in
              heading :: payload
          | Opfordlessthanequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 188l in
              heading :: payload
          | Opfordnotequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 182l in
              heading :: payload
          | Opfunordequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 181l in
              heading :: payload
          | Opfunordgreaterthan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 187l in
              heading :: payload
          | Opfunordgreaterthanequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 191l in
              heading :: payload
          | Opfunordlessthan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 185l in
              heading :: payload
          | Opfunordlessthanequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 189l in
              heading :: payload
          | Opfunordnotequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 183l in
              heading :: payload
          | Opiequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 170l in
              heading :: payload
          | Opinotequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 171l in
              heading :: payload
          | Opisfinite t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 158l in
              heading :: payload
          | Opisinf t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 157l in
              heading :: payload
          | Opisnan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 156l in
              heading :: payload
          | Opisnormal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 159l in
              heading :: payload
          | Oplessorgreater t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.x;
                  Operand_kind.Payload.Idref.value t.y] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 161l in
              heading :: payload
          | Oplogicaland t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 167l in
              heading :: payload
          | Oplogicalequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 164l in
              heading :: payload
          | Oplogicalnot t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 168l in
              heading :: payload
          | Oplogicalnotequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 165l in
              heading :: payload
          | Oplogicalor t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 166l in
              heading :: payload
          | Opordered t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.x;
                  Operand_kind.Payload.Idref.value t.y] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 162l in
              heading :: payload
          | Opselect t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.condition;
                  Operand_kind.Payload.Idref.value t.object1;
                  Operand_kind.Payload.Idref.value t.object2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 169l in
              heading :: payload
          | Opsgreaterthan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 173l in
              heading :: payload
          | Opsgreaterthanequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 175l in
              heading :: payload
          | Opsignbitset t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.x] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 160l in
              heading :: payload
          | Opslessthan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 177l in
              heading :: payload
          | Opslessthanequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 179l in
              heading :: payload
          | Opugreaterthan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 172l in
              heading :: payload
          | Opugreaterthanequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 174l in
              heading :: payload
          | Opulessthan t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 176l in
              heading :: payload
          | Opulessthanequal t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 178l in
              heading :: payload
          | Opunordered t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.x;
                  Operand_kind.Payload.Idref.value t.y] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 163l in
              heading :: payload
        let any_required_version =
          function
          | Opall _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opany _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfordequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfordgreaterthan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfordgreaterthanequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfordlessthan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfordlessthanequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfordnotequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunordequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunordgreaterthan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunordgreaterthanequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunordlessthan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunordlessthanequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfunordnotequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opiequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opinotequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisfinite _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisinf _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisnan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisnormal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oplessorgreater _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:(Some V1_5))
                |> Requirements.Version.Set.of_list
          | Oplogicaland _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oplogicalequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oplogicalnot _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oplogicalnotequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Oplogicalor _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opordered _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opselect _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsgreaterthan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsgreaterthanequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsignbitset _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opslessthan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opslessthanequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opugreaterthan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opugreaterthanequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opulessthan _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opulessthanequal _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Opunordered _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opall _ -> [] |> Requirements.Extension.Set.of_list
          | Opany _ -> [] |> Requirements.Extension.Set.of_list
          | Opfordequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opfordgreaterthan _ -> [] |> Requirements.Extension.Set.of_list
          | Opfordgreaterthanequal _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfordlessthan _ -> [] |> Requirements.Extension.Set.of_list
          | Opfordlessthanequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opfordnotequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opfunordequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opfunordgreaterthan _ -> [] |> Requirements.Extension.Set.of_list
          | Opfunordgreaterthanequal _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfunordlessthan _ -> [] |> Requirements.Extension.Set.of_list
          | Opfunordlessthanequal _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfunordnotequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opiequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opinotequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opisfinite _ -> [] |> Requirements.Extension.Set.of_list
          | Opisinf _ -> [] |> Requirements.Extension.Set.of_list
          | Opisnan _ -> [] |> Requirements.Extension.Set.of_list
          | Opisnormal _ -> [] |> Requirements.Extension.Set.of_list
          | Oplessorgreater _ -> [] |> Requirements.Extension.Set.of_list
          | Oplogicaland _ -> [] |> Requirements.Extension.Set.of_list
          | Oplogicalequal _ -> [] |> Requirements.Extension.Set.of_list
          | Oplogicalnot _ -> [] |> Requirements.Extension.Set.of_list
          | Oplogicalnotequal _ -> [] |> Requirements.Extension.Set.of_list
          | Oplogicalor _ -> [] |> Requirements.Extension.Set.of_list
          | Opordered _ -> [] |> Requirements.Extension.Set.of_list
          | Opselect _ -> [] |> Requirements.Extension.Set.of_list
          | Opsgreaterthan _ -> [] |> Requirements.Extension.Set.of_list
          | Opsgreaterthanequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opsignbitset _ -> [] |> Requirements.Extension.Set.of_list
          | Opslessthan _ -> [] |> Requirements.Extension.Set.of_list
          | Opslessthanequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opugreaterthan _ -> [] |> Requirements.Extension.Set.of_list
          | Opugreaterthanequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opulessthan _ -> [] |> Requirements.Extension.Set.of_list
          | Opulessthanequal _ -> [] |> Requirements.Extension.Set.of_list
          | Opunordered _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opall _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opany _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfordequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfordgreaterthan _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfordgreaterthanequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfordlessthan _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfordlessthanequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfordnotequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunordequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunordgreaterthan _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunordgreaterthanequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunordlessthan _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunordlessthanequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opfunordnotequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opiequal _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opinotequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opisfinite _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opisinf _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opisnan _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opisnormal _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oplessorgreater _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oplogicaland _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Oplogicalequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Oplogicalnot _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Oplogicalnotequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Oplogicalor _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opordered _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opselect _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsgreaterthan _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsgreaterthanequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opsignbitset _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opslessthan _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opslessthanequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opugreaterthan _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opugreaterthanequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opulessthan _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opulessthanequal _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Opunordered _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Reserved =
      struct
        type t =
          | Opabsisubintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opabsusubintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opallocatenodepayloadsamdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          visibility: Operand_kind.Payload.Idscope.t ;
          payloadcount: Operand_kind.Payload.Idref.t ;
          nodeindex: Operand_kind.Payload.Idref.t } 
          | Opbegininvocationinterlockext 
          | Opconstantstringamdx of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          literalstring: Operand_kind.Payload.Literalstring.t } 
          | Opconvertimagetounv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertsampledimagetounv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertsamplertounv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertutoaccelerationstructurekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          accel: Operand_kind.Payload.Idref.t } 
          | Opconvertutoimagenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertutosampledimagenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opconvertutosamplernv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixlengthnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          type_: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixloadnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          pointer: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t ;
          columnmajor: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativematrixmuladdnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          a: Operand_kind.Payload.Idref.t ;
          b: Operand_kind.Payload.Idref.t ;
          c: Operand_kind.Payload.Idref.t } 
          | Opcooperativematrixstorenv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t ;
          columnmajor: Operand_kind.Payload.Idref.t ;
          memoryaccess: Operand_kind.Payload.Memoryaccess.t option } 
          | Opcooperativevectormatrixmuladdnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          inputinterpretation: Operand_kind.Payload.Idref.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          matrixoffset: Operand_kind.Payload.Idref.t ;
          matrixinterpretation: Operand_kind.Payload.Idref.t ;
          bias: Operand_kind.Payload.Idref.t ;
          biasoffset: Operand_kind.Payload.Idref.t ;
          biasinterpretation: Operand_kind.Payload.Idref.t ;
          m: Operand_kind.Payload.Idref.t ;
          k: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          transpose: Operand_kind.Payload.Idref.t ;
          matrixstride: Operand_kind.Payload.Idref.t option ;
          cooperativematrixoperands:
            Operand_kind.Payload.Cooperativematrixoperands.t option }
          
          | Opcooperativevectormatrixmulnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          input: Operand_kind.Payload.Idref.t ;
          inputinterpretation: Operand_kind.Payload.Idref.t ;
          matrix: Operand_kind.Payload.Idref.t ;
          matrixoffset: Operand_kind.Payload.Idref.t ;
          matrixinterpretation: Operand_kind.Payload.Idref.t ;
          m: Operand_kind.Payload.Idref.t ;
          k: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          transpose: Operand_kind.Payload.Idref.t ;
          matrixstride: Operand_kind.Payload.Idref.t option ;
          cooperativematrixoperands:
            Operand_kind.Payload.Cooperativematrixoperands.t option }
          
          | Opcooperativevectorouterproductaccumulatenv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          a: Operand_kind.Payload.Idref.t ;
          b: Operand_kind.Payload.Idref.t ;
          memorylayout: Operand_kind.Payload.Idref.t ;
          matrixinterpretation: Operand_kind.Payload.Idref.t ;
          matrixstride: Operand_kind.Payload.Idref.t option } 
          | Opcooperativevectorreducesumaccumulatenv of
          {
          pointer: Operand_kind.Payload.Idref.t ;
          offset: Operand_kind.Payload.Idref.t ;
          v: Operand_kind.Payload.Idref.t } 
          | Opcreatetensorlayoutnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opcreatetensorviewnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opemitmeshtasksext of
          {
          groupcountx: Operand_kind.Payload.Idref.t ;
          groupcounty: Operand_kind.Payload.Idref.t ;
          groupcountz: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t option } 
          | Opendinvocationinterlockext 
          | Openqueuenodepayloadsamdx of
          {
          payloadarray: Operand_kind.Payload.Idref.t } 
          | Opexecutecallablekhr of
          {
          sbtindex: Operand_kind.Payload.Idref.t ;
          callabledata: Operand_kind.Payload.Idref.t } 
          | Opexecutecallablenv of
          {
          sbtindex: Operand_kind.Payload.Idref.t ;
          callabledataid: Operand_kind.Payload.Idref.t } 
          | Opfetchmicrotrianglevertexbarycentricnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          accel: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          primitiveindex: Operand_kind.Payload.Idref.t ;
          barycentric: Operand_kind.Payload.Idref.t } 
          | Opfetchmicrotrianglevertexpositionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          accel: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          primitiveindex: Operand_kind.Payload.Idref.t ;
          barycentric: Operand_kind.Payload.Idref.t } 
          | Opfinishwritingnodepayloadamdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Opfragmentfetchamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t ;
          fragmentindex: Operand_kind.Payload.Idref.t } 
          | Opfragmentmaskfetchamd of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          image: Operand_kind.Payload.Idref.t ;
          coordinate: Operand_kind.Payload.Idref.t } 
          | Ophitobjectexecuteshaderext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjectexecuteshadernv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetattributesext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          hitobjectattribute: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetattributesnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          hitobjectattribute: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetclusteridnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetcurrenttimeext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetcurrenttimenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetgeometryindexext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetgeometryindexnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgethitkindext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgethitkindnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetinstancecustomindexext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetinstancecustomindexnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetinstanceidext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetinstanceidnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetintersectiontrianglevertexpositionsext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetlsspositionsnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetlssradiinv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjectraydirectionext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjectraydirectionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjectrayoriginext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjectrayoriginnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjecttoworldext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetobjecttoworldnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetprimitiveindexext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetprimitiveindexnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetrayflagsext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetraytmaxext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetraytmaxnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetraytminext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetraytminnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetshaderbindingtablerecordindexext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetshaderbindingtablerecordindexnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetshaderrecordbufferhandleext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetshaderrecordbufferhandlenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetspherepositionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetsphereradiusnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldraydirectionext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldraydirectionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldrayoriginext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldrayoriginnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldtoobjectext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectgetworldtoobjectnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectisemptyext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectisemptynv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectishitext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectishitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectislsshitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectismissext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectismissnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectisspherehitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordemptyext of
          {
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordemptynv of
          {
          hitobject: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordfromqueryext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          sbtrecordindex: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordhitmotionnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          primitiveid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t ;
          sbtrecordoffset: Operand_kind.Payload.Idref.t ;
          sbtrecordstride: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordhitnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          primitiveid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t ;
          sbtrecordoffset: Operand_kind.Payload.Idref.t ;
          sbtrecordstride: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordhitwithindexmotionnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          primitiveid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t ;
          sbtrecordindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordhitwithindexnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          instanceid: Operand_kind.Payload.Idref.t ;
          primitiveid: Operand_kind.Payload.Idref.t ;
          geometryindex: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t ;
          sbtrecordindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          hitobjectattributes: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordmissext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordmissmotionext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordmissmotionnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          sbtindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t } 
          | Ophitobjectrecordmissnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          sbtindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t } 
          | Ophitobjectreorderexecuteshaderext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Ophitobjectsetshaderbindingtablerecordindexext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          sbtrecordindex: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttracemotionreorderexecuteext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Ophitobjecttracerayext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttraceraymotionext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          currenttime: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttraceraymotionnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtrecordoffset: Operand_kind.Payload.Idref.t ;
          sbtrecordstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          time: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttraceraynv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtrecordoffset: Operand_kind.Payload.Idref.t ;
          sbtrecordstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          origin: Operand_kind.Payload.Idref.t ;
          tmin: Operand_kind.Payload.Idref.t ;
          direction: Operand_kind.Payload.Idref.t ;
          tmax: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Ophitobjecttracereorderexecuteext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          accelerationstructure: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Opiaddsatintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiaverageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opiaverageroundedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opignoreintersectionkhr 
          | Opignoreintersectionnv 
          | Opimul32x16intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opishelperinvocationext of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t } 
          | Opisnodepayloadvalidamdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payloadtype: Operand_kind.Payload.Idref.t ;
          nodeindex: Operand_kind.Payload.Idref.t } 
          | Opisubsatintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Oploopcontrolintel of
          {
          loopcontrolparameters: Operand_kind.Payload.Literalinteger.t list }
          
          | Opnodepayloadarraylengthamdx of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          payloadarray: Operand_kind.Payload.Idref.t } 
          | Oprayqueryconfirmintersectionkhr of
          {
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygenerateintersectionkhr of
          {
          rayquery: Operand_kind.Payload.Idref.t ;
          hitt: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionbarycentricskhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectioncandidateaabbopaquekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionclusteridnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionfrontfacekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectiongeometryindexkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectioninstancecustomindexkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectioninstanceidkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          |
          Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
          of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionlsshitvaluenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionlsspositionsnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionlssradiinv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionobjectraydirectionkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionobjectrayoriginkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionobjecttoworldkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionprimitiveindexkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionspherepositionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionsphereradiusnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectiontkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectiontrianglevertexpositionskhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectiontypekhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetintersectionworldtoobjectkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetrayflagskhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetraytminkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetworldraydirectionkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayquerygetworldrayoriginkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayqueryinitializekhr of
          {
          rayquery: Operand_kind.Payload.Idref.t ;
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t } 
          | Oprayqueryislsshitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayqueryisspherehitnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t ;
          intersection: Operand_kind.Payload.Idref.t } 
          | Oprayqueryproceedkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          rayquery: Operand_kind.Payload.Idref.t } 
          | Oprayqueryterminatekhr of
          {
          rayquery: Operand_kind.Payload.Idref.t } 
          | Opreadclockkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          scope: Operand_kind.Payload.Idscope.t } 
          | Opreorderthreadwithhintext of
          {
          hint: Operand_kind.Payload.Idref.t ;
          bits: Operand_kind.Payload.Idref.t } 
          | Opreorderthreadwithhintnv of
          {
          hint: Operand_kind.Payload.Idref.t ;
          bits: Operand_kind.Payload.Idref.t } 
          | Opreorderthreadwithhitobjectext of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Opreorderthreadwithhitobjectnv of
          {
          hitobject: Operand_kind.Payload.Idref.t ;
          hint: Operand_kind.Payload.Idref.t option ;
          bits: Operand_kind.Payload.Idref.t option } 
          | Opreportintersectionkhr of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          hit: Operand_kind.Payload.Idref.t ;
          hitkind: Operand_kind.Payload.Idref.t } 
          | Opsamplerimageaddressingmodenv of
          {
          bitwidth: Operand_kind.Payload.Literalinteger.t } 
          | Opsetmeshoutputsext of
          {
          vertexcount: Operand_kind.Payload.Idref.t ;
          primitivecount: Operand_kind.Payload.Idref.t } 
          | Opspecconstantstringamdx of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          literalstring: Operand_kind.Payload.Literalstring.t } 
          | Optensorlayoutsetblocksizenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          blocksize: Operand_kind.Payload.Idref.t list } 
          | Optensorlayoutsetclampvaluenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          value: Operand_kind.Payload.Idref.t } 
          | Optensorlayoutsetdimensionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          dim: Operand_kind.Payload.Idref.t list } 
          | Optensorlayoutsetstridenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t list } 
          | Optensorlayoutslicenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorlayout: Operand_kind.Payload.Idref.t ;
          operands: Operand_kind.Payload.Idref.t list } 
          | Optensorviewsetclipnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorview: Operand_kind.Payload.Idref.t ;
          cliprowoffset: Operand_kind.Payload.Idref.t ;
          cliprowspan: Operand_kind.Payload.Idref.t ;
          clipcoloffset: Operand_kind.Payload.Idref.t ;
          clipcolspan: Operand_kind.Payload.Idref.t } 
          | Optensorviewsetdimensionnv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorview: Operand_kind.Payload.Idref.t ;
          dim: Operand_kind.Payload.Idref.t list } 
          | Optensorviewsetstridenv of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensorview: Operand_kind.Payload.Idref.t ;
          stride: Operand_kind.Payload.Idref.t list } 
          | Opterminateraykhr 
          | Opterminateraynv 
          | Optracemotionnv of
          {
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          time: Operand_kind.Payload.Idref.t ;
          payloadid: Operand_kind.Payload.Idref.t } 
          | Optracenv of
          {
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          payloadid: Operand_kind.Payload.Idref.t } 
          | Optraceraykhr of
          {
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Optraceraymotionnv of
          {
          accel: Operand_kind.Payload.Idref.t ;
          rayflags: Operand_kind.Payload.Idref.t ;
          cullmask: Operand_kind.Payload.Idref.t ;
          sbtoffset: Operand_kind.Payload.Idref.t ;
          sbtstride: Operand_kind.Payload.Idref.t ;
          missindex: Operand_kind.Payload.Idref.t ;
          rayorigin: Operand_kind.Payload.Idref.t ;
          raytmin: Operand_kind.Payload.Idref.t ;
          raydirection: Operand_kind.Payload.Idref.t ;
          raytmax: Operand_kind.Payload.Idref.t ;
          time: Operand_kind.Payload.Idref.t ;
          payload: Operand_kind.Payload.Idref.t } 
          | Optypenodepayloadarrayamdx of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          payloadtype: Operand_kind.Payload.Idref.t } 
          | Opuaddsatintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opuaverageintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opuaverageroundedintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opucountleadingzerosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opucounttrailingzerosintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand: Operand_kind.Payload.Idref.t } 
          | Opumul32x16intel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opusubsatintel of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          operand1: Operand_kind.Payload.Idref.t ;
          operand2: Operand_kind.Payload.Idref.t } 
          | Opwritepackedprimitiveindices4x8nv of
          {
          indexoffset: Operand_kind.Payload.Idref.t ;
          packedindices: Operand_kind.Payload.Idref.t } [@@deriving
                                                          compare, sexp_of]
        let provisional =
          function
          | Opabsisubintel _ -> false
          | Opabsusubintel _ -> false
          | Opallocatenodepayloadsamdx _ -> true
          | Opbegininvocationinterlockext -> false
          | Opconstantstringamdx _ -> true
          | Opconvertimagetounv _ -> false
          | Opconvertsampledimagetounv _ -> false
          | Opconvertsamplertounv _ -> false
          | Opconvertutoaccelerationstructurekhr _ -> false
          | Opconvertutoimagenv _ -> false
          | Opconvertutosampledimagenv _ -> false
          | Opconvertutosamplernv _ -> false
          | Opcooperativematrixlengthnv _ -> false
          | Opcooperativematrixloadnv _ -> false
          | Opcooperativematrixmuladdnv _ -> false
          | Opcooperativematrixstorenv _ -> false
          | Opcooperativevectormatrixmuladdnv _ -> false
          | Opcooperativevectormatrixmulnv _ -> false
          | Opcooperativevectorouterproductaccumulatenv _ -> false
          | Opcooperativevectorreducesumaccumulatenv _ -> false
          | Opcreatetensorlayoutnv _ -> false
          | Opcreatetensorviewnv _ -> false
          | Opemitmeshtasksext _ -> false
          | Opendinvocationinterlockext -> false
          | Openqueuenodepayloadsamdx _ -> true
          | Opexecutecallablekhr _ -> false
          | Opexecutecallablenv _ -> false
          | Opfetchmicrotrianglevertexbarycentricnv _ -> false
          | Opfetchmicrotrianglevertexpositionnv _ -> false
          | Opfinishwritingnodepayloadamdx _ -> true
          | Opfragmentfetchamd _ -> false
          | Opfragmentmaskfetchamd _ -> false
          | Ophitobjectexecuteshaderext _ -> false
          | Ophitobjectexecuteshadernv _ -> false
          | Ophitobjectgetattributesext _ -> false
          | Ophitobjectgetattributesnv _ -> false
          | Ophitobjectgetclusteridnv _ -> false
          | Ophitobjectgetcurrenttimeext _ -> false
          | Ophitobjectgetcurrenttimenv _ -> false
          | Ophitobjectgetgeometryindexext _ -> false
          | Ophitobjectgetgeometryindexnv _ -> false
          | Ophitobjectgethitkindext _ -> false
          | Ophitobjectgethitkindnv _ -> false
          | Ophitobjectgetinstancecustomindexext _ -> false
          | Ophitobjectgetinstancecustomindexnv _ -> false
          | Ophitobjectgetinstanceidext _ -> false
          | Ophitobjectgetinstanceidnv _ -> false
          | Ophitobjectgetintersectiontrianglevertexpositionsext _ -> false
          | Ophitobjectgetlsspositionsnv _ -> false
          | Ophitobjectgetlssradiinv _ -> false
          | Ophitobjectgetobjectraydirectionext _ -> false
          | Ophitobjectgetobjectraydirectionnv _ -> false
          | Ophitobjectgetobjectrayoriginext _ -> false
          | Ophitobjectgetobjectrayoriginnv _ -> false
          | Ophitobjectgetobjecttoworldext _ -> false
          | Ophitobjectgetobjecttoworldnv _ -> false
          | Ophitobjectgetprimitiveindexext _ -> false
          | Ophitobjectgetprimitiveindexnv _ -> false
          | Ophitobjectgetrayflagsext _ -> false
          | Ophitobjectgetraytmaxext _ -> false
          | Ophitobjectgetraytmaxnv _ -> false
          | Ophitobjectgetraytminext _ -> false
          | Ophitobjectgetraytminnv _ -> false
          | Ophitobjectgetshaderbindingtablerecordindexext _ -> false
          | Ophitobjectgetshaderbindingtablerecordindexnv _ -> false
          | Ophitobjectgetshaderrecordbufferhandleext _ -> false
          | Ophitobjectgetshaderrecordbufferhandlenv _ -> false
          | Ophitobjectgetspherepositionnv _ -> false
          | Ophitobjectgetsphereradiusnv _ -> false
          | Ophitobjectgetworldraydirectionext _ -> false
          | Ophitobjectgetworldraydirectionnv _ -> false
          | Ophitobjectgetworldrayoriginext _ -> false
          | Ophitobjectgetworldrayoriginnv _ -> false
          | Ophitobjectgetworldtoobjectext _ -> false
          | Ophitobjectgetworldtoobjectnv _ -> false
          | Ophitobjectisemptyext _ -> false
          | Ophitobjectisemptynv _ -> false
          | Ophitobjectishitext _ -> false
          | Ophitobjectishitnv _ -> false
          | Ophitobjectislsshitnv _ -> false
          | Ophitobjectismissext _ -> false
          | Ophitobjectismissnv _ -> false
          | Ophitobjectisspherehitnv _ -> false
          | Ophitobjectrecordemptyext _ -> false
          | Ophitobjectrecordemptynv _ -> false
          | Ophitobjectrecordfromqueryext _ -> false
          | Ophitobjectrecordhitmotionnv _ -> false
          | Ophitobjectrecordhitnv _ -> false
          | Ophitobjectrecordhitwithindexmotionnv _ -> false
          | Ophitobjectrecordhitwithindexnv _ -> false
          | Ophitobjectrecordmissext _ -> false
          | Ophitobjectrecordmissmotionext _ -> false
          | Ophitobjectrecordmissmotionnv _ -> false
          | Ophitobjectrecordmissnv _ -> false
          | Ophitobjectreorderexecuteshaderext _ -> false
          | Ophitobjectsetshaderbindingtablerecordindexext _ -> false
          | Ophitobjecttracemotionreorderexecuteext _ -> false
          | Ophitobjecttracerayext _ -> false
          | Ophitobjecttraceraymotionext _ -> false
          | Ophitobjecttraceraymotionnv _ -> false
          | Ophitobjecttraceraynv _ -> false
          | Ophitobjecttracereorderexecuteext _ -> false
          | Opiaddsatintel _ -> false
          | Opiaverageintel _ -> false
          | Opiaverageroundedintel _ -> false
          | Opignoreintersectionkhr -> false
          | Opignoreintersectionnv -> false
          | Opimul32x16intel _ -> false
          | Opishelperinvocationext _ -> false
          | Opisnodepayloadvalidamdx _ -> true
          | Opisubsatintel _ -> false
          | Oploopcontrolintel _ -> false
          | Opnodepayloadarraylengthamdx _ -> true
          | Oprayqueryconfirmintersectionkhr _ -> false
          | Oprayquerygenerateintersectionkhr _ -> false
          | Oprayquerygetintersectionbarycentricskhr _ -> false
          | Oprayquerygetintersectioncandidateaabbopaquekhr _ -> false
          | Oprayquerygetintersectionclusteridnv _ -> false
          | Oprayquerygetintersectionfrontfacekhr _ -> false
          | Oprayquerygetintersectiongeometryindexkhr _ -> false
          | Oprayquerygetintersectioninstancecustomindexkhr _ -> false
          | Oprayquerygetintersectioninstanceidkhr _ -> false
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              _ -> false
          | Oprayquerygetintersectionlsshitvaluenv _ -> false
          | Oprayquerygetintersectionlsspositionsnv _ -> false
          | Oprayquerygetintersectionlssradiinv _ -> false
          | Oprayquerygetintersectionobjectraydirectionkhr _ -> false
          | Oprayquerygetintersectionobjectrayoriginkhr _ -> false
          | Oprayquerygetintersectionobjecttoworldkhr _ -> false
          | Oprayquerygetintersectionprimitiveindexkhr _ -> false
          | Oprayquerygetintersectionspherepositionnv _ -> false
          | Oprayquerygetintersectionsphereradiusnv _ -> false
          | Oprayquerygetintersectiontkhr _ -> false
          | Oprayquerygetintersectiontrianglevertexpositionskhr _ -> false
          | Oprayquerygetintersectiontypekhr _ -> false
          | Oprayquerygetintersectionworldtoobjectkhr _ -> false
          | Oprayquerygetrayflagskhr _ -> false
          | Oprayquerygetraytminkhr _ -> false
          | Oprayquerygetworldraydirectionkhr _ -> false
          | Oprayquerygetworldrayoriginkhr _ -> false
          | Oprayqueryinitializekhr _ -> false
          | Oprayqueryislsshitnv _ -> false
          | Oprayqueryisspherehitnv _ -> false
          | Oprayqueryproceedkhr _ -> false
          | Oprayqueryterminatekhr _ -> false
          | Opreadclockkhr _ -> false
          | Opreorderthreadwithhintext _ -> false
          | Opreorderthreadwithhintnv _ -> false
          | Opreorderthreadwithhitobjectext _ -> false
          | Opreorderthreadwithhitobjectnv _ -> false
          | Opreportintersectionkhr _ -> false
          | Opsamplerimageaddressingmodenv _ -> false
          | Opsetmeshoutputsext _ -> false
          | Opspecconstantstringamdx _ -> true
          | Optensorlayoutsetblocksizenv _ -> false
          | Optensorlayoutsetclampvaluenv _ -> false
          | Optensorlayoutsetdimensionnv _ -> false
          | Optensorlayoutsetstridenv _ -> false
          | Optensorlayoutslicenv _ -> false
          | Optensorviewsetclipnv _ -> false
          | Optensorviewsetdimensionnv _ -> false
          | Optensorviewsetstridenv _ -> false
          | Opterminateraykhr -> false
          | Opterminateraynv -> false
          | Optracemotionnv _ -> false
          | Optracenv _ -> false
          | Optraceraykhr _ -> false
          | Optraceraymotionnv _ -> false
          | Optypenodepayloadarrayamdx _ -> true
          | Opuaddsatintel _ -> false
          | Opuaverageintel _ -> false
          | Opuaverageroundedintel _ -> false
          | Opucountleadingzerosintel _ -> false
          | Opucounttrailingzerosintel _ -> false
          | Opumul32x16intel _ -> false
          | Opusubsatintel _ -> false
          | Opwritepackedprimitiveindices4x8nv _ -> false
        let value =
          function
          | Opabsisubintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5587l in
              heading :: payload
          | Opabsusubintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5588l in
              heading :: payload
          | Opallocatenodepayloadsamdx t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.visibility;
                  Operand_kind.Payload.Idref.value t.payloadcount;
                  Operand_kind.Payload.Idref.value t.nodeindex] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5074l in
              heading :: payload
          | Opbegininvocationinterlockext ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5364l in
              [heading]
          | Opconstantstringamdx t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalstring.value t.literalstring] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5103l in
              heading :: payload
          | Opconvertimagetounv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5393l in
              heading :: payload
          | Opconvertsampledimagetounv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5396l in
              heading :: payload
          | Opconvertsamplertounv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5394l in
              heading :: payload
          | Opconvertutoaccelerationstructurekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.accel] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4447l in
              heading :: payload
          | Opconvertutoimagenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5391l in
              heading :: payload
          | Opconvertutosampledimagenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5395l in
              heading :: payload
          | Opconvertutosamplernv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5392l in
              heading :: payload
          | Opcooperativematrixlengthnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.type_] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5362l in
              heading :: payload
          | Opcooperativematrixloadnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.stride;
                  Operand_kind.Payload.Idref.value t.columnmajor;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5359l in
              heading :: payload
          | Opcooperativematrixmuladdnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Idref.value t.c] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5361l in
              heading :: payload
          | Opcooperativematrixstorenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.object_;
                  Operand_kind.Payload.Idref.value t.stride;
                  Operand_kind.Payload.Idref.value t.columnmajor;
                  (t.memoryaccess |>
                     (Option.map ~f:Operand_kind.Payload.Memoryaccess.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5360l in
              heading :: payload
          | Opcooperativevectormatrixmuladdnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Idref.value t.inputinterpretation;
                  Operand_kind.Payload.Idref.value t.matrix;
                  Operand_kind.Payload.Idref.value t.matrixoffset;
                  Operand_kind.Payload.Idref.value t.matrixinterpretation;
                  Operand_kind.Payload.Idref.value t.bias;
                  Operand_kind.Payload.Idref.value t.biasoffset;
                  Operand_kind.Payload.Idref.value t.biasinterpretation;
                  Operand_kind.Payload.Idref.value t.m;
                  Operand_kind.Payload.Idref.value t.k;
                  Operand_kind.Payload.Idref.value t.memorylayout;
                  Operand_kind.Payload.Idref.value t.transpose;
                  (t.matrixstride |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.cooperativematrixoperands |>
                     (Option.map
                        ~f:Operand_kind.Payload.Cooperativematrixoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5292l in
              heading :: payload
          | Opcooperativevectormatrixmulnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.input;
                  Operand_kind.Payload.Idref.value t.inputinterpretation;
                  Operand_kind.Payload.Idref.value t.matrix;
                  Operand_kind.Payload.Idref.value t.matrixoffset;
                  Operand_kind.Payload.Idref.value t.matrixinterpretation;
                  Operand_kind.Payload.Idref.value t.m;
                  Operand_kind.Payload.Idref.value t.k;
                  Operand_kind.Payload.Idref.value t.memorylayout;
                  Operand_kind.Payload.Idref.value t.transpose;
                  (t.matrixstride |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.cooperativematrixoperands |>
                     (Option.map
                        ~f:Operand_kind.Payload.Cooperativematrixoperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5289l in
              heading :: payload
          | Opcooperativevectorouterproductaccumulatenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.offset;
                  Operand_kind.Payload.Idref.value t.a;
                  Operand_kind.Payload.Idref.value t.b;
                  Operand_kind.Payload.Idref.value t.memorylayout;
                  Operand_kind.Payload.Idref.value t.matrixinterpretation;
                  (t.matrixstride |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5290l in
              heading :: payload
          | Opcooperativevectorreducesumaccumulatenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointer;
                  Operand_kind.Payload.Idref.value t.offset;
                  Operand_kind.Payload.Idref.value t.v] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5291l in
              heading :: payload
          | Opcreatetensorlayoutnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5372l in
              heading :: payload
          | Opcreatetensorviewnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5377l in
              heading :: payload
          | Opemitmeshtasksext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.groupcountx;
                  Operand_kind.Payload.Idref.value t.groupcounty;
                  Operand_kind.Payload.Idref.value t.groupcountz;
                  (t.payload |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5294l in
              heading :: payload
          | Opendinvocationinterlockext ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5365l in
              [heading]
          | Openqueuenodepayloadsamdx t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.payloadarray] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5075l in
              heading :: payload
          | Opexecutecallablekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.sbtindex;
                  Operand_kind.Payload.Idref.value t.callabledata] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4446l in
              heading :: payload
          | Opexecutecallablenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.sbtindex;
                  Operand_kind.Payload.Idref.value t.callabledataid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5344l in
              heading :: payload
          | Opfetchmicrotrianglevertexbarycentricnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.accel;
                  Operand_kind.Payload.Idref.value t.instanceid;
                  Operand_kind.Payload.Idref.value t.geometryindex;
                  Operand_kind.Payload.Idref.value t.primitiveindex;
                  Operand_kind.Payload.Idref.value t.barycentric] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5301l in
              heading :: payload
          | Opfetchmicrotrianglevertexpositionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.accel;
                  Operand_kind.Payload.Idref.value t.instanceid;
                  Operand_kind.Payload.Idref.value t.geometryindex;
                  Operand_kind.Payload.Idref.value t.primitiveindex;
                  Operand_kind.Payload.Idref.value t.barycentric] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5300l in
              heading :: payload
          | Opfinishwritingnodepayloadamdx t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5078l in
              heading :: payload
          | Opfragmentfetchamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate;
                  Operand_kind.Payload.Idref.value t.fragmentindex] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5012l in
              heading :: payload
          | Opfragmentmaskfetchamd t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.image;
                  Operand_kind.Payload.Idref.value t.coordinate] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5011l in
              heading :: payload
          | Ophitobjectexecuteshaderext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5319l in
              heading :: payload
          | Ophitobjectexecuteshadernv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5264l in
              heading :: payload
          | Ophitobjectgetattributesext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.hitobjectattribute] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5321l in
              heading :: payload
          | Ophitobjectgetattributesnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.hitobjectattribute] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5266l in
              heading :: payload
          | Ophitobjectgetclusteridnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5346l in
              heading :: payload
          | Ophitobjectgetcurrenttimeext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5320l in
              heading :: payload
          | Ophitobjectgetcurrenttimenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5265l in
              heading :: payload
          | Ophitobjectgetgeometryindexext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5324l in
              heading :: payload
          | Ophitobjectgetgeometryindexnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5269l in
              heading :: payload
          | Ophitobjectgethitkindext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5322l in
              heading :: payload
          | Ophitobjectgethitkindnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5267l in
              heading :: payload
          | Ophitobjectgetinstancecustomindexext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5326l in
              heading :: payload
          | Ophitobjectgetinstancecustomindexnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5271l in
              heading :: payload
          | Ophitobjectgetinstanceidext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5325l in
              heading :: payload
          | Ophitobjectgetinstanceidnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5270l in
              heading :: payload
          | Ophitobjectgetintersectiontrianglevertexpositionsext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5307l in
              heading :: payload
          | Ophitobjectgetlsspositionsnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5434l in
              heading :: payload
          | Ophitobjectgetlssradiinv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5435l in
              heading :: payload
          | Ophitobjectgetobjectraydirectionext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5328l in
              heading :: payload
          | Ophitobjectgetobjectraydirectionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5254l in
              heading :: payload
          | Ophitobjectgetobjectrayoriginext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5327l in
              heading :: payload
          | Ophitobjectgetobjectrayoriginnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5255l in
              heading :: payload
          | Ophitobjectgetobjecttoworldext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5331l in
              heading :: payload
          | Ophitobjectgetobjecttoworldnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5253l in
              heading :: payload
          | Ophitobjectgetprimitiveindexext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5323l in
              heading :: payload
          | Ophitobjectgetprimitiveindexnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5268l in
              heading :: payload
          | Ophitobjectgetrayflagsext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5308l in
              heading :: payload
          | Ophitobjectgetraytmaxext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5333l in
              heading :: payload
          | Ophitobjectgetraytmaxnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5274l in
              heading :: payload
          | Ophitobjectgetraytminext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5347l in
              heading :: payload
          | Ophitobjectgetraytminnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5275l in
              heading :: payload
          | Ophitobjectgetshaderbindingtablerecordindexext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5348l in
              heading :: payload
          | Ophitobjectgetshaderbindingtablerecordindexnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5258l in
              heading :: payload
          | Ophitobjectgetshaderrecordbufferhandleext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5349l in
              heading :: payload
          | Ophitobjectgetshaderrecordbufferhandlenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5257l in
              heading :: payload
          | Ophitobjectgetspherepositionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5432l in
              heading :: payload
          | Ophitobjectgetsphereradiusnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5433l in
              heading :: payload
          | Ophitobjectgetworldraydirectionext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5329l in
              heading :: payload
          | Ophitobjectgetworldraydirectionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5272l in
              heading :: payload
          | Ophitobjectgetworldrayoriginext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5330l in
              heading :: payload
          | Ophitobjectgetworldrayoriginnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5273l in
              heading :: payload
          | Ophitobjectgetworldtoobjectext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5332l in
              heading :: payload
          | Ophitobjectgetworldtoobjectnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5252l in
              heading :: payload
          | Ophitobjectisemptyext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5350l in
              heading :: payload
          | Ophitobjectisemptynv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5276l in
              heading :: payload
          | Ophitobjectishitext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5351l in
              heading :: payload
          | Ophitobjectishitnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5277l in
              heading :: payload
          | Ophitobjectislsshitnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5437l in
              heading :: payload
          | Ophitobjectismissext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5352l in
              heading :: payload
          | Ophitobjectismissnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5278l in
              heading :: payload
          | Ophitobjectisspherehitnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5436l in
              heading :: payload
          | Ophitobjectrecordemptyext t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5318l in
              heading :: payload
          | Ophitobjectrecordemptynv t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.hitobject] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5259l in
              heading :: payload
          | Ophitobjectrecordfromqueryext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.sbtrecordindex;
                  Operand_kind.Payload.Idref.value t.hitobjectattributes] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5304l in
              heading :: payload
          | Ophitobjectrecordhitmotionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.instanceid;
                  Operand_kind.Payload.Idref.value t.primitiveid;
                  Operand_kind.Payload.Idref.value t.geometryindex;
                  Operand_kind.Payload.Idref.value t.hitkind;
                  Operand_kind.Payload.Idref.value t.sbtrecordoffset;
                  Operand_kind.Payload.Idref.value t.sbtrecordstride;
                  Operand_kind.Payload.Idref.value t.origin;
                  Operand_kind.Payload.Idref.value t.tmin;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.tmax;
                  Operand_kind.Payload.Idref.value t.currenttime;
                  Operand_kind.Payload.Idref.value t.hitobjectattributes] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5249l in
              heading :: payload
          | Ophitobjectrecordhitnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.instanceid;
                  Operand_kind.Payload.Idref.value t.primitiveid;
                  Operand_kind.Payload.Idref.value t.geometryindex;
                  Operand_kind.Payload.Idref.value t.hitkind;
                  Operand_kind.Payload.Idref.value t.sbtrecordoffset;
                  Operand_kind.Payload.Idref.value t.sbtrecordstride;
                  Operand_kind.Payload.Idref.value t.origin;
                  Operand_kind.Payload.Idref.value t.tmin;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.tmax;
                  Operand_kind.Payload.Idref.value t.hitobjectattributes] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5261l in
              heading :: payload
          | Ophitobjectrecordhitwithindexmotionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.instanceid;
                  Operand_kind.Payload.Idref.value t.primitiveid;
                  Operand_kind.Payload.Idref.value t.geometryindex;
                  Operand_kind.Payload.Idref.value t.hitkind;
                  Operand_kind.Payload.Idref.value t.sbtrecordindex;
                  Operand_kind.Payload.Idref.value t.origin;
                  Operand_kind.Payload.Idref.value t.tmin;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.tmax;
                  Operand_kind.Payload.Idref.value t.currenttime;
                  Operand_kind.Payload.Idref.value t.hitobjectattributes] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5250l in
              heading :: payload
          | Ophitobjectrecordhitwithindexnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.instanceid;
                  Operand_kind.Payload.Idref.value t.primitiveid;
                  Operand_kind.Payload.Idref.value t.geometryindex;
                  Operand_kind.Payload.Idref.value t.hitkind;
                  Operand_kind.Payload.Idref.value t.sbtrecordindex;
                  Operand_kind.Payload.Idref.value t.origin;
                  Operand_kind.Payload.Idref.value t.tmin;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.tmax;
                  Operand_kind.Payload.Idref.value t.hitobjectattributes] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5262l in
              heading :: payload
          | Ophitobjectrecordmissext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5305l in
              heading :: payload
          | Ophitobjectrecordmissmotionext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.currenttime] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5306l in
              heading :: payload
          | Ophitobjectrecordmissmotionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.sbtindex;
                  Operand_kind.Payload.Idref.value t.origin;
                  Operand_kind.Payload.Idref.value t.tmin;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.tmax;
                  Operand_kind.Payload.Idref.value t.currenttime] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5251l in
              heading :: payload
          | Ophitobjectrecordmissnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.sbtindex;
                  Operand_kind.Payload.Idref.value t.origin;
                  Operand_kind.Payload.Idref.value t.tmin;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.tmax] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5263l in
              heading :: payload
          | Ophitobjectreorderexecuteshaderext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.payload;
                  (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5310l in
              heading :: payload
          | Ophitobjectsetshaderbindingtablerecordindexext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.sbtrecordindex] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5309l in
              heading :: payload
          | Ophitobjecttracemotionreorderexecuteext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtoffset;
                  Operand_kind.Payload.Idref.value t.sbtstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.currenttime;
                  Operand_kind.Payload.Idref.value t.payload;
                  (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5312l in
              heading :: payload
          | Ophitobjecttracerayext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtoffset;
                  Operand_kind.Payload.Idref.value t.sbtstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5316l in
              heading :: payload
          | Ophitobjecttraceraymotionext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtoffset;
                  Operand_kind.Payload.Idref.value t.sbtstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.currenttime;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5317l in
              heading :: payload
          | Ophitobjecttraceraymotionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtrecordoffset;
                  Operand_kind.Payload.Idref.value t.sbtrecordstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.origin;
                  Operand_kind.Payload.Idref.value t.tmin;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.tmax;
                  Operand_kind.Payload.Idref.value t.time;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5256l in
              heading :: payload
          | Ophitobjecttraceraynv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtrecordoffset;
                  Operand_kind.Payload.Idref.value t.sbtrecordstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.origin;
                  Operand_kind.Payload.Idref.value t.tmin;
                  Operand_kind.Payload.Idref.value t.direction;
                  Operand_kind.Payload.Idref.value t.tmax;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5260l in
              heading :: payload
          | Ophitobjecttracereorderexecuteext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  Operand_kind.Payload.Idref.value t.accelerationstructure;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtoffset;
                  Operand_kind.Payload.Idref.value t.sbtstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.payload;
                  (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5311l in
              heading :: payload
          | Opiaddsatintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5589l in
              heading :: payload
          | Opiaverageintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5591l in
              heading :: payload
          | Opiaverageroundedintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5593l in
              heading :: payload
          | Opignoreintersectionkhr ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 4448l in
              [heading]
          | Opignoreintersectionnv ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5335l in
              [heading]
          | Opimul32x16intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5597l in
              heading :: payload
          | Opishelperinvocationext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5381l in
              heading :: payload
          | Opisnodepayloadvalidamdx t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payloadtype;
                  Operand_kind.Payload.Idref.value t.nodeindex] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5101l in
              heading :: payload
          | Opisubsatintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5595l in
              heading :: payload
          | Oploopcontrolintel t ->
              let payload =
                List.concat
                  [List.concat_map t.loopcontrolparameters
                     ~f:Operand_kind.Payload.Literalinteger.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5887l in
              heading :: payload
          | Opnodepayloadarraylengthamdx t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payloadarray] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5090l in
              heading :: payload
          | Oprayqueryconfirmintersectionkhr t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.rayquery] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4476l in
              heading :: payload
          | Oprayquerygenerateintersectionkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.hitt] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4475l in
              heading :: payload
          | Oprayquerygetintersectionbarycentricskhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6024l in
              heading :: payload
          | Oprayquerygetintersectioncandidateaabbopaquekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6026l in
              heading :: payload
          | Oprayquerygetintersectionclusteridnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5345l in
              heading :: payload
          | Oprayquerygetintersectionfrontfacekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6025l in
              heading :: payload
          | Oprayquerygetintersectiongeometryindexkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6022l in
              heading :: payload
          | Oprayquerygetintersectioninstancecustomindexkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6019l in
              heading :: payload
          | Oprayquerygetintersectioninstanceidkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6020l in
              heading :: payload
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6021l in
              heading :: payload
          | Oprayquerygetintersectionlsshitvaluenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5431l in
              heading :: payload
          | Oprayquerygetintersectionlsspositionsnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5429l in
              heading :: payload
          | Oprayquerygetintersectionlssradiinv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5430l in
              heading :: payload
          | Oprayquerygetintersectionobjectraydirectionkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6027l in
              heading :: payload
          | Oprayquerygetintersectionobjectrayoriginkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6028l in
              heading :: payload
          | Oprayquerygetintersectionobjecttoworldkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6031l in
              heading :: payload
          | Oprayquerygetintersectionprimitiveindexkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6023l in
              heading :: payload
          | Oprayquerygetintersectionspherepositionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5427l in
              heading :: payload
          | Oprayquerygetintersectionsphereradiusnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5428l in
              heading :: payload
          | Oprayquerygetintersectiontkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6018l in
              heading :: payload
          | Oprayquerygetintersectiontrianglevertexpositionskhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5340l in
              heading :: payload
          | Oprayquerygetintersectiontypekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4479l in
              heading :: payload
          | Oprayquerygetintersectionworldtoobjectkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6032l in
              heading :: payload
          | Oprayquerygetrayflagskhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6017l in
              heading :: payload
          | Oprayquerygetraytminkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6016l in
              heading :: payload
          | Oprayquerygetworldraydirectionkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6029l in
              heading :: payload
          | Oprayquerygetworldrayoriginkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6030l in
              heading :: payload
          | Oprayqueryinitializekhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.accel;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4473l in
              heading :: payload
          | Oprayqueryislsshitnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5439l in
              heading :: payload
          | Oprayqueryisspherehitnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery;
                  Operand_kind.Payload.Idref.value t.intersection] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5438l in
              heading :: payload
          | Oprayqueryproceedkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.rayquery] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4477l in
              heading :: payload
          | Oprayqueryterminatekhr t ->
              let payload =
                List.concat [Operand_kind.Payload.Idref.value t.rayquery] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4474l in
              heading :: payload
          | Opreadclockkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idscope.value t.scope] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5056l in
              heading :: payload
          | Opreorderthreadwithhintext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hint;
                  Operand_kind.Payload.Idref.value t.bits] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5314l in
              heading :: payload
          | Opreorderthreadwithhintnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hint;
                  Operand_kind.Payload.Idref.value t.bits] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5280l in
              heading :: payload
          | Opreorderthreadwithhitobjectext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5315l in
              heading :: payload
          | Opreorderthreadwithhitobjectnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.hitobject;
                  (t.hint |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.bits |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5279l in
              heading :: payload
          | Opreportintersectionkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.hit;
                  Operand_kind.Payload.Idref.value t.hitkind] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5334l in
              heading :: payload
          | Opsamplerimageaddressingmodenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Literalinteger.value t.bitwidth] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5397l in
              heading :: payload
          | Opsetmeshoutputsext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.vertexcount;
                  Operand_kind.Payload.Idref.value t.primitivecount] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5295l in
              heading :: payload
          | Opspecconstantstringamdx t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalstring.value t.literalstring] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5104l in
              heading :: payload
          | Optensorlayoutsetblocksizenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensorlayout;
                  List.concat_map t.blocksize
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5384l in
              heading :: payload
          | Optensorlayoutsetclampvaluenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensorlayout;
                  Operand_kind.Payload.Idref.value t.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5376l in
              heading :: payload
          | Optensorlayoutsetdimensionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensorlayout;
                  List.concat_map t.dim ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5373l in
              heading :: payload
          | Optensorlayoutsetstridenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensorlayout;
                  List.concat_map t.stride
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5374l in
              heading :: payload
          | Optensorlayoutslicenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensorlayout;
                  List.concat_map t.operands
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5375l in
              heading :: payload
          | Optensorviewsetclipnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensorview;
                  Operand_kind.Payload.Idref.value t.cliprowoffset;
                  Operand_kind.Payload.Idref.value t.cliprowspan;
                  Operand_kind.Payload.Idref.value t.clipcoloffset;
                  Operand_kind.Payload.Idref.value t.clipcolspan] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5382l in
              heading :: payload
          | Optensorviewsetdimensionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensorview;
                  List.concat_map t.dim ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5378l in
              heading :: payload
          | Optensorviewsetstridenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensorview;
                  List.concat_map t.stride
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5379l in
              heading :: payload
          | Opterminateraykhr ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 4449l in
              [heading]
          | Opterminateraynv ->
              let heading =
                let size = (Int.shift_left 1 16) |> Int32.of_int_trunc in
                Int32.bit_or size 5336l in
              [heading]
          | Optracemotionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.accel;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtoffset;
                  Operand_kind.Payload.Idref.value t.sbtstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.time;
                  Operand_kind.Payload.Idref.value t.payloadid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5338l in
              heading :: payload
          | Optracenv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.accel;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtoffset;
                  Operand_kind.Payload.Idref.value t.sbtstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.payloadid] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5337l in
              heading :: payload
          | Optraceraykhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.accel;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtoffset;
                  Operand_kind.Payload.Idref.value t.sbtstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4445l in
              heading :: payload
          | Optraceraymotionnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.accel;
                  Operand_kind.Payload.Idref.value t.rayflags;
                  Operand_kind.Payload.Idref.value t.cullmask;
                  Operand_kind.Payload.Idref.value t.sbtoffset;
                  Operand_kind.Payload.Idref.value t.sbtstride;
                  Operand_kind.Payload.Idref.value t.missindex;
                  Operand_kind.Payload.Idref.value t.rayorigin;
                  Operand_kind.Payload.Idref.value t.raytmin;
                  Operand_kind.Payload.Idref.value t.raydirection;
                  Operand_kind.Payload.Idref.value t.raytmax;
                  Operand_kind.Payload.Idref.value t.time;
                  Operand_kind.Payload.Idref.value t.payload] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5339l in
              heading :: payload
          | Optypenodepayloadarrayamdx t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.payloadtype] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5076l in
              heading :: payload
          | Opuaddsatintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5590l in
              heading :: payload
          | Opuaverageintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5592l in
              heading :: payload
          | Opuaverageroundedintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5594l in
              heading :: payload
          | Opucountleadingzerosintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5585l in
              heading :: payload
          | Opucounttrailingzerosintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5586l in
              heading :: payload
          | Opumul32x16intel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5598l in
              heading :: payload
          | Opusubsatintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.operand1;
                  Operand_kind.Payload.Idref.value t.operand2] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5596l in
              heading :: payload
          | Opwritepackedprimitiveindices4x8nv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.indexoffset;
                  Operand_kind.Payload.Idref.value t.packedindices] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5299l in
              heading :: payload
        let any_required_version =
          function
          | Opabsisubintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opabsusubintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opallocatenodepayloadsamdx _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opbegininvocationinterlockext ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconstantstringamdx _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertimagetounv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertsampledimagetounv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertsamplertounv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertutoaccelerationstructurekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertutoimagenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertutosampledimagenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opconvertutosamplernv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixlengthnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixloadnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixmuladdnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativematrixstorenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativevectormatrixmuladdnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativevectormatrixmulnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativevectorouterproductaccumulatenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcooperativevectorreducesumaccumulatenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcreatetensorlayoutnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opcreatetensorviewnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opemitmeshtasksext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opendinvocationinterlockext ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Openqueuenodepayloadsamdx _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opexecutecallablekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opexecutecallablenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfetchmicrotrianglevertexbarycentricnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfetchmicrotrianglevertexpositionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfinishwritingnodepayloadamdx _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfragmentfetchamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opfragmentmaskfetchamd _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectexecuteshaderext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectexecuteshadernv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetattributesext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetattributesnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetclusteridnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetcurrenttimeext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetcurrenttimenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetgeometryindexext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetgeometryindexnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgethitkindext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgethitkindnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetinstancecustomindexext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetinstancecustomindexnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetinstanceidext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetinstanceidnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetintersectiontrianglevertexpositionsext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetlsspositionsnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetlssradiinv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetobjectraydirectionext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetobjectraydirectionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetobjectrayoriginext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetobjectrayoriginnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetobjecttoworldext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetobjecttoworldnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetprimitiveindexext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetprimitiveindexnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetrayflagsext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetraytmaxext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetraytmaxnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetraytminext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetraytminnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetshaderbindingtablerecordindexext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetshaderbindingtablerecordindexnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetshaderrecordbufferhandleext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetshaderrecordbufferhandlenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetspherepositionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetsphereradiusnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetworldraydirectionext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetworldraydirectionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetworldrayoriginext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetworldrayoriginnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetworldtoobjectext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectgetworldtoobjectnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectisemptyext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectisemptynv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectishitext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectishitnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectislsshitnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectismissext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectismissnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectisspherehitnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordemptyext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordemptynv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordfromqueryext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordhitmotionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordhitnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordhitwithindexmotionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordhitwithindexnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordmissext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordmissmotionext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordmissmotionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectrecordmissnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectreorderexecuteshaderext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjectsetshaderbindingtablerecordindexext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjecttracemotionreorderexecuteext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjecttracerayext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjecttraceraymotionext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjecttraceraymotionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjecttraceraynv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Ophitobjecttracereorderexecuteext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opiaddsatintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opiaverageintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opiaverageroundedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opignoreintersectionkhr ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opignoreintersectionnv ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opimul32x16intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opishelperinvocationext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisnodepayloadvalidamdx _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opisubsatintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oploopcontrolintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opnodepayloadarraylengthamdx _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayqueryconfirmintersectionkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygenerateintersectionkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionbarycentricskhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectioncandidateaabbopaquekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionclusteridnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionfrontfacekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectiongeometryindexkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectioninstancecustomindexkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectioninstanceidkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionlsshitvaluenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionlsspositionsnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionlssradiinv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionobjectraydirectionkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionobjectrayoriginkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionobjecttoworldkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionprimitiveindexkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionspherepositionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionsphereradiusnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectiontkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectiontrianglevertexpositionskhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectiontypekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetintersectionworldtoobjectkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetrayflagskhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetraytminkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetworldraydirectionkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayquerygetworldrayoriginkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayqueryinitializekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayqueryislsshitnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayqueryisspherehitnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayqueryproceedkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Oprayqueryterminatekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreadclockkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreorderthreadwithhintext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreorderthreadwithhintnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreorderthreadwithhitobjectext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreorderthreadwithhitobjectnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opreportintersectionkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsamplerimageaddressingmodenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opsetmeshoutputsext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opspecconstantstringamdx _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorlayoutsetblocksizenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorlayoutsetclampvaluenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorlayoutsetdimensionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorlayoutsetstridenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorlayoutslicenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorviewsetclipnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorviewsetdimensionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorviewsetstridenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opterminateraykhr ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opterminateraynv ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optracemotionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optracenv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optraceraykhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optraceraymotionnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypenodepayloadarrayamdx _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuaddsatintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuaverageintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opuaverageroundedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opucountleadingzerosintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opucounttrailingzerosintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opumul32x16intel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opusubsatintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Opwritepackedprimitiveindices4x8nv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Opabsisubintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opabsusubintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opallocatenodepayloadsamdx _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opbegininvocationinterlockext ->
              [Requirements.Extension.Spv_ext_fragment_shader_interlock] |>
                Requirements.Extension.Set.of_list
          | Opconstantstringamdx _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconvertimagetounv _ -> [] |> Requirements.Extension.Set.of_list
          | Opconvertsampledimagetounv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconvertsamplertounv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconvertutoaccelerationstructurekhr _ ->
              [Requirements.Extension.Spv_khr_ray_tracing;
              Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Opconvertutoimagenv _ -> [] |> Requirements.Extension.Set.of_list
          | Opconvertutosampledimagenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opconvertutosamplernv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativematrixlengthnv _ ->
              [Requirements.Extension.Spv_nv_cooperative_matrix] |>
                Requirements.Extension.Set.of_list
          | Opcooperativematrixloadnv _ ->
              [Requirements.Extension.Spv_nv_cooperative_matrix] |>
                Requirements.Extension.Set.of_list
          | Opcooperativematrixmuladdnv _ ->
              [Requirements.Extension.Spv_nv_cooperative_matrix] |>
                Requirements.Extension.Set.of_list
          | Opcooperativematrixstorenv _ ->
              [Requirements.Extension.Spv_nv_cooperative_matrix] |>
                Requirements.Extension.Set.of_list
          | Opcooperativevectormatrixmuladdnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativevectormatrixmulnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativevectorouterproductaccumulatenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcooperativevectorreducesumaccumulatenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcreatetensorlayoutnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opcreatetensorviewnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opemitmeshtasksext _ -> [] |> Requirements.Extension.Set.of_list
          | Opendinvocationinterlockext ->
              [Requirements.Extension.Spv_ext_fragment_shader_interlock] |>
                Requirements.Extension.Set.of_list
          | Openqueuenodepayloadsamdx _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opexecutecallablekhr _ ->
              [Requirements.Extension.Spv_khr_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Opexecutecallablenv _ ->
              [Requirements.Extension.Spv_nv_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Opfetchmicrotrianglevertexbarycentricnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfetchmicrotrianglevertexpositionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfinishwritingnodepayloadamdx _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opfragmentfetchamd _ ->
              [Requirements.Extension.Spv_amd_shader_fragment_mask] |>
                Requirements.Extension.Set.of_list
          | Opfragmentmaskfetchamd _ ->
              [Requirements.Extension.Spv_amd_shader_fragment_mask] |>
                Requirements.Extension.Set.of_list
          | Ophitobjectexecuteshaderext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectexecuteshadernv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetattributesext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetattributesnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetclusteridnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetcurrenttimeext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetcurrenttimenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetgeometryindexext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetgeometryindexnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgethitkindext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgethitkindnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetinstancecustomindexext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetinstancecustomindexnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetinstanceidext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetinstanceidnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetintersectiontrianglevertexpositionsext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetlsspositionsnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetlssradiinv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetobjectraydirectionext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetobjectraydirectionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetobjectrayoriginext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetobjectrayoriginnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetobjecttoworldext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetobjecttoworldnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetprimitiveindexext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetprimitiveindexnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetrayflagsext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetraytmaxext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetraytmaxnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetraytminext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetraytminnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetshaderbindingtablerecordindexext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetshaderbindingtablerecordindexnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetshaderrecordbufferhandleext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetshaderrecordbufferhandlenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetspherepositionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetsphereradiusnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetworldraydirectionext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetworldraydirectionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetworldrayoriginext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetworldrayoriginnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetworldtoobjectext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectgetworldtoobjectnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectisemptyext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectisemptynv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectishitext _ -> [] |> Requirements.Extension.Set.of_list
          | Ophitobjectishitnv _ -> [] |> Requirements.Extension.Set.of_list
          | Ophitobjectislsshitnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectismissext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectismissnv _ -> [] |> Requirements.Extension.Set.of_list
          | Ophitobjectisspherehitnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordemptyext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordemptynv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordfromqueryext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordhitmotionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordhitnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordhitwithindexmotionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordhitwithindexnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordmissext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordmissmotionext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordmissmotionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectrecordmissnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectreorderexecuteshaderext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjectsetshaderbindingtablerecordindexext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjecttracemotionreorderexecuteext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjecttracerayext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjecttraceraymotionext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjecttraceraymotionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjecttraceraynv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Ophitobjecttracereorderexecuteext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opiaddsatintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opiaverageintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opiaverageroundedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opignoreintersectionkhr ->
              [Requirements.Extension.Spv_khr_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Opignoreintersectionnv ->
              [Requirements.Extension.Spv_nv_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Opimul32x16intel _ -> [] |> Requirements.Extension.Set.of_list
          | Opishelperinvocationext _ ->
              [Requirements.Extension.Spv_ext_demote_to_helper_invocation] |>
                Requirements.Extension.Set.of_list
          | Opisnodepayloadvalidamdx _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opisubsatintel _ -> [] |> Requirements.Extension.Set.of_list
          | Oploopcontrolintel _ ->
              [Requirements.Extension.Spv_intel_unstructured_loop_controls]
                |> Requirements.Extension.Set.of_list
          | Opnodepayloadarraylengthamdx _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayqueryconfirmintersectionkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygenerateintersectionkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionbarycentricskhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectioncandidateaabbopaquekhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionclusteridnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionfrontfacekhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectiongeometryindexkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectioninstancecustomindexkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectioninstanceidkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionlsshitvaluenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionlsspositionsnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionlssradiinv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionobjectraydirectionkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionobjectrayoriginkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionobjecttoworldkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionprimitiveindexkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionspherepositionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionsphereradiusnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayquerygetintersectiontkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectiontrianglevertexpositionskhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayquerygetintersectiontypekhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetintersectionworldtoobjectkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetrayflagskhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetraytminkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetworldraydirectionkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayquerygetworldrayoriginkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayqueryinitializekhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayqueryislsshitnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayqueryisspherehitnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Oprayqueryproceedkhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Oprayqueryterminatekhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Opreadclockkhr _ -> [] |> Requirements.Extension.Set.of_list
          | Opreorderthreadwithhintext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opreorderthreadwithhintnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opreorderthreadwithhitobjectext _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opreorderthreadwithhitobjectnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opreportintersectionkhr _ ->
              [Requirements.Extension.Spv_nv_ray_tracing;
              Requirements.Extension.Spv_khr_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Opsamplerimageaddressingmodenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opsetmeshoutputsext _ -> [] |> Requirements.Extension.Set.of_list
          | Opspecconstantstringamdx _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorlayoutsetblocksizenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorlayoutsetclampvaluenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorlayoutsetdimensionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorlayoutsetstridenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorlayoutslicenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorviewsetclipnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorviewsetdimensionnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorviewsetstridenv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opterminateraykhr ->
              [Requirements.Extension.Spv_khr_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Opterminateraynv ->
              [Requirements.Extension.Spv_nv_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Optracemotionnv _ ->
              [Requirements.Extension.Spv_nv_ray_tracing_motion_blur] |>
                Requirements.Extension.Set.of_list
          | Optracenv _ ->
              [Requirements.Extension.Spv_nv_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Optraceraykhr _ ->
              [Requirements.Extension.Spv_khr_ray_tracing] |>
                Requirements.Extension.Set.of_list
          | Optraceraymotionnv _ ->
              [Requirements.Extension.Spv_nv_ray_tracing_motion_blur] |>
                Requirements.Extension.Set.of_list
          | Optypenodepayloadarrayamdx _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opuaddsatintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opuaverageintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opuaverageroundedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opucountleadingzerosintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opucounttrailingzerosintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Opumul32x16intel _ -> [] |> Requirements.Extension.Set.of_list
          | Opusubsatintel _ -> [] |> Requirements.Extension.Set.of_list
          | Opwritepackedprimitiveindices4x8nv _ ->
              [Requirements.Extension.Spv_nv_mesh_shader] |>
                Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Opabsisubintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opabsusubintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opallocatenodepayloadsamdx _ ->
              [Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opbegininvocationinterlockext ->
              [Operand_kind.Payload.Capability.Fragmentshadersampleinterlockext;
              Operand_kind.Payload.Capability.Fragmentshaderpixelinterlockext;
              Operand_kind.Payload.Capability.Fragmentshadershadingrateinterlockext]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opconstantstringamdx _ ->
              [Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertimagetounv _ ->
              [Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertsampledimagetounv _ ->
              [Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertsamplertounv _ ->
              [Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertutoaccelerationstructurekhr _ ->
              [Operand_kind.Payload.Capability.Raytracingkhr;
              Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertutoimagenv _ ->
              [Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertutosampledimagenv _ ->
              [Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opconvertutosamplernv _ ->
              [Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixlengthnv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixloadnv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixmuladdnv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativematrixstorenv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativevectormatrixmuladdnv _ ->
              [Operand_kind.Payload.Capability.Cooperativevectornv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativevectormatrixmulnv _ ->
              [Operand_kind.Payload.Capability.Cooperativevectornv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativevectorouterproductaccumulatenv _ ->
              [Operand_kind.Payload.Capability.Cooperativevectortrainingnv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opcooperativevectorreducesumaccumulatenv _ ->
              [Operand_kind.Payload.Capability.Cooperativevectortrainingnv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opcreatetensorlayoutnv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opcreatetensorviewnv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opemitmeshtasksext _ ->
              [Operand_kind.Payload.Capability.Meshshadingext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opendinvocationinterlockext ->
              [Operand_kind.Payload.Capability.Fragmentshadersampleinterlockext;
              Operand_kind.Payload.Capability.Fragmentshaderpixelinterlockext;
              Operand_kind.Payload.Capability.Fragmentshadershadingrateinterlockext]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Openqueuenodepayloadsamdx _ ->
              [Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opexecutecallablekhr _ ->
              [Operand_kind.Payload.Capability.Raytracingkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opexecutecallablenv _ ->
              [Operand_kind.Payload.Capability.Raytracingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfetchmicrotrianglevertexbarycentricnv _ ->
              [Operand_kind.Payload.Capability.Displacementmicromapnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfetchmicrotrianglevertexpositionnv _ ->
              [Operand_kind.Payload.Capability.Displacementmicromapnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfinishwritingnodepayloadamdx _ ->
              [Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfragmentfetchamd _ ->
              [Operand_kind.Payload.Capability.Fragmentmaskamd] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opfragmentmaskfetchamd _ ->
              [Operand_kind.Payload.Capability.Fragmentmaskamd] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectexecuteshaderext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectexecuteshadernv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetattributesext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetattributesnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetclusteridnv _ ->
              [Operand_kind.Payload.Capability.Raytracingclusteraccelerationstructurenv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetcurrenttimeext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext;
              Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetcurrenttimenv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetgeometryindexext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetgeometryindexnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgethitkindext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgethitkindnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetinstancecustomindexext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetinstancecustomindexnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetinstanceidext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetinstanceidnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetintersectiontrianglevertexpositionsext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetlsspositionsnv _ ->
              [Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetlssradiinv _ ->
              [Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetobjectraydirectionext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetobjectraydirectionnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetobjectrayoriginext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetobjectrayoriginnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetobjecttoworldext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetobjecttoworldnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetprimitiveindexext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetprimitiveindexnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetrayflagsext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetraytmaxext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetraytmaxnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetraytminext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetraytminnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetshaderbindingtablerecordindexext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetshaderbindingtablerecordindexnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetshaderrecordbufferhandleext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetshaderrecordbufferhandlenv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetspherepositionnv _ ->
              [Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetsphereradiusnv _ ->
              [Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetworldraydirectionext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetworldraydirectionnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetworldrayoriginext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetworldrayoriginnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetworldtoobjectext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectgetworldtoobjectnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectisemptyext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectisemptynv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectishitext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectishitnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectislsshitnv _ ->
              [Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectismissext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectismissnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectisspherehitnv _ ->
              [Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordemptyext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordemptynv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordfromqueryext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordhitmotionnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv;
              Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordhitnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordhitwithindexmotionnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv;
              Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordhitwithindexnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordmissext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordmissmotionext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext;
              Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordmissmotionnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv;
              Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectrecordmissnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectreorderexecuteshaderext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjectsetshaderbindingtablerecordindexext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjecttracemotionreorderexecuteext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext;
              Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjecttracerayext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjecttraceraymotionext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext;
              Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjecttraceraymotionnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv;
              Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjecttraceraynv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Ophitobjecttracereorderexecuteext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opiaddsatintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opiaverageintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opiaverageroundedintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opignoreintersectionkhr ->
              [Operand_kind.Payload.Capability.Raytracingkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opignoreintersectionnv ->
              [Operand_kind.Payload.Capability.Raytracingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opimul32x16intel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opishelperinvocationext _ ->
              [Operand_kind.Payload.Capability.Demotetohelperinvocation] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opisnodepayloadvalidamdx _ ->
              [Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opisubsatintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oploopcontrolintel _ ->
              [Operand_kind.Payload.Capability.Unstructuredloopcontrolsintel]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Opnodepayloadarraylengthamdx _ ->
              [Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayqueryconfirmintersectionkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygenerateintersectionkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionbarycentricskhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectioncandidateaabbopaquekhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionclusteridnv _ ->
              [Operand_kind.Payload.Capability.Raytracingclusteraccelerationstructurenv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionfrontfacekhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectiongeometryindexkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectioninstancecustomindexkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectioninstanceidkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectioninstanceshaderbindingtablerecordoffsetkhr
              _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionlsshitvaluenv _ ->
              [Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionlsspositionsnv _ ->
              [Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionlssradiinv _ ->
              [Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionobjectraydirectionkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionobjectrayoriginkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionobjecttoworldkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionprimitiveindexkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionspherepositionnv _ ->
              [Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionsphereradiusnv _ ->
              [Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectiontkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectiontrianglevertexpositionskhr _ ->
              [Operand_kind.Payload.Capability.Rayquerypositionfetchkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectiontypekhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetintersectionworldtoobjectkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetrayflagskhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetraytminkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetworldraydirectionkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayquerygetworldrayoriginkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayqueryinitializekhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayqueryislsshitnv _ ->
              [Operand_kind.Payload.Capability.Raytracinglinearsweptspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oprayqueryisspherehitnv _ ->
              [Operand_kind.Payload.Capability.Raytracingspheresgeometrynv]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Oprayqueryproceedkhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Oprayqueryterminatekhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreadclockkhr _ ->
              [Operand_kind.Payload.Capability.Shaderclockkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreorderthreadwithhintext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreorderthreadwithhintnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreorderthreadwithhitobjectext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreorderthreadwithhitobjectnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opreportintersectionkhr _ ->
              [Operand_kind.Payload.Capability.Raytracingnv;
              Operand_kind.Payload.Capability.Raytracingkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsamplerimageaddressingmodenv _ ->
              [Operand_kind.Payload.Capability.Bindlesstexturenv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opsetmeshoutputsext _ ->
              [Operand_kind.Payload.Capability.Meshshadingext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opspecconstantstringamdx _ ->
              [Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorlayoutsetblocksizenv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorlayoutsetclampvaluenv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorlayoutsetdimensionnv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorlayoutsetstridenv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorlayoutslicenv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorviewsetclipnv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorviewsetdimensionnv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorviewsetstridenv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opterminateraykhr ->
              [Operand_kind.Payload.Capability.Raytracingkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opterminateraynv ->
              [Operand_kind.Payload.Capability.Raytracingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optracemotionnv _ ->
              [Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optracenv _ ->
              [Operand_kind.Payload.Capability.Raytracingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optraceraykhr _ ->
              [Operand_kind.Payload.Capability.Raytracingkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optraceraymotionnv _ ->
              [Operand_kind.Payload.Capability.Raytracingmotionblurnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypenodepayloadarrayamdx _ ->
              [Operand_kind.Payload.Capability.Shaderenqueueamdx] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuaddsatintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuaverageintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opuaverageroundedintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opucountleadingzerosintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opucounttrailingzerosintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opumul32x16intel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opusubsatintel _ ->
              [Operand_kind.Payload.Capability.Integerfunctions2intel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Opwritepackedprimitiveindices4x8nv _ ->
              [Operand_kind.Payload.Capability.Meshshadingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Tensor =
      struct
        type t =
          | Optensorquerysizearm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensor: Operand_kind.Payload.Idref.t ;
          dimension: Operand_kind.Payload.Idref.t } 
          | Optensorreadarm of
          {
          idresulttype: Operand_kind.Payload.Idresulttype.t ;
          idresult: Operand_kind.Payload.Idresult.t ;
          tensor: Operand_kind.Payload.Idref.t ;
          coordinates: Operand_kind.Payload.Idref.t ;
          tensoroperands: Operand_kind.Payload.Tensoroperands.t option } 
          | Optensorwritearm of
          {
          tensor: Operand_kind.Payload.Idref.t ;
          coordinates: Operand_kind.Payload.Idref.t ;
          object_: Operand_kind.Payload.Idref.t ;
          tensoroperands: Operand_kind.Payload.Tensoroperands.t option } 
        [@@deriving compare, sexp_of]
        let provisional =
          function
          | Optensorquerysizearm _ -> false
          | Optensorreadarm _ -> false
          | Optensorwritearm _ -> false
        let value =
          function
          | Optensorquerysizearm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensor;
                  Operand_kind.Payload.Idref.value t.dimension] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4166l in
              heading :: payload
          | Optensorreadarm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresulttype.value t.idresulttype;
                  Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.tensor;
                  Operand_kind.Payload.Idref.value t.coordinates;
                  (t.tensoroperands |>
                     (Option.map ~f:Operand_kind.Payload.Tensoroperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4164l in
              heading :: payload
          | Optensorwritearm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.tensor;
                  Operand_kind.Payload.Idref.value t.coordinates;
                  Operand_kind.Payload.Idref.value t.object_;
                  (t.tensoroperands |>
                     (Option.map ~f:Operand_kind.Payload.Tensoroperands.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4165l in
              heading :: payload
        let any_required_version =
          function
          | Optensorquerysizearm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorreadarm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optensorwritearm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Optensorquerysizearm _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optensorreadarm _ -> [] |> Requirements.Extension.Set.of_list
          | Optensorwritearm _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Optensorquerysizearm _ ->
              [Operand_kind.Payload.Capability.Tensorsarm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorreadarm _ ->
              [Operand_kind.Payload.Capability.Tensorsarm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optensorwritearm _ ->
              [Operand_kind.Payload.Capability.Tensorsarm] |>
                Operand_kind.Payload.Capability.Set.of_list
      end
    module Type_declaration =
      struct
        type t =
          | Optypeaccelerationstructurekhr of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypearray of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          elementtype: Operand_kind.Payload.Idref.t ;
          length: Operand_kind.Payload.Idref.t } 
          | Optypebool of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypebuffersurfaceintel of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          accessqualifier: Operand_kind.Payload.Accessqualifier.t } 
          | Optypecooperativematrixkhr of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          componenttype: Operand_kind.Payload.Idref.t ;
          scope: Operand_kind.Payload.Idscope.t ;
          rows: Operand_kind.Payload.Idref.t ;
          columns: Operand_kind.Payload.Idref.t ;
          use: Operand_kind.Payload.Idref.t } 
          | Optypecooperativematrixnv of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          componenttype: Operand_kind.Payload.Idref.t ;
          execution: Operand_kind.Payload.Idscope.t ;
          rows: Operand_kind.Payload.Idref.t ;
          columns: Operand_kind.Payload.Idref.t } 
          | Optypedeviceevent of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeevent of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypefloat of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          width: Operand_kind.Payload.Literalinteger.t ;
          floatingpointencoding: Operand_kind.Payload.Fpencoding.t option } 
          | Optypeforwardpointer of
          {
          pointertype: Operand_kind.Payload.Idref.t ;
          storageclass: Operand_kind.Payload.Storageclass.t } 
          | Optypefunction of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          returntype: Operand_kind.Payload.Idref.t ;
          parameter0typeparameter1type___: Operand_kind.Payload.Idref.t list }
          
          | Optypegrapharm of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          numinputs: Operand_kind.Payload.Literalinteger.t ;
          inouttypes: Operand_kind.Payload.Idref.t list } 
          | Optypehitobjectext of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypehitobjectnv of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeimage of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          sampledtype: Operand_kind.Payload.Idref.t ;
          dim: Operand_kind.Payload.Dim.t ;
          depth: Operand_kind.Payload.Literalinteger.t ;
          arrayed: Operand_kind.Payload.Literalinteger.t ;
          ms: Operand_kind.Payload.Literalinteger.t ;
          sampled: Operand_kind.Payload.Literalinteger.t ;
          imageformat: Operand_kind.Payload.Imageformat.t ;
          accessqualifier: Operand_kind.Payload.Accessqualifier.t option } 
          | Optypeint of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          width: Operand_kind.Payload.Literalinteger.t ;
          signedness: Operand_kind.Payload.Literalinteger.t } 
          | Optypematrix of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          columntype: Operand_kind.Payload.Idref.t ;
          columncount: Operand_kind.Payload.Literalinteger.t } 
          | Optypenamedbarrier of
          {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypeopaque of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          thenameoftheopaquetype_: Operand_kind.Payload.Literalstring.t } 
          | Optypepipe of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          qualifier: Operand_kind.Payload.Accessqualifier.t } 
          | Optypepipestorage of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypepointer of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          storageclass: Operand_kind.Payload.Storageclass.t ;
          type_: Operand_kind.Payload.Idref.t } 
          | Optypequeue of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optyperayquerykhr of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypereserveid of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optyperuntimearray of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          elementtype: Operand_kind.Payload.Idref.t } 
          | Optypesampledimage of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          imagetype: Operand_kind.Payload.Idref.t } 
          | Optypesampler of {
          idresult: Operand_kind.Payload.Idresult.t } 
          | Optypestruct of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          member0typemember1type___: Operand_kind.Payload.Idref.t list } 
          | Optypestructcontinuedintel of
          {
          member0typemember1type___: Operand_kind.Payload.Idref.t list } 
          | Optypetensorarm of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          elementtype: Operand_kind.Payload.Idref.t ;
          rank: Operand_kind.Payload.Idref.t option ;
          shape: Operand_kind.Payload.Idref.t option } 
          | Optypetensorlayoutnv of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          dim: Operand_kind.Payload.Idref.t ;
          clampmode: Operand_kind.Payload.Idref.t } 
          | Optypetensorviewnv of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          dim: Operand_kind.Payload.Idref.t ;
          hasdimensions: Operand_kind.Payload.Idref.t ;
          p: Operand_kind.Payload.Idref.t list } 
          | Optypeuntypedpointerkhr of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          storageclass: Operand_kind.Payload.Storageclass.t } 
          | Optypevector of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          componenttype: Operand_kind.Payload.Idref.t ;
          componentcount: Operand_kind.Payload.Literalinteger.t } 
          | Optypevectoridext of
          {
          idresult: Operand_kind.Payload.Idresult.t ;
          componenttype: Operand_kind.Payload.Idref.t ;
          componentcount: Operand_kind.Payload.Idref.t } 
          | Optypevoid of {
          idresult: Operand_kind.Payload.Idresult.t } [@@deriving
                                                        compare, sexp_of]
        let provisional =
          function
          | Optypeaccelerationstructurekhr _ -> false
          | Optypearray _ -> false
          | Optypebool _ -> false
          | Optypebuffersurfaceintel _ -> false
          | Optypecooperativematrixkhr _ -> false
          | Optypecooperativematrixnv _ -> false
          | Optypedeviceevent _ -> false
          | Optypeevent _ -> false
          | Optypefloat _ -> false
          | Optypeforwardpointer _ -> false
          | Optypefunction _ -> false
          | Optypegrapharm _ -> false
          | Optypehitobjectext _ -> false
          | Optypehitobjectnv _ -> false
          | Optypeimage _ -> false
          | Optypeint _ -> false
          | Optypematrix _ -> false
          | Optypenamedbarrier _ -> false
          | Optypeopaque _ -> false
          | Optypepipe _ -> false
          | Optypepipestorage _ -> false
          | Optypepointer _ -> false
          | Optypequeue _ -> false
          | Optyperayquerykhr _ -> false
          | Optypereserveid _ -> false
          | Optyperuntimearray _ -> false
          | Optypesampledimage _ -> false
          | Optypesampler _ -> false
          | Optypestruct _ -> false
          | Optypestructcontinuedintel _ -> false
          | Optypetensorarm _ -> false
          | Optypetensorlayoutnv _ -> false
          | Optypetensorviewnv _ -> false
          | Optypeuntypedpointerkhr _ -> false
          | Optypevector _ -> false
          | Optypevectoridext _ -> false
          | Optypevoid _ -> false
        let value =
          function
          | Optypeaccelerationstructurekhr t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5341l in
              heading :: payload
          | Optypearray t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.elementtype;
                  Operand_kind.Payload.Idref.value t.length] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 28l in
              heading :: payload
          | Optypebool t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 20l in
              heading :: payload
          | Optypebuffersurfaceintel t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Accessqualifier.value
                    t.accessqualifier] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6086l in
              heading :: payload
          | Optypecooperativematrixkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.componenttype;
                  Operand_kind.Payload.Idscope.value t.scope;
                  Operand_kind.Payload.Idref.value t.rows;
                  Operand_kind.Payload.Idref.value t.columns;
                  Operand_kind.Payload.Idref.value t.use] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4456l in
              heading :: payload
          | Optypecooperativematrixnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.componenttype;
                  Operand_kind.Payload.Idscope.value t.execution;
                  Operand_kind.Payload.Idref.value t.rows;
                  Operand_kind.Payload.Idref.value t.columns] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5358l in
              heading :: payload
          | Optypedeviceevent t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 35l in
              heading :: payload
          | Optypeevent t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 34l in
              heading :: payload
          | Optypefloat t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalinteger.value t.width;
                  (t.floatingpointencoding |>
                     (Option.map ~f:Operand_kind.Payload.Fpencoding.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 22l in
              heading :: payload
          | Optypeforwardpointer t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idref.value t.pointertype;
                  Operand_kind.Payload.Storageclass.value t.storageclass] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 39l in
              heading :: payload
          | Optypefunction t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.returntype;
                  List.concat_map t.parameter0typeparameter1type___
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 33l in
              heading :: payload
          | Optypegrapharm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalinteger.value t.numinputs;
                  List.concat_map t.inouttypes
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4190l in
              heading :: payload
          | Optypehitobjectext t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5313l in
              heading :: payload
          | Optypehitobjectnv t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5281l in
              heading :: payload
          | Optypeimage t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.sampledtype;
                  Operand_kind.Payload.Dim.value t.dim;
                  Operand_kind.Payload.Literalinteger.value t.depth;
                  Operand_kind.Payload.Literalinteger.value t.arrayed;
                  Operand_kind.Payload.Literalinteger.value t.ms;
                  Operand_kind.Payload.Literalinteger.value t.sampled;
                  Operand_kind.Payload.Imageformat.value t.imageformat;
                  (t.accessqualifier |>
                     (Option.map
                        ~f:Operand_kind.Payload.Accessqualifier.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 25l in
              heading :: payload
          | Optypeint t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalinteger.value t.width;
                  Operand_kind.Payload.Literalinteger.value t.signedness] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 21l in
              heading :: payload
          | Optypematrix t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.columntype;
                  Operand_kind.Payload.Literalinteger.value t.columncount] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 24l in
              heading :: payload
          | Optypenamedbarrier t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 327l in
              heading :: payload
          | Optypeopaque t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Literalstring.value
                    t.thenameoftheopaquetype_] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 31l in
              heading :: payload
          | Optypepipe t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Accessqualifier.value t.qualifier] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 38l in
              heading :: payload
          | Optypepipestorage t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 322l in
              heading :: payload
          | Optypepointer t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Storageclass.value t.storageclass;
                  Operand_kind.Payload.Idref.value t.type_] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 32l in
              heading :: payload
          | Optypequeue t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 37l in
              heading :: payload
          | Optyperayquerykhr t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4472l in
              heading :: payload
          | Optypereserveid t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 36l in
              heading :: payload
          | Optyperuntimearray t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.elementtype] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 29l in
              heading :: payload
          | Optypesampledimage t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.imagetype] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 27l in
              heading :: payload
          | Optypesampler t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 26l in
              heading :: payload
          | Optypestruct t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  List.concat_map t.member0typemember1type___
                    ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 30l in
              heading :: payload
          | Optypestructcontinuedintel t ->
              let payload =
                List.concat
                  [List.concat_map t.member0typemember1type___
                     ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 6090l in
              heading :: payload
          | Optypetensorarm t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.elementtype;
                  (t.rank |> (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[]);
                  (t.shape |>
                     (Option.map ~f:Operand_kind.Payload.Idref.value))
                    |> (Option.value ~default:[])] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4163l in
              heading :: payload
          | Optypetensorlayoutnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.dim;
                  Operand_kind.Payload.Idref.value t.clampmode] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5370l in
              heading :: payload
          | Optypetensorviewnv t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.dim;
                  Operand_kind.Payload.Idref.value t.hasdimensions;
                  List.concat_map t.p ~f:Operand_kind.Payload.Idref.value] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5371l in
              heading :: payload
          | Optypeuntypedpointerkhr t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Storageclass.value t.storageclass] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 4417l in
              heading :: payload
          | Optypevector t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.componenttype;
                  Operand_kind.Payload.Literalinteger.value t.componentcount] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 23l in
              heading :: payload
          | Optypevectoridext t ->
              let payload =
                List.concat
                  [Operand_kind.Payload.Idresult.value t.idresult;
                  Operand_kind.Payload.Idref.value t.componenttype;
                  Operand_kind.Payload.Idref.value t.componentcount] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 5288l in
              heading :: payload
          | Optypevoid t ->
              let payload =
                List.concat [Operand_kind.Payload.Idresult.value t.idresult] in
              let heading =
                let size =
                  (Int.shift_left (1 + (List.length payload)) 16) |>
                    Int32.of_int_trunc in
                Int32.bit_or size 19l in
              heading :: payload
        let any_required_version =
          function
          | Optypeaccelerationstructurekhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypearray _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypebool _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypebuffersurfaceintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypecooperativematrixkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypecooperativematrixnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypedeviceevent _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeevent _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypefloat _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeforwardpointer _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypefunction _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypegrapharm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypehitobjectext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypehitobjectnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeimage _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeint _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypematrix _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypenamedbarrier _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeopaque _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypepipe _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypepipestorage _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_1)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypepointer _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypequeue _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optyperayquerykhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypereserveid _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optyperuntimearray _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypesampledimage _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypesampler _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypestruct _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypestructcontinuedintel _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypetensorarm _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypetensorlayoutnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypetensorviewnv _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypeuntypedpointerkhr _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypevector _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypevectoridext _ ->
              (Requirements.Version.valid_versions ~required:None ~last:None)
                |> Requirements.Version.Set.of_list
          | Optypevoid _ ->
              (Requirements.Version.valid_versions ~required:(Some V1_0)
                 ~last:None)
                |> Requirements.Version.Set.of_list
        let any_required_extension =
          function
          | Optypeaccelerationstructurekhr _ ->
              [Requirements.Extension.Spv_nv_ray_tracing;
              Requirements.Extension.Spv_khr_ray_tracing;
              Requirements.Extension.Spv_khr_ray_query;
              Requirements.Extension.Spv_nv_displacement_micromap] |>
                Requirements.Extension.Set.of_list
          | Optypearray _ -> [] |> Requirements.Extension.Set.of_list
          | Optypebool _ -> [] |> Requirements.Extension.Set.of_list
          | Optypebuffersurfaceintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypecooperativematrixkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypecooperativematrixnv _ ->
              [Requirements.Extension.Spv_nv_cooperative_matrix] |>
                Requirements.Extension.Set.of_list
          | Optypedeviceevent _ -> [] |> Requirements.Extension.Set.of_list
          | Optypeevent _ -> [] |> Requirements.Extension.Set.of_list
          | Optypefloat _ -> [] |> Requirements.Extension.Set.of_list
          | Optypeforwardpointer _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypefunction _ -> [] |> Requirements.Extension.Set.of_list
          | Optypegrapharm _ -> [] |> Requirements.Extension.Set.of_list
          | Optypehitobjectext _ -> [] |> Requirements.Extension.Set.of_list
          | Optypehitobjectnv _ -> [] |> Requirements.Extension.Set.of_list
          | Optypeimage _ -> [] |> Requirements.Extension.Set.of_list
          | Optypeint _ -> [] |> Requirements.Extension.Set.of_list
          | Optypematrix _ -> [] |> Requirements.Extension.Set.of_list
          | Optypenamedbarrier _ -> [] |> Requirements.Extension.Set.of_list
          | Optypeopaque _ -> [] |> Requirements.Extension.Set.of_list
          | Optypepipe _ -> [] |> Requirements.Extension.Set.of_list
          | Optypepipestorage _ -> [] |> Requirements.Extension.Set.of_list
          | Optypepointer _ -> [] |> Requirements.Extension.Set.of_list
          | Optypequeue _ -> [] |> Requirements.Extension.Set.of_list
          | Optyperayquerykhr _ ->
              [Requirements.Extension.Spv_khr_ray_query] |>
                Requirements.Extension.Set.of_list
          | Optypereserveid _ -> [] |> Requirements.Extension.Set.of_list
          | Optyperuntimearray _ -> [] |> Requirements.Extension.Set.of_list
          | Optypesampledimage _ -> [] |> Requirements.Extension.Set.of_list
          | Optypesampler _ -> [] |> Requirements.Extension.Set.of_list
          | Optypestruct _ -> [] |> Requirements.Extension.Set.of_list
          | Optypestructcontinuedintel _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypetensorarm _ -> [] |> Requirements.Extension.Set.of_list
          | Optypetensorlayoutnv _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypetensorviewnv _ -> [] |> Requirements.Extension.Set.of_list
          | Optypeuntypedpointerkhr _ ->
              [] |> Requirements.Extension.Set.of_list
          | Optypevector _ -> [] |> Requirements.Extension.Set.of_list
          | Optypevectoridext _ -> [] |> Requirements.Extension.Set.of_list
          | Optypevoid _ -> [] |> Requirements.Extension.Set.of_list
        let any_required_capability =
          function
          | Optypeaccelerationstructurekhr _ ->
              [Operand_kind.Payload.Capability.Raytracingnv;
              Operand_kind.Payload.Capability.Raytracingkhr;
              Operand_kind.Payload.Capability.Rayquerykhr;
              Operand_kind.Payload.Capability.Displacementmicromapnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypearray _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypebool _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypebuffersurfaceintel _ ->
              [Operand_kind.Payload.Capability.Vectorcomputeintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypecooperativematrixkhr _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixkhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypecooperativematrixnv _ ->
              [Operand_kind.Payload.Capability.Cooperativematrixnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypedeviceevent _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypeevent _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypefloat _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeforwardpointer _ ->
              [Operand_kind.Payload.Capability.Addresses;
              Operand_kind.Payload.Capability.Physicalstoragebufferaddresses]
                |> Operand_kind.Payload.Capability.Set.of_list
          | Optypefunction _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypegrapharm _ ->
              [Operand_kind.Payload.Capability.Grapharm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypehitobjectext _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreorderext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypehitobjectnv _ ->
              [Operand_kind.Payload.Capability.Shaderinvocationreordernv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypeimage _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypeint _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypematrix _ ->
              [Operand_kind.Payload.Capability.Matrix] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypenamedbarrier _ ->
              [Operand_kind.Payload.Capability.Namedbarrier] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypeopaque _ ->
              [Operand_kind.Payload.Capability.Kernel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypepipe _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypepipestorage _ ->
              [Operand_kind.Payload.Capability.Pipestorage] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypepointer _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypequeue _ ->
              [Operand_kind.Payload.Capability.Deviceenqueue] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optyperayquerykhr _ ->
              [Operand_kind.Payload.Capability.Rayquerykhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypereserveid _ ->
              [Operand_kind.Payload.Capability.Pipes] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optyperuntimearray _ ->
              [Operand_kind.Payload.Capability.Shader] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypesampledimage _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypesampler _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypestruct _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypestructcontinuedintel _ ->
              [Operand_kind.Payload.Capability.Longcompositesintel] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypetensorarm _ ->
              [Operand_kind.Payload.Capability.Tensorsarm] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypetensorlayoutnv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypetensorviewnv _ ->
              [Operand_kind.Payload.Capability.Tensoraddressingnv] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypeuntypedpointerkhr _ ->
              [Operand_kind.Payload.Capability.Untypedpointerskhr] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypevector _ ->
              [] |> Operand_kind.Payload.Capability.Set.of_list
          | Optypevectoridext _ ->
              [Operand_kind.Payload.Capability.Cooperativevectornv;
              Operand_kind.Payload.Capability.Longvectorext] |>
                Operand_kind.Payload.Capability.Set.of_list
          | Optypevoid _ -> [] |> Operand_kind.Payload.Capability.Set.of_list
      end
    type t =
      | Annotation of Annotation.t 
      | Arithmetic of Arithmetic.t 
      | Atomic of Atomic.t 
      | Barrier of Barrier.t 
      | Bit of Bit.t 
      | Composite of Composite.t 
      | Constant_creation of Constant_creation.t 
      | Control_flow of Control_flow.t 
      | Conversion of Conversion.t 
      | Debug of Debug.t 
      | Derivative of Derivative.t 
      | Device_side_enqueue of Device_side_enqueue.t 
      | Exclude of Exclude.t 
      | Extension of Extension.t 
      | Function of Function.t 
      | Graph of Graph.t 
      | Group of Group.t 
      | Image of Image.t 
      | Memory of Memory.t 
      | Miscellaneous of Miscellaneous.t 
      | Mode_setting of Mode_setting.t 
      | Non_uniform of Non_uniform.t 
      | Pipe of Pipe.t 
      | Primitive of Primitive.t 
      | Relational_and_logical of Relational_and_logical.t 
      | Reserved of Reserved.t 
      | Tensor of Tensor.t 
      | Type_declaration of Type_declaration.t [@@deriving compare, sexp_of]
    let provisional =
      function
      | Annotation t -> Annotation.provisional t
      | Arithmetic t -> Arithmetic.provisional t
      | Atomic t -> Atomic.provisional t
      | Barrier t -> Barrier.provisional t
      | Bit t -> Bit.provisional t
      | Composite t -> Composite.provisional t
      | Constant_creation t -> Constant_creation.provisional t
      | Control_flow t -> Control_flow.provisional t
      | Conversion t -> Conversion.provisional t
      | Debug t -> Debug.provisional t
      | Derivative t -> Derivative.provisional t
      | Device_side_enqueue t -> Device_side_enqueue.provisional t
      | Exclude t -> Exclude.provisional t
      | Extension t -> Extension.provisional t
      | Function t -> Function.provisional t
      | Graph t -> Graph.provisional t
      | Group t -> Group.provisional t
      | Image t -> Image.provisional t
      | Memory t -> Memory.provisional t
      | Miscellaneous t -> Miscellaneous.provisional t
      | Mode_setting t -> Mode_setting.provisional t
      | Non_uniform t -> Non_uniform.provisional t
      | Pipe t -> Pipe.provisional t
      | Primitive t -> Primitive.provisional t
      | Relational_and_logical t -> Relational_and_logical.provisional t
      | Reserved t -> Reserved.provisional t
      | Tensor t -> Tensor.provisional t
      | Type_declaration t -> Type_declaration.provisional t
    let value =
      function
      | Annotation t -> Annotation.value t
      | Arithmetic t -> Arithmetic.value t
      | Atomic t -> Atomic.value t
      | Barrier t -> Barrier.value t
      | Bit t -> Bit.value t
      | Composite t -> Composite.value t
      | Constant_creation t -> Constant_creation.value t
      | Control_flow t -> Control_flow.value t
      | Conversion t -> Conversion.value t
      | Debug t -> Debug.value t
      | Derivative t -> Derivative.value t
      | Device_side_enqueue t -> Device_side_enqueue.value t
      | Exclude t -> Exclude.value t
      | Extension t -> Extension.value t
      | Function t -> Function.value t
      | Graph t -> Graph.value t
      | Group t -> Group.value t
      | Image t -> Image.value t
      | Memory t -> Memory.value t
      | Miscellaneous t -> Miscellaneous.value t
      | Mode_setting t -> Mode_setting.value t
      | Non_uniform t -> Non_uniform.value t
      | Pipe t -> Pipe.value t
      | Primitive t -> Primitive.value t
      | Relational_and_logical t -> Relational_and_logical.value t
      | Reserved t -> Reserved.value t
      | Tensor t -> Tensor.value t
      | Type_declaration t -> Type_declaration.value t
    let any_required_version =
      function
      | Annotation t -> Annotation.any_required_version t
      | Arithmetic t -> Arithmetic.any_required_version t
      | Atomic t -> Atomic.any_required_version t
      | Barrier t -> Barrier.any_required_version t
      | Bit t -> Bit.any_required_version t
      | Composite t -> Composite.any_required_version t
      | Constant_creation t -> Constant_creation.any_required_version t
      | Control_flow t -> Control_flow.any_required_version t
      | Conversion t -> Conversion.any_required_version t
      | Debug t -> Debug.any_required_version t
      | Derivative t -> Derivative.any_required_version t
      | Device_side_enqueue t -> Device_side_enqueue.any_required_version t
      | Exclude t -> Exclude.any_required_version t
      | Extension t -> Extension.any_required_version t
      | Function t -> Function.any_required_version t
      | Graph t -> Graph.any_required_version t
      | Group t -> Group.any_required_version t
      | Image t -> Image.any_required_version t
      | Memory t -> Memory.any_required_version t
      | Miscellaneous t -> Miscellaneous.any_required_version t
      | Mode_setting t -> Mode_setting.any_required_version t
      | Non_uniform t -> Non_uniform.any_required_version t
      | Pipe t -> Pipe.any_required_version t
      | Primitive t -> Primitive.any_required_version t
      | Relational_and_logical t ->
          Relational_and_logical.any_required_version t
      | Reserved t -> Reserved.any_required_version t
      | Tensor t -> Tensor.any_required_version t
      | Type_declaration t -> Type_declaration.any_required_version t
    let any_required_capability =
      function
      | Annotation t -> Annotation.any_required_capability t
      | Arithmetic t -> Arithmetic.any_required_capability t
      | Atomic t -> Atomic.any_required_capability t
      | Barrier t -> Barrier.any_required_capability t
      | Bit t -> Bit.any_required_capability t
      | Composite t -> Composite.any_required_capability t
      | Constant_creation t -> Constant_creation.any_required_capability t
      | Control_flow t -> Control_flow.any_required_capability t
      | Conversion t -> Conversion.any_required_capability t
      | Debug t -> Debug.any_required_capability t
      | Derivative t -> Derivative.any_required_capability t
      | Device_side_enqueue t ->
          Device_side_enqueue.any_required_capability t
      | Exclude t -> Exclude.any_required_capability t
      | Extension t -> Extension.any_required_capability t
      | Function t -> Function.any_required_capability t
      | Graph t -> Graph.any_required_capability t
      | Group t -> Group.any_required_capability t
      | Image t -> Image.any_required_capability t
      | Memory t -> Memory.any_required_capability t
      | Miscellaneous t -> Miscellaneous.any_required_capability t
      | Mode_setting t -> Mode_setting.any_required_capability t
      | Non_uniform t -> Non_uniform.any_required_capability t
      | Pipe t -> Pipe.any_required_capability t
      | Primitive t -> Primitive.any_required_capability t
      | Relational_and_logical t ->
          Relational_and_logical.any_required_capability t
      | Reserved t -> Reserved.any_required_capability t
      | Tensor t -> Tensor.any_required_capability t
      | Type_declaration t -> Type_declaration.any_required_capability t
  end